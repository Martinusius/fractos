<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;

            background-color: black;
        }

        canvas {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }
    </style>


    <script type="x-shader/x-fragment" id="sdf">
        /*float sdf(vec3 z) {
            const int iterations = 8;

            z *= cos(z.x * -0.8 + z.z * 0.8 - z.y * 0.8) * 0.2 + 0.8;

            for(int i = 0; i < iterations; ++i) {
                z = abs(z);

                z = rotateX(z, -0.1);

                if(z.x - z.y < 0.0) z.xy = z.yx;
                if(z.x - z.z < 0.0) z.xz = z.zx;
                if(z.y - z.z < 0.0) z.zy = z.yz;

                z = rotateY(z, -0.1);

                z.z -= 2.0 / 3.0;
                z.z = -abs(z.z);
                z.z += 1.0 / 3.0;

                z *= vec3(3, 3, 3);
                z += vec3(-2.5, -2, -0.5);

                z = rotateZ(-z, -0.1);
        
                //if(z.z > 1.0 * sdf_offset) z.z -= 2.0 * sdf_offset;
            }
        
            return box(z * pow(3.0, float(-iterations)), vec3(pow(3.0, float(-iterations))));
        }*/
        
        /*float sdf(vec3 z) {
            const int iterations = 12;
            const float scale = 1.5;

           

            z *= -1.0;

            z *= cos(z.x * -0.4 + z.z * 0.4) * 0.2 + 0.8;
            z.y *= 0.8;

           

            //z.x = mod(z.x + 1.0, 2.0) - 1.0;

            float minimum = 4.0;

            for(int i = 0; i < iterations; ++i) {
                minimum = min(minimum,  box(z * pow(scale, float(-i)), vec3(pow(scale, float(-i)))));

                if(z.x - z.y > 0.0) z.xy = z.yx;
                if(z.x - z.z > 0.0) z.xz = z.zx;


                z *= scale;
                z += vec3(2, -1, -1);

                //z += vec3(2, 0, 0);

               

            }

            minimum = min(minimum,  box(z * pow(scale, float(-iterations)), vec3(pow(scale, float(-iterations)))));

            return minimum * 0.8;
        }*/

        float sdf(vec3 z) {
            const int iterations = 16;

            for(int i = 0; i < iterations; i++) {
                //z = rotateZ(z, 45.0);

                z = abs(z);

                if(z.x - z.y < 0.0) z.xy = z.yx;
                if(z.x - z.z < 0.0) z.xz = z.zx;
                if(z.y - z.z < 0.0) z.zy = z.yz;

                /*z.z -= 1.0 / 3.0;
                z.z = -abs(z.z);
                z.z += 1.0 / 3.0;*/


                z *= vec3(3, 3, 3);
                z += vec3(-2, -1, 0);
                
            }
        
            return box(z * pow(3.0, -float(iterations)), vec3(pow(3.0, -float(iterations))));
        }

        vec3 csdf(vec3 z) {
            return vec3(1);
        }
    </script>

    <script src="./three.min.js"></script>
    <script src="../dist/fractos.min.js"></script>
    <script>
        const canvas = Fractos.init('body');

        
        function getEnvMap(url, positive = 'p', negative = 'n') {
            const r = url;
            const urls = [r + positive + "x.jpg", r + negative + "x.jpg", r + positive + "y.jpg", r + negative + "y.jpg", r + positive + "z.jpg", r + negative + "z.jpg"];

            textureCube = new THREE.CubeTextureLoader().load(urls);
            textureCube.format = THREE.RGBFormat;
            textureCube.mapping = THREE.CubeReflectionMapping;
            textureCube.encoding = THREE.sRGBEncoding;

            return textureCube;
        }

        //const background = new ImageBackground(getEnvMap('https://playground.babylonjs.com/textures/skybox_'));
        //const background = new ImageBackground(getEnvMap('https://threejs.org/examples/textures/cube/skyboxsun25deg/'));
        const background = new Fractos.ColorBackground(new THREE.Color(1, 1, 1));

        const fractal = new Fractos.Menger(8);


        fractal.transform2 = ['rotateX(-10)', 'absZ'];

        // const fractal = new CustomSDF(document.getElementById('sdf').textContent);

       

        const renderer = new Fractos.RealtimeRenderer(fractal, background);
        renderer.animationDuration = 100;

        renderer.color = new THREE.Color(0.7, 0.7, 0.7);
        renderer.enableShadows = true;
        renderer.framerate = 0;

        renderer.sunDirection = new THREE.Vector3(-1, -1, -3);

        Fractos.camera.position.set(0, 0, 2);
        Fractos.camera.lookAt(new THREE.Vector3(0, 0, 0));
        Fractos.camera.fov = 55;

       

        const pathTracer = new Fractos.PathTracer(fractal, background);
        pathTracer.color = renderer.color;
        pathTracer.roughness = 1;
        pathTracer.sunDirection = renderer.sunDirection;
        pathTracer.rayDepth = 3;

        renderer.postprocess = [];

        pathTracer.pixelDivisions = 8;
        pathTracer.sunStrength = 1;
        pathTracer.backgroundMultiplier = 1;
        pathTracer.sunColor = new THREE.Color(1, 1, 0.8);


        let capturing = false;
        let recordingPath = false;
        
        const animationPath = [];

        renderer.start(() => {});
        Fractos.controls.enabled = true;

        document.addEventListener('keydown', event => {
            if(event.key.toLowerCase() === 'c') {
                capturing = !capturing;

                if(capturing) {
                    renderer.timer.stop();
                    pathTracer.renderImage(1080, 1080, renderer.time / renderer.animationDuration)
                        .then(image => image.postprocess('uchimura', 'vignette(0.7, 0.5)').show()).catch(() => {});
                    Fractos.controls.enabled = true;
                }
                else {
                    renderer.start();
                    renderer.timer.start();
                }
            }
            else if(event.key === ' ') {
                if(capturing) return;

                Fractos.controls.enabled = !Fractos.controls.enabled;
            }
            else if(event.key.toLowerCase() === 'p') {
                recordingPath = !recordingPath;

                if(recordingPath) animationPath.length = 0;

                renderer.start(recordingPath ? () => {
                    const point = { position: new THREE.Vector3(), direction: new THREE.Vector3(), time: renderer.time / renderer.animationDuration };

                    Fractos.camera.getWorldPosition(point.position);
                    Fractos.camera.getWorldDirection(point.direction);

                    animationPath.push(point);
                } : () => {});
            }
            else if(event.key.toLowerCase() === 'f') {
                capturing = !capturing;

                if(capturing) {
                    renderer.timer.stop();
                    
                    let index = 0;

                    pathTracer.renderAnimation(1080, 1080, animationPath).catch(() => {});
                    
                    Fractos.controls.enabled = true;
                }
                else {
                    renderer.start();
                    renderer.timer.start();
                }
            }
            else if(event.key.toLowerCase() === 'g') {
                pathTracer.lastImage.download();
            }
            else if(event.key.toLowerCase() === 'l') {
                renderer.sunDirection.set(-Fractos.camera.position.x, -Fractos.camera.position.y, -Fractos.camera.position.z);
                pathTracer.sunDirection.set(-Fractos.camera.position.x, -Fractos.camera.position.y, -Fractos.camera.position.z);
            }
        });
    </script>
</body>
</html>