var Vn=Object.defineProperty;var Wn=(qt,tr,O)=>tr in qt?Vn(qt,tr,{enumerable:!0,configurable:!0,writable:!0,value:O}):qt[tr]=O;var we=(qt,tr,O)=>(Wn(qt,typeof tr!="symbol"?tr+"":tr,O),O);(function(qt,tr){typeof exports=="object"&&typeof module!="undefined"?tr(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],tr):(qt=typeof globalThis!="undefined"?globalThis:qt||self,tr(qt.Fractos={},qt.THREE))})(this,function(exports,THREE){var tr;"use strict";function _interopNamespace(O){if(O&&O.__esModule)return O;var C=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});return O&&Object.keys(O).forEach(function(A){if(A!=="default"){var z=Object.getOwnPropertyDescriptor(O,A);Object.defineProperty(C,A,z.get?z:{enumerable:!0,get:function(){return O[A]}})}}),C.default=O,Object.freeze(C)}var THREE__namespace=_interopNamespace(THREE),colorBackground=`uniform vec3 bg_color;

vec3 background(vec3 direction) {\r
    return bg_color;\r
}`,hemisphereBackground=`uniform vec3 bg_top;\r
uniform vec3 bg_bottom;\r
uniform float bg_blendAngle;

vec3 background(vec3 direction) {\r
    float angle = atan(direction.y / length(direction.xz));\r
    return mix(bg_bottom, bg_top, clamp((angle + bg_blendAngle) / 2.0 / bg_blendAngle, 0.0, 1.0));\r
}`,imageBackground=`uniform samplerCube bg_image;

vec3 background(vec3 direction) {\r
    return texture(bg_image, direction).xyz;\r
}`;class Background{}class ColorBackground extends Background{constructor(A){super();we(this,"glsl",colorBackground);we(this,"color");this.color=A}}class HemisphereBackground extends Background{constructor(A,z,I=.1){super();we(this,"glsl",hemisphereBackground);we(this,"top");we(this,"bottom");we(this,"blendAngle");this.top=A,this.bottom=z,this.blendAngle=I}}class ImageBackground extends Background{constructor(A){super();we(this,"glsl",imageBackground);we(this,"image");this.image=A}}const _changeEvent={type:"change"},_startEvent={type:"start"},_endEvent={type:"end"};class OrbitControls extends THREE.EventDispatcher{constructor(C,A){super(),A===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),A===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=C,this.domElement=A,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return te.phi},this.getAzimuthalAngle=function(){return te.theta},this.listenToKeyEvents=function(Re){Re.addEventListener("keydown",Mr),this._domElementKeyEvents=Re},this.saveState=function(){z.target0.copy(z.target),z.position0.copy(z.object.position),z.zoom0=z.object.zoom},this.reset=function(){z.target.copy(z.target0),z.object.position.copy(z.position0),z.object.zoom=z.zoom0,z.object.updateProjectionMatrix(),z.dispatchEvent(_changeEvent),z.update(),L=I.NONE},this.update=function(){const Re=new THREE.Vector3,Nt=new THREE.Quaternion().setFromUnitVectors(C.up,new THREE.Vector3(0,1,0)),Zt=Nt.clone().invert(),er=new THREE.Vector3,yr=new THREE.Quaternion,Sr=2*Math.PI;return function(){const Nr=z.object.position;Re.copy(Nr).sub(z.target),Re.applyQuaternion(Nt),te.setFromVector3(Re),z.autoRotate&&L===I.NONE&&Ze(Ve()),z.enableDamping?(te.theta+=ne.theta*z.dampingFactor,te.phi+=ne.phi*z.dampingFactor):(te.theta+=ne.theta,te.phi+=ne.phi);let ur=z.minAzimuthAngle,cr=z.maxAzimuthAngle;return isFinite(ur)&&isFinite(cr)&&(ur<-Math.PI?ur+=Sr:ur>Math.PI&&(ur-=Sr),cr<-Math.PI?cr+=Sr:cr>Math.PI&&(cr-=Sr),ur<=cr?te.theta=Math.max(ur,Math.min(cr,te.theta)):te.theta=te.theta>(ur+cr)/2?Math.max(ur,te.theta):Math.min(cr,te.theta)),te.phi=Math.max(z.minPolarAngle,Math.min(z.maxPolarAngle,te.phi)),te.makeSafe(),te.radius*=ie,te.radius=Math.max(z.minDistance,Math.min(z.maxDistance,te.radius)),z.enableDamping===!0?z.target.addScaledVector(oe,z.dampingFactor):z.target.add(oe),Re.setFromSpherical(te),Re.applyQuaternion(Zt),Nr.copy(z.target).add(Re),z.object.lookAt(z.target),z.enableDamping===!0?(ne.theta*=1-z.dampingFactor,ne.phi*=1-z.dampingFactor,oe.multiplyScalar(1-z.dampingFactor)):(ne.set(0,0,0),oe.set(0,0,0)),ie=1,ue||er.distanceToSquared(z.object.position)>K||8*(1-yr.dot(z.object.quaternion))>K?(z.dispatchEvent(_changeEvent),er.copy(z.object.position),yr.copy(z.object.quaternion),ue=!1,!0):!1}}(),this.dispose=function(){z.domElement.removeEventListener("contextmenu",Wr),z.domElement.removeEventListener("pointerdown",xr),z.domElement.removeEventListener("wheel",ir),z.domElement.removeEventListener("touchstart",Cr),z.domElement.removeEventListener("touchend",kr),z.domElement.removeEventListener("touchmove",Rr),z.domElement.ownerDocument.removeEventListener("pointermove",fr),z.domElement.ownerDocument.removeEventListener("pointerup",vr),z._domElementKeyEvents!==null&&z._domElementKeyEvents.removeEventListener("keydown",Mr)};const z=this,I={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let L=I.NONE;const K=1e-6,te=new THREE.Spherical,ne=new THREE.Spherical;let ie=1;const oe=new THREE.Vector3;let ue=!1;const de=new THREE.Vector2,he=new THREE.Vector2,fe=new THREE.Vector2,be=new THREE.Vector2,xe=new THREE.Vector2,Se=new THREE.Vector2,Fe=new THREE.Vector2,Ce=new THREE.Vector2,Ge=new THREE.Vector2;function Ve(){return 2*Math.PI/60/60*z.autoRotateSpeed}function pt(){return Math.pow(.95,z.zoomSpeed)}function Ze(Re){ne.theta-=Re}function ct(Re){ne.phi-=Re}const Xe=function(){const Re=new THREE.Vector3;return function(Zt,er){Re.setFromMatrixColumn(er,0),Re.multiplyScalar(-Zt),oe.add(Re)}}(),We=function(){const Re=new THREE.Vector3;return function(Zt,er){z.screenSpacePanning===!0?Re.setFromMatrixColumn(er,1):(Re.setFromMatrixColumn(er,0),Re.crossVectors(z.object.up,Re)),Re.multiplyScalar(Zt),oe.add(Re)}}(),Mt=function(){const Re=new THREE.Vector3;return function(Zt,er){const yr=z.domElement;if(z.object.isPerspectiveCamera){const Sr=z.object.position;Re.copy(Sr).sub(z.target);let zr=Re.length();zr*=Math.tan(z.object.fov/2*Math.PI/180),Xe(2*Zt*zr/yr.clientHeight,z.object.matrix),We(2*er*zr/yr.clientHeight,z.object.matrix)}else z.object.isOrthographicCamera?(Xe(Zt*(z.object.right-z.object.left)/z.object.zoom/yr.clientWidth,z.object.matrix),We(er*(z.object.top-z.object.bottom)/z.object.zoom/yr.clientHeight,z.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),z.enablePan=!1)}}();function jt(Re){z.object.isPerspectiveCamera?ie/=Re:z.object.isOrthographicCamera?(z.object.zoom=Math.max(z.minZoom,Math.min(z.maxZoom,z.object.zoom*Re)),z.object.updateProjectionMatrix(),ue=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),z.enableZoom=!1)}function At(Re){z.object.isPerspectiveCamera?ie*=Re:z.object.isOrthographicCamera?(z.object.zoom=Math.max(z.minZoom,Math.min(z.maxZoom,z.object.zoom/Re)),z.object.updateProjectionMatrix(),ue=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),z.enableZoom=!1)}function _t(Re){de.set(Re.clientX,Re.clientY)}function It(Re){Fe.set(Re.clientX,Re.clientY)}function zt(Re){be.set(Re.clientX,Re.clientY)}function xt(Re){he.set(Re.clientX,Re.clientY),fe.subVectors(he,de).multiplyScalar(z.rotateSpeed);const Nt=z.domElement;Ze(2*Math.PI*fe.x/Nt.clientHeight),ct(2*Math.PI*fe.y/Nt.clientHeight),de.copy(he),z.update()}function Lt(Re){Ce.set(Re.clientX,Re.clientY),Ge.subVectors(Ce,Fe),Ge.y>0?jt(pt()):Ge.y<0&&At(pt()),Fe.copy(Ce),z.update()}function dt(Re){xe.set(Re.clientX,Re.clientY),Se.subVectors(xe,be).multiplyScalar(z.panSpeed),Mt(Se.x,Se.y),be.copy(xe),z.update()}function Pt(Re){Re.deltaY<0?At(pt()):Re.deltaY>0&&jt(pt()),z.update()}function br(Re){let Nt=!1;switch(Re.code){case z.keys.UP:Mt(0,z.keyPanSpeed),Nt=!0;break;case z.keys.BOTTOM:Mt(0,-z.keyPanSpeed),Nt=!0;break;case z.keys.LEFT:Mt(z.keyPanSpeed,0),Nt=!0;break;case z.keys.RIGHT:Mt(-z.keyPanSpeed,0),Nt=!0;break}Nt&&(Re.preventDefault(),z.update())}function Ht(Re){if(Re.touches.length==1)de.set(Re.touches[0].pageX,Re.touches[0].pageY);else{const Nt=.5*(Re.touches[0].pageX+Re.touches[1].pageX),Zt=.5*(Re.touches[0].pageY+Re.touches[1].pageY);de.set(Nt,Zt)}}function nr(Re){if(Re.touches.length==1)be.set(Re.touches[0].pageX,Re.touches[0].pageY);else{const Nt=.5*(Re.touches[0].pageX+Re.touches[1].pageX),Zt=.5*(Re.touches[0].pageY+Re.touches[1].pageY);be.set(Nt,Zt)}}function hr(Re){const Nt=Re.touches[0].pageX-Re.touches[1].pageX,Zt=Re.touches[0].pageY-Re.touches[1].pageY,er=Math.sqrt(Nt*Nt+Zt*Zt);Fe.set(0,er)}function pr(Re){z.enableZoom&&hr(Re),z.enablePan&&nr(Re)}function mr(Re){z.enableZoom&&hr(Re),z.enableRotate&&Ht(Re)}function wr(Re){if(Re.touches.length==1)he.set(Re.touches[0].pageX,Re.touches[0].pageY);else{const Zt=.5*(Re.touches[0].pageX+Re.touches[1].pageX),er=.5*(Re.touches[0].pageY+Re.touches[1].pageY);he.set(Zt,er)}fe.subVectors(he,de).multiplyScalar(z.rotateSpeed);const Nt=z.domElement;Ze(2*Math.PI*fe.x/Nt.clientHeight),ct(2*Math.PI*fe.y/Nt.clientHeight),de.copy(he)}function gr(Re){if(Re.touches.length==1)xe.set(Re.touches[0].pageX,Re.touches[0].pageY);else{const Nt=.5*(Re.touches[0].pageX+Re.touches[1].pageX),Zt=.5*(Re.touches[0].pageY+Re.touches[1].pageY);xe.set(Nt,Zt)}Se.subVectors(xe,be).multiplyScalar(z.panSpeed),Mt(Se.x,Se.y),be.copy(xe)}function dr(Re){const Nt=Re.touches[0].pageX-Re.touches[1].pageX,Zt=Re.touches[0].pageY-Re.touches[1].pageY,er=Math.sqrt(Nt*Nt+Zt*Zt);Ce.set(0,er),Ge.set(0,Math.pow(Ce.y/Fe.y,z.zoomSpeed)),jt(Ge.y),Fe.copy(Ce)}function Ar(Re){z.enableZoom&&dr(Re),z.enablePan&&gr(Re)}function Fr(Re){z.enableZoom&&dr(Re),z.enableRotate&&wr(Re)}function xr(Re){if(z.enabled!==!1)switch(Re.pointerType){case"mouse":case"pen":or(Re);break}}function fr(Re){if(z.enabled!==!1)switch(Re.pointerType){case"mouse":case"pen":ar(Re);break}}function vr(Re){switch(Re.pointerType){case"mouse":case"pen":lr();break}}function or(Re){Re.preventDefault(),z.domElement.focus?z.domElement.focus():window.focus();let Nt;switch(Re.button){case 0:Nt=z.mouseButtons.LEFT;break;case 1:Nt=z.mouseButtons.MIDDLE;break;case 2:Nt=z.mouseButtons.RIGHT;break;default:Nt=-1}switch(Nt){case THREE.MOUSE.DOLLY:if(z.enableZoom===!1)return;It(Re),L=I.DOLLY;break;case THREE.MOUSE.ROTATE:if(Re.ctrlKey||Re.metaKey||Re.shiftKey){if(z.enablePan===!1)return;zt(Re),L=I.PAN}else{if(z.enableRotate===!1)return;_t(Re),L=I.ROTATE}break;case THREE.MOUSE.PAN:if(Re.ctrlKey||Re.metaKey||Re.shiftKey){if(z.enableRotate===!1)return;_t(Re),L=I.ROTATE}else{if(z.enablePan===!1)return;zt(Re),L=I.PAN}break;default:L=I.NONE}L!==I.NONE&&(z.domElement.ownerDocument.addEventListener("pointermove",fr),z.domElement.ownerDocument.addEventListener("pointerup",vr),z.dispatchEvent(_startEvent))}function ar(Re){if(z.enabled!==!1)switch(Re.preventDefault(),L){case I.ROTATE:if(z.enableRotate===!1)return;xt(Re);break;case I.DOLLY:if(z.enableZoom===!1)return;Lt(Re);break;case I.PAN:if(z.enablePan===!1)return;dt(Re);break}}function lr(Re){z.domElement.ownerDocument.removeEventListener("pointermove",fr),z.domElement.ownerDocument.removeEventListener("pointerup",vr),z.enabled!==!1&&(z.dispatchEvent(_endEvent),L=I.NONE)}function ir(Re){z.enabled===!1||z.enableZoom===!1||L!==I.NONE&&L!==I.ROTATE||(Re.preventDefault(),z.dispatchEvent(_startEvent),Pt(Re),z.dispatchEvent(_endEvent))}function Mr(Re){z.enabled===!1||z.enablePan===!1||br(Re)}function Cr(Re){if(z.enabled!==!1){switch(Re.preventDefault(),Re.touches.length){case 1:switch(z.touches.ONE){case THREE.TOUCH.ROTATE:if(z.enableRotate===!1)return;Ht(Re),L=I.TOUCH_ROTATE;break;case THREE.TOUCH.PAN:if(z.enablePan===!1)return;nr(Re),L=I.TOUCH_PAN;break;default:L=I.NONE}break;case 2:switch(z.touches.TWO){case THREE.TOUCH.DOLLY_PAN:if(z.enableZoom===!1&&z.enablePan===!1)return;pr(Re),L=I.TOUCH_DOLLY_PAN;break;case THREE.TOUCH.DOLLY_ROTATE:if(z.enableZoom===!1&&z.enableRotate===!1)return;mr(Re),L=I.TOUCH_DOLLY_ROTATE;break;default:L=I.NONE}break;default:L=I.NONE}L!==I.NONE&&z.dispatchEvent(_startEvent)}}function Rr(Re){if(z.enabled!==!1)switch(Re.preventDefault(),L){case I.TOUCH_ROTATE:if(z.enableRotate===!1)return;wr(Re),z.update();break;case I.TOUCH_PAN:if(z.enablePan===!1)return;gr(Re),z.update();break;case I.TOUCH_DOLLY_PAN:if(z.enableZoom===!1&&z.enablePan===!1)return;Ar(Re),z.update();break;case I.TOUCH_DOLLY_ROTATE:if(z.enableZoom===!1&&z.enableRotate===!1)return;Fr(Re),z.update();break;default:L=I.NONE}}function kr(Re){z.enabled!==!1&&(z.dispatchEvent(_endEvent),L=I.NONE)}function Wr(Re){z.enabled!==!1&&Re.preventDefault()}z.domElement.addEventListener("contextmenu",Wr),z.domElement.addEventListener("pointerdown",xr),z.domElement.addEventListener("wheel",ir,{passive:!1}),z.domElement.addEventListener("touchstart",Cr,{passive:!1}),z.domElement.addEventListener("touchend",kr),z.domElement.addEventListener("touchmove",Rr,{passive:!1}),this.update()}}var CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`};class Pass{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const _camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),_geometry$1=new THREE.BufferGeometry;_geometry$1.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),_geometry$1.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2));class FullScreenQuad{constructor(C){this._mesh=new THREE.Mesh(_geometry$1,C)}dispose(){this._mesh.geometry.dispose()}render(C){C.render(this._mesh,_camera)}get material(){return this._mesh.material}set material(C){this._mesh.material=C}}class ShaderPass extends Pass{constructor(C,A){super(),this.textureID=A!==void 0?A:"tDiffuse",C instanceof THREE.ShaderMaterial?(this.uniforms=C.uniforms,this.material=C):C&&(this.uniforms=THREE.UniformsUtils.clone(C.uniforms),this.material=new THREE.ShaderMaterial({defines:Object.assign({},C.defines),uniforms:this.uniforms,vertexShader:C.vertexShader,fragmentShader:C.fragmentShader})),this.fsQuad=new FullScreenQuad(this.material)}render(C,A,z){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=z.texture),this.fsQuad.material=this.material,this.renderToScreen?(C.setRenderTarget(null),this.fsQuad.render(C)):(C.setRenderTarget(A),this.clear&&C.clear(C.autoClearColor,C.autoClearDepth,C.autoClearStencil),this.fsQuad.render(C))}}class MaskPass extends Pass{constructor(C,A){super(),this.scene=C,this.camera=A,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(C,A,z){const I=C.getContext(),L=C.state;L.buffers.color.setMask(!1),L.buffers.depth.setMask(!1),L.buffers.color.setLocked(!0),L.buffers.depth.setLocked(!0);let K,te;this.inverse?(K=0,te=1):(K=1,te=0),L.buffers.stencil.setTest(!0),L.buffers.stencil.setOp(I.REPLACE,I.REPLACE,I.REPLACE),L.buffers.stencil.setFunc(I.ALWAYS,K,4294967295),L.buffers.stencil.setClear(te),L.buffers.stencil.setLocked(!0),C.setRenderTarget(z),this.clear&&C.clear(),C.render(this.scene,this.camera),C.setRenderTarget(A),this.clear&&C.clear(),C.render(this.scene,this.camera),L.buffers.color.setLocked(!1),L.buffers.depth.setLocked(!1),L.buffers.stencil.setLocked(!1),L.buffers.stencil.setFunc(I.EQUAL,1,4294967295),L.buffers.stencil.setOp(I.KEEP,I.KEEP,I.KEEP),L.buffers.stencil.setLocked(!0)}}class ClearMaskPass extends Pass{constructor(){super(),this.needsSwap=!1}render(C){C.state.buffers.stencil.setLocked(!1),C.state.buffers.stencil.setTest(!1)}}class EffectComposer{constructor(C,A){if(this.renderer=C,A===void 0){const z={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},I=C.getSize(new THREE.Vector2);this._pixelRatio=C.getPixelRatio(),this._width=I.width,this._height=I.height,A=new THREE.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,z),A.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=A.width,this._height=A.height;this.renderTarget1=A,this.renderTarget2=A.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],CopyShader===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),ShaderPass===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new ShaderPass(CopyShader),this.clock=new THREE.Clock}swapBuffers(){const C=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=C}addPass(C){this.passes.push(C),C.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(C,A){this.passes.splice(A,0,C),C.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(C){const A=this.passes.indexOf(C);A!==-1&&this.passes.splice(A,1)}isLastEnabledPass(C){for(let A=C+1;A<this.passes.length;A++)if(this.passes[A].enabled)return!1;return!0}render(C){C===void 0&&(C=this.clock.getDelta());const A=this.renderer.getRenderTarget();let z=!1;for(let I=0,L=this.passes.length;I<L;I++){const K=this.passes[I];if(K.enabled!==!1){if(K.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(I),K.render(this.renderer,this.writeBuffer,this.readBuffer,C,z),K.needsSwap){if(z){const te=this.renderer.getContext(),ne=this.renderer.state.buffers.stencil;ne.setFunc(te.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,C),ne.setFunc(te.EQUAL,1,4294967295)}this.swapBuffers()}MaskPass!==void 0&&(K instanceof MaskPass?z=!0:K instanceof ClearMaskPass&&(z=!1))}}this.renderer.setRenderTarget(A)}reset(C){if(C===void 0){const A=this.renderer.getSize(new THREE.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=A.width,this._height=A.height,C=this.renderTarget1.clone(),C.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=C,this.renderTarget2=C.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(C,A){this._width=C,this._height=A;const z=this._width*this._pixelRatio,I=this._height*this._pixelRatio;this.renderTarget1.setSize(z,I),this.renderTarget2.setSize(z,I);for(let L=0;L<this.passes.length;L++)this.passes[L].setSize(z,I)}setPixelRatio(C){this._pixelRatio=C,this.setSize(this._width,this._height)}}new THREE.OrthographicCamera(-1,1,1,-1,0,1);const _geometry=new THREE.BufferGeometry;_geometry.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),_geometry.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2));class RenderPass extends Pass{constructor(C,A,z,I,L){super(),this.scene=C,this.camera=A,this.overrideMaterial=z,this.clearColor=I,this.clearAlpha=L!==void 0?L:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new THREE.Color}render(C,A,z){const I=C.autoClear;C.autoClear=!1;let L,K;this.overrideMaterial!==void 0&&(K=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(C.getClearColor(this._oldClearColor),L=C.getClearAlpha(),C.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&C.clearDepth(),C.setRenderTarget(this.renderToScreen?null:z),this.clear&&C.clear(C.autoClearColor,C.autoClearDepth,C.autoClearStencil),C.render(this.scene,this.camera),this.clearColor&&C.setClearColor(this._oldClearColor,L),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=K),C.autoClear=I}}const SMAAEdgesShader={defines:{SMAA_THRESHOLD:"0.1"},uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`},SMAAWeightsShader={defines:{SMAA_MAX_SEARCH_STEPS:"8",SMAA_AREATEX_MAX_DISTANCE:"16",SMAA_AREATEX_PIXEL_SIZE:"( 1.0 / vec2( 160.0, 560.0 ) )",SMAA_AREATEX_SUBTEX_SIZE:"( 1.0 / 7.0 )"},uniforms:{tDiffuse:{value:null},tArea:{value:null},tSearch:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`},SMAABlendShader={uniforms:{tDiffuse:{value:null},tColor:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`};class SMAAPass extends Pass{constructor(C,A){super(),this.edgesRT=new THREE.WebGLRenderTarget(C,A,{depthBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBFormat}),this.edgesRT.texture.name="SMAAPass.edges",this.weightsRT=new THREE.WebGLRenderTarget(C,A,{depthBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.weightsRT.texture.name="SMAAPass.weights";const z=this,I=new Image;I.src=this.getAreaTexture(),I.onload=function(){z.areaTexture.needsUpdate=!0},this.areaTexture=new THREE.Texture,this.areaTexture.name="SMAAPass.area",this.areaTexture.image=I,this.areaTexture.format=THREE.RGBFormat,this.areaTexture.minFilter=THREE.LinearFilter,this.areaTexture.generateMipmaps=!1,this.areaTexture.flipY=!1;const L=new Image;L.src=this.getSearchTexture(),L.onload=function(){z.searchTexture.needsUpdate=!0},this.searchTexture=new THREE.Texture,this.searchTexture.name="SMAAPass.search",this.searchTexture.image=L,this.searchTexture.magFilter=THREE.NearestFilter,this.searchTexture.minFilter=THREE.NearestFilter,this.searchTexture.generateMipmaps=!1,this.searchTexture.flipY=!1,SMAAEdgesShader===void 0&&console.error("THREE.SMAAPass relies on SMAAShader"),this.uniformsEdges=THREE.UniformsUtils.clone(SMAAEdgesShader.uniforms),this.uniformsEdges.resolution.value.set(1/C,1/A),this.materialEdges=new THREE.ShaderMaterial({defines:Object.assign({},SMAAEdgesShader.defines),uniforms:this.uniformsEdges,vertexShader:SMAAEdgesShader.vertexShader,fragmentShader:SMAAEdgesShader.fragmentShader}),this.uniformsWeights=THREE.UniformsUtils.clone(SMAAWeightsShader.uniforms),this.uniformsWeights.resolution.value.set(1/C,1/A),this.uniformsWeights.tDiffuse.value=this.edgesRT.texture,this.uniformsWeights.tArea.value=this.areaTexture,this.uniformsWeights.tSearch.value=this.searchTexture,this.materialWeights=new THREE.ShaderMaterial({defines:Object.assign({},SMAAWeightsShader.defines),uniforms:this.uniformsWeights,vertexShader:SMAAWeightsShader.vertexShader,fragmentShader:SMAAWeightsShader.fragmentShader}),this.uniformsBlend=THREE.UniformsUtils.clone(SMAABlendShader.uniforms),this.uniformsBlend.resolution.value.set(1/C,1/A),this.uniformsBlend.tDiffuse.value=this.weightsRT.texture,this.materialBlend=new THREE.ShaderMaterial({uniforms:this.uniformsBlend,vertexShader:SMAABlendShader.vertexShader,fragmentShader:SMAABlendShader.fragmentShader}),this.needsSwap=!1,this.fsQuad=new FullScreenQuad(null)}render(C,A,z){this.uniformsEdges.tDiffuse.value=z.texture,this.fsQuad.material=this.materialEdges,C.setRenderTarget(this.edgesRT),this.clear&&C.clear(),this.fsQuad.render(C),this.fsQuad.material=this.materialWeights,C.setRenderTarget(this.weightsRT),this.clear&&C.clear(),this.fsQuad.render(C),this.uniformsBlend.tColor.value=z.texture,this.fsQuad.material=this.materialBlend,this.renderToScreen?(C.setRenderTarget(null),this.fsQuad.render(C)):(C.setRenderTarget(A),this.clear&&C.clear(),this.fsQuad.render(C))}setSize(C,A){this.edgesRT.setSize(C,A),this.weightsRT.setSize(C,A),this.materialEdges.uniforms.resolution.value.set(1/C,1/A),this.materialWeights.uniforms.resolution.value.set(1/C,1/A),this.materialBlend.uniforms.resolution.value.set(1/C,1/A)}getAreaTexture(){return"data:image/png;base64,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"}getSearchTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="}}const renderer=new THREE__namespace.WebGLRenderer({antialias:!1,preserveDrawingBuffer:!0,powerPreference:"high-performance"}),screenSize=new THREE__namespace.Vector2;renderer.extensions.get("EXT_color_buffer_float");let element;function init$1(O){return element=document.querySelector(O),element?(renderer.setSize(element.clientWidth,element.clientHeight),element.appendChild(renderer.domElement),renderer.domElement.style.position="absolute",new ResizeObserver(()=>{if(!element)return;screenSize.set(element.clientWidth-1,element.clientHeight-1);const A=new THREE__namespace.Vector2;renderer.getSize(A);const z=Math.max(A.x/screenSize.x,A.y/screenSize.y);renderer.domElement.style.width=A.x/z+"px",renderer.domElement.style.height=A.y/z+"px"}).observe(element),renderer.domElement):void 0}function fullscreen(){init$1("body"),document.body.style.width="100%",document.body.style.height="100%",document.body.style.margin="0",document.body.style.overflow="hidden",document.documentElement.style.width="100%",document.documentElement.style.height="100%",document.documentElement.style.margin="0",document.documentElement.style.overflow="hidden"}function setResolution(O,C,A=!0){if(renderer.setSize(O,C),effectsComposer.setSize(O,C),camera.aspect=O/C,camera.updateProjectionMatrix(),!A)return;const z=Math.max(O/screenSize.x,C/screenSize.y);renderer.domElement.style.width=O/z+"px",renderer.domElement.style.height=C/z+"px"}const quadScene=new THREE__namespace.Scene,ortho=new THREE__namespace.OrthographicCamera(-1,1,1,-1,0,1),camera=new THREE__namespace.PerspectiveCamera(90,document.body.clientWidth/document.body.clientHeight,.01,10);camera.position.set(2,2,2),camera.lookAt(new THREE__namespace.Vector3(0,0,0));const controls=new OrbitControls(camera,renderer.domElement),quad=new THREE__namespace.Mesh(new THREE__namespace.PlaneBufferGeometry(2,2,1,1));quadScene.add(quad);function setShader(O){quad.material=O}function createShader(O,C={}){const A=new THREE__namespace.ShaderMaterial({uniforms:{resolution:{value:new THREE__namespace.Vector2},cameraPos:{value:new THREE__namespace.Vector3},cameraDirection:{value:new THREE__namespace.Vector3},fov:{value:0},modelView:{value:new THREE__namespace.Matrix4},projection:{value:new THREE__namespace.Matrix4},...C},vertexShader:`void main(){
gl_Position = vec4(position, 1.0);
}
`,fragmentShader:O});return setShader(A),A}const effectsComposer=new EffectComposer(renderer);effectsComposer.addPass(new RenderPass(quadScene,ortho)),effectsComposer.addPass(new SMAAPass(document.body.clientWidth,document.body.clientHeight));function render(O,C=null){quad.material=O,renderer.setRenderTarget(C),renderer.getSize(quad.material.uniforms.resolution.value),quad.material.uniforms.cameraPos.value.copy(camera.position),camera.getWorldDirection(quad.material.uniforms.cameraDirection.value),quad.material.uniforms.fov.value=camera.fov/180*Math.PI,quad.material.uniforms.projection.value=camera.projectionMatrix,renderer.render(quadScene,ortho)}function renderAA(O,C=null){quad.material=O,renderer.setRenderTarget(C),renderer.getSize(quad.material.uniforms.resolution.value),quad.material.uniforms.cameraPos.value.copy(camera.position),camera.getWorldDirection(quad.material.uniforms.cameraDirection.value),quad.material.uniforms.fov.value=camera.fov/180*Math.PI,quad.material.uniforms.projection.value=camera.projectionMatrix,effectsComposer.render()}class Utils{static objectToUniforms(C,A=""){const z={};for(const[I,L]of Object.entries(C))L instanceof Array||(z[A+I]={value:L});return z}static setUniformsFromObject(C,A,z=""){for(const[I,L]of Object.entries(A))L instanceof Array||(C.uniforms[z+I]={value:L})}static createUniformsFromVariables(C,...A){const z={};return A.forEach(I=>{z[I]={value:C[I]}}),z}static setUniformsFromVariables(C,A,...z){z.forEach(I=>{C.uniforms[I].value=A[I]})}}new THREE__namespace.Scene;var functions=`const _ANIMATION = "clamp(step - (steps -= 1.0), 0.0, 1.0)";\r
const _STEPS = [];

function float(arg) {\r
  return String(arg).replace(/(?<![a-zA-Z\\.\\d])(\\d+)(?![\\.\\d])/g, "$1.0");\r
}

function isNumber(n) {\r
  return !isNaN(parseFloat(n)) && isFinite(n);\r
}

/*function union(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Union: Radius must be a number");\r
  if (radius < 0) throw new Error("Union: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length === 1) throw new Error("Intersection requires at least 2 objects");\r
  if (objects.length === 2) return radius > 0 ? \`smoothUnion(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`_union(\${objects[0]}, \${objects[1]})\`;

  const [firstObject, ...otherObjects] = objects;

  if (otherObjects.length === 0) return firstObject;

  return _VERIFY + (radius > 0 ? \`smoothUnion(\${firstObject}, \${union(otherObjects)}, \${float(radius)} / data.s)\` : \`_union(\${firstObject}, \${union(otherObjects)})\`);\r
}

function intersection(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Intersection: Radius must be a number");\r
  if (radius < 0) throw new Error("Intersection: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length === 1) throw new Error("Intersection requires at least 2 objects");\r
  if (objects.length === 2) return radius > 0 ? \`smoothIntersection(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`intersection(\${objects[0]}, \${objects[1]})\`;

  const [firstObject, ...otherObjects] = objkects;

  if (otherObjects.length === 0) return firstObject;

  return _VERIFY + (radius > 0 ? \`smoothIntersection(\${firstObject}, \${intersection(otherObjects)}, \${float(radius)} / data.s)\` : \`intersection(\${firstObject}, \${intersection(otherObjects)})\`);\r
}

function difference(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Difference: Radius must be a number");\r
  if (radius < 0) throw new Error("Difference: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length !== 2) throw new Error("Difference requires exactly 2 objects");

  return _VERIFY + (radius > 0 ? \`smoothDifference(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`difference(\${objects[0]}, \${objects[1]})\`);\r
}*/

function shape(u) {\r
  _STEPS.push(\`dist = min(dist, \${u})\`);\r
}

function sphere(properties = {}) {\r
  properties.radius = properties.radius ?? 1;

  shape(\`sphere(data.z, \${float(properties.radius)}) * data.s\`);\r
}

function tetrahedron(properties = {}) {\r
  properties.radius = properties.radius ?? 1;

  shape(\`tetrahedron(data.z, \${float(properties.radius)}) * data.s\`);\r
}

function box(properties = {}) {\r
  properties.size = properties.size ?? [1, 1, 1];

  shape(\`box(data.z, vec3(\${properties.size\r
    .map((coord) => \`\${float(coord)}\`)\r
    .join(", ")})) * data.s\`);\r
}

function cube(properties = {}) {\r
  properties.center = properties.center ?? [0, 0, 0];\r
  properties.size = properties.size ?? 1;

  box({ center: properties.center, size: [properties.size, properties.size, properties.size] });\r
}

function torus(properties = {}) {\r
  properties.center = properties.center ?? [0, 0, 0];\r
  properties.radius = properties.radius ?? 1;\r
  properties.tube = properties.tube ?? 0.25;

  shape(\`torus(data.z, vec2(\${float(properties.radius)}, \${float(properties.tube)})) * data.s\`);\r
}

function scale(value) {\r
  if(arguments.length !== 1) throw new Error("Scale: Requires 1 argument");

  _STEPS.push(\`scale(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translate(x, y, z) {\r
  if(arguments.length !== 3) throw new Error("Translate: Requires 3 arguments");

  _STEPS.push(\`translate(data, \${float(x)}, \${float(y)}, \${float(z)}, \${_ANIMATION})\`);\r
}

function translateX(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateX: Requires 1 argument");

  _STEPS.push(\`translateX(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translateY(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateY: Requires 1 argument");

  _STEPS.push(\`translateY(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translateZ(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateZ: Requires 1 argument");

  _STEPS.push(\`translateZ(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateX(value) {\r
  if(arguments.length !== 1) throw new Error("RotateX: Requires 1 argument");

  _STEPS.push(\`rotateX(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateY(value) {\r
  if(arguments.length !== 1) throw new Error("RotateY: Requires 1 argument");

  _STEPS.push(\`rotateY(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateZ(value) {\r
  if(arguments.length !== 1) throw new Error("RotateZ: Requires 1 argument");

  _STEPS.push(\`rotateZ(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function mirror(nx, ny, nz) {\r
  if(arguments.length !== 3) throw new Error("Mirror: Requires 3 arguments");

  const s = Math.sqrt(nx * nx + ny * ny + nz * nz);

  _STEPS.push(\`mirror(data, \${float(nx / s)}, \${float(ny / s)}, \${float(nz / s)}, \${_ANIMATION})\`);\r
}

function mirrorUp() {\r
  mirror(0, 1, 0);\r
}

function mirrorDown() {\r
  mirror(0, -1, 0);\r
}

function mirrorLeft() {\r
  mirror(-1, 0, 0);\r
}

function mirrorRight() {\r
  mirror(1, 0, 0);\r
}

function mirrorFront() {\r
  mirror(0, 0, 1);\r
}

function mirrorBack() {\r
  mirror(0, 0, -1);\r
}`;let getRandomValues;const rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto!="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}const byteToHex=[];for(let O=0;O<256;++O)byteToHex.push((O+256).toString(16).slice(1));function unsafeStringify(O,C=0){return byteToHex[O[C+0]]+byteToHex[O[C+1]]+byteToHex[O[C+2]]+byteToHex[O[C+3]]+"-"+byteToHex[O[C+4]]+byteToHex[O[C+5]]+"-"+byteToHex[O[C+6]]+byteToHex[O[C+7]]+"-"+byteToHex[O[C+8]]+byteToHex[O[C+9]]+"-"+byteToHex[O[C+10]]+byteToHex[O[C+11]]+byteToHex[O[C+12]]+byteToHex[O[C+13]]+byteToHex[O[C+14]]+byteToHex[O[C+15]]}const randomUUID=typeof crypto!="undefined"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var native={randomUUID};function v4(O,C,A){if(native.randomUUID&&!C&&!O)return native.randomUUID();O=O||{};const z=O.random||(O.rng||rng)();if(z[6]=z[6]&15|64,z[8]=z[8]&63|128,C){A=A||0;for(let I=0;I<16;++I)C[A+I]=z[I];return C}return unsafeStringify(z)}function limitEval(O,C,A){let z=Math.random()+1,I=new Blob(["onmessage=function(a){a=a.data;postMessage({i:a.i+1});postMessage({r:eval.call(this,a.c),i:a.i});};"],{type:"text/javascript"}),L=new Worker(URL.createObjectURL(I));function K(te){URL.revokeObjectURL(I),C(te)}L.onmessage=function(te){te=te.data,te&&(te.i===z?(z=0,K(te.r)):te.i===z+1&&setTimeout(function(){z&&(L.terminate(),K(void 0))},A||1e3))},L.postMessage({c:O,i:z})}function iteratize(O){const C={},A=[];let z=0,I="";O.forEach(ie=>{C[ie]===void 0&&(C[ie]=z++,A.push(ie)),I+=String.fromCharCode(C[ie]+65)});function L(ie){let oe="";for(let ue=0;ue<ie.length;ue++)ie[ue]==="@"?oe+="@":oe+=A[ie.charCodeAt(ue)-65]+`
`;return oe}let K;for(let ie=32;ie>1;ie--){const oe=I.match(new RegExp(`(.+)(?=\\1{${ie}})`,"g"));if(oe){const ue=L(I.replace(new RegExp(`(${oe[0]}){${ie+1}}`,"g"),"@")),de=v4();K=ue.replace("@",`/* BEGIN ITERATION ${de} */ for(int i = 0; i < ${ie+1}; i++) {
${L(oe[0])}
} /* END ITERATION ${de} */
`);break}}const te=K!==void 0;K||(K=L(I));const ne=K.split(`
`);return{success:te,steps:ne.slice(0,ne.length-1)}}class UncompiledSDF{constructor(C){this.instructions=C}}class __SDF{constructor(code=""){we(this,"glsl");we(this,"stepCount");code instanceof Function&&(code=__SDF.stripFunction(code));const steps=code instanceof UncompiledSDF?code.instructions.reverse():eval(`${functions} ;; ${code} ;;  _STEPS`).reverse();let iteratization={success:!0,steps};for(;(iteratization=iteratize(iteratization.steps)).success;);this.stepCount=iteratization.steps.length,this.glsl=`
    
    uniform int iterations;
    uniform float step;

    float sdf(vec3 z) {
      SDF data = SDF(z, 1.0);

      float dist = 1000.0;

      float steps = ${iteratization.steps.length}.0;
      
      ${iteratization.steps.join(`;
`)+`;
`}

      return dist;
    }`}static stripFunction(O){const C=O.toString();return C.slice(C.indexOf("{")+1,C.lastIndexOf("}"))}static createInSandbox(O){return O instanceof Function&&(O=__SDF.stripFunction(O)),new Promise(C=>{limitEval(`${functions} ;; ${O} ;;  _STEPS`,A=>{C(new __SDF(new UncompiledSDF(A)))},100)})}}var simple=`uniform vec3 sunDirection;\r
uniform vec3 sunColor;\r
uniform float aoStrength;\r
uniform bool enableShadows;\r
uniform float roughness;

uniform vec3 color;

float calculateDirectLight(vec3 position, vec3 normal, float epsilon) {\r
    if(enableShadows) {\r
        Ray shadowRay = raycastEpsilon(position + normal * 2.0 * epsilon, -sunDirection, epsilon);\r
        return shadowRay.hit ? 0.0 : max(dot(normal, -sunDirection), 0.0);\r
    }\r
    else {\r
        return max(dot(normal, -sunDirection), 0.0);\r
    }\r
}\r

float statixAO(vec3 p, vec3 n, float k, float delta) {\r
    float sum = 0.0;\r
    for(int i = 1; i <= 5; ++i) {\r
        float fi = float(i);\r
        sum += pow(2.0, -fi) * (fi * delta - sdf(p + n * fi * delta));\r
    }\r
    return 1.0 - k * sum;\r
}

/*float tracerAO(vec3 position, vec3 normal, float epsilon) {

    float luminance = 1.0;

    for(int i = 0; i < 5; ++i) {\r
        Ray tracer = raycastEpsilon(position + normal * 2.0 * epsilon, normal, epsilon);

        if(!tracer.hit) break;

        luminance *= 0.5;\r
        position = tracer.position;\r
        normal = normalize(tracer.normal);\r
    }

    return luminance;\r
    

}*/

uniform int pixelDivisions;

vec3 shading() {\r
    vec3 total = vec3(0);

    for(int x = 0; x < pixelDivisions; x++) {\r
        for(int y = 0; y < pixelDivisions; y++) {\r
            seed = subpixelCoord(x, y, pixelDivisions);\r
            vec3 rayDirection = subpixelDirection(x, x, pixelDivisions);

            Ray ray = raycast(cameraPos, rayDirection);

            if(ray.hit) {\r
                if(ray.steps == 0.0) {\r
                    return vec3(0);\r
                }

                const int samples = 4;\r
                vec3 backgroundAverage = vec3(0);\r
                float lerpFactor = roughness * roughness;

                vec3 reflected = reflect(ray.direction, ray.normal);

                for(int i = 0; i < samples; ++i)  {\r
                    vec3 random = normalize(rand3() * 2.0 - 1.0); 
                    backgroundAverage += linear(background(normalize(mix(reflected, random, lerpFactor)))) * mix(max(dot(reflected, ray.normal), 0.0), 1.0, lerpFactor);\r
                }

                vec3 scolor = linear(color);\r

                vec3 indirect = (backgroundAverage / float(samples)) * scolor * pow(ray.steps, -0.6);\r
                vec3 direct = calculateDirectLight(ray.position, ray.normal, ray.epsilon) * scolor;\r
            \r
                total += indirect + direct;\r
            }\r
            else {\r
                total += background(ray.direction);\r
            }\r
        }\r
    }

    return total / float(pixelDivisions * pixelDivisions);\r
    \r
    
    \r
    \r
}`;let autoResize=!1;function setAutoResize(O){autoResize=O}const qt=class{static loop(C,A=()=>{}){qt.cleanup(),qt.callback=C,qt.cleanup=A}static cancel(){qt.callback=()=>{},qt.cleanup(),qt.cleanup=()=>{}}static once(C){qt.callback=()=>{C(),this.callback=()=>{}}}};let Queue=qt;we(Queue,"callback",()=>{}),we(Queue,"cleanup",()=>{});function animator(){requestAnimationFrame(animator);const O=new THREE__namespace.Vector2;renderer.getSize(O),autoResize&&!screenSize.equals(O)&&setResolution(screenSize.x,screenSize.y,!1),Queue.callback()}animator();var _core=`uniform vec2 resolution;\r
uniform vec3 cameraPos;\r
uniform vec3 cameraDirection;\r
uniform float fov;\r
uniform float time;

uniform bool adaptiveEpsilon;\r
uniform float epsilonScale;\r
uniform float epsilon;

const float PI = 3.1415926535897932384626433832795;\r
const float DEG_TO_RAD = PI / 180.0;\r

const int maximumRaySteps = 16536;

float sdf(vec3 position);\r
vec3 background(vec3 direction);

vec3 calculateNormal(vec3 position, float minDist) {\r
    vec2 h = vec2(minDist, 0.0);\r
    return normalize(vec3(sdf(position + h.xyy) - sdf(position - h.xyy),\r
                           sdf(position + h.yxy) - sdf(position - h.yxy),\r
                           sdf(position + h.yyx) - sdf(position - h.yyx)));\r
}

vec3 trap;

vec2 seed = vec2(0);\r
float rand() { \r
    seed += vec2(-0.1, 0.1);\r
    return fract(sin(dot(seed, vec2(12.9898, 4.1414))) * 43758.5453);\r
}

vec2 rand2() {\r
    return vec2(rand(), rand());\r
}

vec3 rand3() {\r
    return vec3(rand(), rand(), rand());\r
}

vec3 sphericalRand() {\r
    float z = rand() * 2.0 - 1.0;\r
    float rxy = sqrt(1.0 - z * z);\r
    float phi = rand() * 2.0 * PI;\r
    float x = rxy * cos(phi);\r
    float y = rxy * sin(phi);

    return vec3(x, y, z);\r
}\r

struct Ray {\r
    vec3 origin;\r
    vec3 direction;

    float closest;

    vec3 closestPoint;

    bool hit;\r
    vec3 position;\r
    vec3 normal;\r
    float steps;

    float epsilon;\r
};

mat3 cameraMatrix(vec3 direction) {\r
    vec3 cw = direction;\r
    vec3 cp = vec3(0.0, 1.0, 0.0);\r
    vec3 cu = normalize(cross(cw, cp));\r
    vec3 cv = cross(cu, cw);\r
    return mat3(cu, cv, cw);\r
}

vec2 subpixelCoord(int x, int y, int divisions) {\r
    float subpixelSize = 1.0 / float(divisions);\r
    vec2 offset = vec2(subpixelSize * (float(x) + 0.5) - 0.5, subpixelSize * (float(y) + 0.5) - 0.5);\r
    return gl_FragCoord.xy + offset;\r
}

vec3 subpixelDirection(int x, int y, int divisions) {\r
    mat3 view = cameraMatrix(cameraDirection);\r
    vec2 uv = (subpixelCoord(x, y, divisions) / resolution) * 2.0 - 1.0;\r
    uv.x *= resolution.x / resolution.y;\r
    return view * normalize(vec3(uv, 1.0 / tan(fov / 2.0)));\r
}\r

vec3 pixelDirection() {\r
    mat3 view = cameraMatrix(cameraDirection);\r
    vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;\r
    uv.x *= resolution.x / resolution.y;\r
    return view * normalize(vec3(uv, 1.0 / tan(fov / 2.0)));\r
}

vec2 directionPixel(vec3 position, vec3 cameraPos, vec3 cameraDir) {\r
    mat3 inverseView = inverse(cameraMatrix(cameraDir));\r
    vec3 toPos = normalize(position - cameraPos);\r
    vec3 fromCameraDir = inverseView * toPos;

    float zDistance = 1.0 / tan(fov / 2.0);\r
    vec2 uv = (fromCameraDir * zDistance / fromCameraDir.z).xy;\r
    uv /= resolution.x / resolution.y;\r
    return (uv + 1.0) / 2.0;\r
}\r

/*uniform int orbitSampler;\r
uniform int orbitMapping;

vec3 sampleOrbit(vec3 a, vec3 b) {\r
    switch (orbitSampler) {\r
    case 0:\r
        return min(a, b);\r
    case 1:\r
        return max(a, b);\r
    case 2:\r
        return a + b;\r
    case 3:\r
        return min(abs(a), abs(b));\r
    case 4:\r
        return max(abs(a), abs(b));\r
    case 5:\r
        return abs(a) + abs(b);\r
    }\r
}

float mapOrbit(float x) {\r
    switch (orbitMapping) {\r
    case 0:\r
        return 1.0 / 3.0;\r
    case 1:\r
        return x;\r
    case 2:\r
        return 1.0 / (1.0 + pow(2.71828182846, -x));\r
    case 3:\r
        return x / (x + 1.0);\r
    }\r
}

vec3 mapToChannels(vec3 color1, vec3 color2, vec3 color3, vec3 map) {\r
    return (mapOrbit(map.x) * color1 + mapOrbit(map.y) * color2 + mapOrbit(map.z) * color3);\r
}*/\r

Ray raycast(vec3 origin, vec3 direction) {\r
    Ray data;\r
    data.origin = origin;\r
    data.direction = direction;

    if(!adaptiveEpsilon)\r
        data.epsilon = epsilon;

    float totalDistance = 0.0;\r
    float closest = 100.0;\r
    float closestT = 0.0;

    for (int steps = 0; steps < maximumRaySteps; ++steps) {\r
        vec3 currentPosition = origin + totalDistance * direction;

        if(totalDistance > 100.0)\r
            break;

        float currentDistance = sdf(currentPosition);

        if(currentDistance < closest) {\r
            closest = currentDistance;\r
            closestT = totalDistance;\r
        }

        
        totalDistance += max(0.0, (steps < 1 ? rand() * currentDistance : currentDistance));

        if(steps == 0) {\r
            if(currentDistance < 0.0) {\r
                data.hit = true;\r
                data.position = origin;\r
                data.normal = vec3(0);\r
                data.steps = 0.0;\r
                data.closest = 0.0;\r
                data.closestPoint = data.position;

                return data;\r
            }

            if(adaptiveEpsilon)\r
                data.epsilon = currentDistance * epsilonScale;\r
        }\r
        else if(currentDistance < data.epsilon) {\r
            data.hit = true;\r
            data.position = origin + totalDistance * direction;\r
            data.normal = calculateNormal(data.position, data.epsilon);\r
            data.steps = float(steps) + currentDistance / data.epsilon;\r
            data.closest = 0.0;\r
            data.closestPoint = data.position;

            return data;\r
        }\r
    }

    float l = closestT - closest;\r
    float r = closestT + closest;

    for(int i = 0; i < 10; i++) {\r
        float ld = sdf(origin + l * direction);\r
        float rd = sdf(origin + r * direction);

        if(ld < rd) {\r
            r = (l + r) / 2.0;\r
        }\r
        else {\r
            l = (l + r) / 2.0;\r
        }\r
    }

    data.closestPoint = origin + (l + r) / 2.0 * direction;

    data.closest = sdf(origin + (l + r) / 2.0 * direction);\r
    data.hit = false;\r
    return data;\r
}

float linear(float x) {\r
    if (x <= 0.04045)\r
        return x / 12.92;\r
    else\r
        return pow((x + 0.055) / 1.055, 2.4);\r
}

vec3 linear(vec3 color) {\r
    return vec3(linear(color.r), linear(color.g), linear(color.b));\r
}

Ray raycastEpsilon(vec3 origin, vec3 direction, float epsilon) {\r
    Ray data;\r
    data.origin = origin;\r
    data.direction = direction;\r
    data.epsilon = epsilon;

    float totalDistance = 0.0;\r
      float closest = 100.0;\r
    for (int steps = 0; steps < maximumRaySteps; ++steps) {\r
        vec3 currentPosition = origin + totalDistance * direction;

        if(totalDistance > 100.0)\r
            break;

        float currentDistance = sdf(currentPosition);\r
        closest = min(closest, currentDistance);

        
        totalDistance += max(0.0, (steps < 1 ? rand() * currentDistance : currentDistance));

        if(steps == 0) {\r
            if(currentDistance < 0.0) {\r
                data.hit = true;\r
                data.position = origin;\r
                data.normal = vec3(0);\r
                data.steps = 0.0;

                return data;\r
            }

        }\r
        else if(currentDistance < data.epsilon) {\r
            data.hit = true;\r
            data.position = origin + totalDistance * direction;\r
            data.normal = calculateNormal(data.position, data.epsilon);\r
            data.steps = float(steps) + currentDistance / data.epsilon;

            return data;\r
        }\r
    }

    data.closest = closest;\r
    data.hit = false;\r
    return data;\r
}

Ray pixelRaycast() {\r
    return raycast(cameraPos, pixelDirection());\r
}\r

vec3 shading();

void main() {        \r
    gl_FragColor = vec4(shading(), 1);\r
}`,primitives=`float smoothUnion( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r
    return mix( d2, d1, h ) - k*h*(1.0-h); }

float smoothDifference( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\r
    return mix( d1, -d2, h ) + k*h*(1.0-h);\r
}

float smoothIntersection( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\r
    return mix( d2, d1, h ) + k*h*(1.0-h);\r
}

float _union(float a, float b) {\r
    return min(a, b);\r
}

float difference(float a, float b) {\r
    return max(a, -b);\r
}

float intersection(float a, float b) {\r
    return max(a, b);\r
}

mat4 rotationMatrix(vec3 axis, float angle) {\r
    axis = normalize(axis);\r
    float s = sin(angle);\r
    float c = cos(angle);\r
    float oc = 1.0 - c;\r
    \r
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r
                0.0,                                0.0,                                0.0,                                1.0);\r
}\r

float between(float a, float b) {\r
    return mix(a, b, mod(time, 1.0));\r
}

vec3 between(vec3 a, vec3 b) {\r
    return mix(a, b, mod(time, 1.0));\r
}\r

float sphere(vec3 p, float r) {\r
    return length(p) - r;\r
}

float box(vec3 p, vec3 b) {\r
    vec3 q = abs(p) - b;\r
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\r
}

float cube(vec3 p, float b) {\r
    return box(p, vec3(b));\r
}

float torus(vec3 p, vec2 t){\r
  vec2 q = vec2(length(p.xz)-t.x,p.y);\r
  return length(q)-t.y;\r
}\r

float tetrahedron(vec3 p, float r) {\r
    float md = max(max(-p.x + p.y - p.z, p.x - p.y - p.z),\r
              max(-p.x - p.y + p.z, p.x + p.y + p.z));\r
    return (md - r) / sqrt(3.0);\r
}

float octahedron(vec3 p, float s) {\r
    p = abs(p);\r
    float m = p.x + p.y + p.z - s;\r
    vec3 q;\r
        if(3.0 * p.x < m) q = p.xyz;\r
    else if(3.0 * p.y < m) q = p.yzx;\r
    else if(3.0 * p.z < m) q = p.zxy;\r
    else return m*0.57735027;\r
        \r
    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s); \r
    return length(vec3(q.x, q.y - s + k, q.z - k)); \r
}\r

struct SDF {\r
    vec3 z;\r
    float s;\r
};

void translate(inout SDF sdf, float x, float y, float z, float animation) {\r
    sdf.z += animation * vec3(x, -y, z);\r
}

void translateX(inout SDF sdf, float x, float animation) {\r
    sdf.z.x += animation * x;\r
}

void translateY(inout SDF sdf, float y, float animation) {\r
    sdf.z.y -= animation * y;\r
}

void translateZ(inout SDF sdf, float z, float animation) {\r
    sdf.z.z += animation * z;\r
}

void scale(inout SDF sdf, float v, float animation) {\r
    sdf.z /= mix(1.0, v, animation);\r
    sdf.s *= mix(1.0, v, animation);\r
}

void mirror(inout SDF sdf, float x, float y, float z, float animation) {\r
    vec3 n = vec3(x, -y, z);

    float d = min(0.0, dot(sdf.z, n));\r
    sdf.z = sdf.z - animation * 2.0 * d * n;\r
}

void rotateX(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(1, 0, 0), angle * DEG_TO_RAD * animation)).xyz;\r
}\r
void rotateY(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(0, 1, 0), angle * DEG_TO_RAD * animation)).xyz;\r
}\r
void rotateZ(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(0, 0, 1), angle * DEG_TO_RAD * animation)).xyz;\r
}

void rotate(inout SDF sdf, float ax, float ay, float az, float angle, float animation) {\r
    vec3 a = normalize(vec3(ax, ay, az));\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(a, angle * DEG_TO_RAD * animation)).xyz;\r
}`;const core=_core+primitives;var postprocess=`uniform vec2 resolution;\r
uniform sampler2D data;

vec3 reinhard(vec3 x) {\r
    return x / (1.0 + x);\r
}

vec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\r
    float l0 = ((P - m) * l) / a;\r
    float L0 = m - m / a;\r
    float L1 = m + (1.0 - m) / a;\r
    float S0 = m + l0;\r
    float S1 = m + a * l0;\r
    float C2 = (a * P) / (P - S1);\r
    float CP = -C2 / P;

    vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\r
    vec3 w2 = vec3(step(m + l0, x));\r
    vec3 w1 = vec3(1.0 - w0 - w2);

    vec3 T = vec3(m * pow(x / m, vec3(c)) + b);\r
    vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\r
    vec3 L = vec3(m + a * (x - m));

    return T * w0 + L * w1 + S * w2;\r
}

vec3 uchimura(vec3 x) {\r
    const float P = 1.0;  
    const float a = 1.0;  
    const float m = 0.22; 
    const float l = 0.4;  
    const float c = 1.33; 
    const float b = 0.0;  

    return uchimura(x, P, a, m, l, c, b);\r
}

vec3 aces(vec3 x) {\r
    const float a = 2.51;\r
    const float b = 0.03;\r
    const float c = 2.43;\r
    const float d = 0.59;\r
    const float e = 0.14;\r
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\r
}

vec3 contrast(vec3 color, float contrast) {\r
    return (color - 0.5) * max(contrast, 0.0) + 0.5;\r
}

vec3 brightness(vec3 color, float brightness) {\r
    return color * max(brightness, 0.0);\r
}

vec3 add(vec3 color, float r, float g, float b) {\r
    return color + vec3(r, g, b);\r
}

vec3 add(vec3 color, float l) {\r
    return color + l;\r
}\r

vec3 filmic(vec3 x) {\r
    vec3 X = max(vec3(0.0), x - 0.004);\r
    vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r
    return pow(result, vec3(2.2));\r
}

vec3 vignette(vec3 color, float radius, float smoothness) {\r
    vec2 uv = gl_FragCoord.xy / resolution.xy;

    float diff = radius - distance(uv, vec2(0.5, 0.5));\r
    return color * smoothstep(-smoothness, smoothness, diff);\r
}\r

vec3 hsv2rgb(vec3 c) {\r
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r
}

vec3 rgb2hsv(vec3 c) {\r
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);\r
    float e = 1.0e-10;\r
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r
}

vec3 saturation(vec3 color, float saturation) {\r
    if(color.r == color.g && color.r == color.b) return color;\r
    vec3 hsv = rgb2hsv(color);\r
    hsv.y *= saturation;\r
    return hsv2rgb(hsv); \r
}\r

float sRGB(float x) {\r
    if (x <= 0.00031308)\r
        return 12.92 * x;\r
    else\r
        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\r
}\r

vec3 sRGB(vec3 c) {\r
    return vec3(sRGB(c.x), sRGB(c.y), sRGB(c.z));\r
}\r

void main() {\r
    vec2 uv = gl_FragCoord.xy / resolution.xy;\r
    vec3 color = texture2D(data, uv).xyz;

    POSTPROCESS

    gl_FragColor = vec4(color, 1);\r
}`,copyGLSL=`uniform vec2 resolution;\r
uniform sampler2D data;

void main() {\r
    gl_FragColor = texture(data, gl_FragCoord.xy / resolution);\r
}`;const copyShader=createShader(copyGLSL,{data:{value:null}});function copyAA(O,C){O instanceof THREE__namespace.WebGLRenderTarget&&(O=O.texture),copyShader.uniforms.data.value=O,renderAA(copyShader,C)}function downloadCanvas(O){const C=document.createElement("a");C.download=O,C.href=renderer.domElement.toDataURL(),C.click(),C.remove()}function downloadJSON(O,C){const A=document.createElement("a");A.href="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(O)),A.download=C,A.click(),A.remove()}class TemporaryImage{constructor(C){we(this,"texture");we(this,"postprocessing",[]);C instanceof THREE__namespace.WebGLRenderTarget&&(C=C.texture),this.texture=C}postprocess(...C){return this.postprocessing.push(...C),this}renderToScreen(){const C=["reinhard","filmic","aces","uchimura","contrast","brightness","saturation","vignette","add","sRGB"],A=this.postprocessing.map(I=>{if(!I.trim())return"// Empty postprocessing step";const L=I.match(/(.*)\((.*)\)/),K=L?L[1]:I;if(!C.includes(K))throw new Error(`Invalid postprocessing step: ${I}`);return I=I.replace(/([^a-zA-Z\.\d])(\d+)([^\.\d])/g,"$1$2.0$3"),L?L[2].trim()===""?"color = "+I.replace(/\(/,"(color")+";":"color = "+I.replace(/\(/,"(color, ")+";":`color = ${I}(color);`}),z=createShader(postprocess.replace(/POSTPROCESS/,A.join(`
`)),{data:{value:this.texture}});render(z,null)}download(){return this.renderToScreen(),downloadCanvas("image.png"),this}show(){return this.renderToScreen(),this}}class Timer{constructor(){we(this,"startTime",this.time());we(this,"running",!0);we(this,"stoppedTime",0)}time(){return performance.now()/1e3}stop(){!this.running||(this.stoppedTime=this.get(),this.running=!1)}start(){this.running||(this.running=!0,this.set(this.stoppedTime))}toggle(){this.running?this.stop():this.start()}reset(){this.running?this.startTime=this.time():this.stoppedTime=0}set(C){this.running?this.startTime=this.time()-C:this.stoppedTime=C}get(){return this.running?this.time()-this.startTime:this.stoppedTime}}function normalize(O){return O.normalize(),O}class RealtimeRenderer{constructor(C=new __SDF("cube()"),A=new ColorBackground(new THREE__namespace.Color("white"))){we(this,"shader");we(this,"target");we(this,"_background");we(this,"_sdf");we(this,"enableShadows",!0);we(this,"aoStrength",1);we(this,"sunDirection",new THREE__namespace.Vector3(-.5,-2,-1));we(this,"sunColor",new THREE__namespace.Vector3(1,1,1));we(this,"roughness",1);we(this,"epsilon",1e-4);we(this,"adaptiveEpsilon",!0);we(this,"epsilonScale",5e-4);we(this,"color",new THREE__namespace.Color(1,1,1));we(this,"pixelDivisions",1);we(this,"timer",new Timer);we(this,"animationDuration",1);we(this,"lastImage",null);we(this,"postprocess",[]);we(this,"step");const z=new THREE__namespace.Vector2;renderer.getSize(z),this.target=new THREE__namespace.WebGLRenderTarget(z.x,z.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this._sdf=C,this._background=A,this.step=this._sdf.stepCount,this.shader=this.initShader()}set sdf(C){this._sdf=C,this.step=C.stepCount,this.shader.fragmentShader=core+simple+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}set background(C){this._background=C,this.shader.fragmentShader=core+simple+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}get sdf(){return this._sdf}get background(){return this._background}get time(){return this.timer.get()}set time(C){this.timer.set(C)}initShader(){return createShader(core+simple+this._sdf.glsl+this._background.glsl,{rasterizerColor:{value:null},rasterizerDepth:{value:null},sunDirection:{value:normalize(this.sunDirection)},time:{value:0},...Utils.createUniformsFromVariables(this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions"),...Utils.objectToUniforms(this._background,"bg_")})}renderImage(C,A,z=0){Queue.cancel(),setAutoResize(!1),setResolution(C,A);const I=new THREE__namespace.Vector2(C,A),L=new THREE__namespace.Vector2(this.target.texture.image.width,this.target.texture.image.height);return I.equals(L)||(this.target.dispose(),this.target=new THREE__namespace.WebGLRenderTarget(I.x,I.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),Utils.setUniformsFromObject(this.shader,this.background,"bg_"),this.shader.uniforms.time.value=z,this.shader.uniforms.sunDirection.value=normalize(this.sunDirection),Utils.setUniformsFromVariables(this.shader,this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions"),render(this.shader,this.target),this.lastImage=new TemporaryImage(this.target),this.lastImage}start(C=()=>{}){setAutoResize(!0),Queue.loop(()=>{C();const A=new THREE__namespace.Vector2;renderer.getSize(A);const z=new THREE__namespace.Vector2(this.target.texture.image.width,this.target.texture.image.height);A.equals(z)||(this.target.dispose(),this.target=new THREE__namespace.WebGLRenderTarget(A.x,A.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),Utils.setUniformsFromObject(this.shader,this.background,"bg_"),this.shader.uniforms.time.value=this.time/this.animationDuration,this.shader.uniforms.rasterizerColor.value=this.target.texture,this.shader.uniforms.sunDirection.value=normalize(this.sunDirection),Utils.setUniformsFromVariables(this.shader,this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions"),render(this.shader,this.target),this.lastImage=new TemporaryImage(this.target),this.lastImage.postprocess("sRGB",...this.postprocess).show()})}}var pathTracer=`uniform vec2 offset;\r
uniform vec2 size;

uniform sampler2D previousFrame;\r
uniform int sampleIndex;\r
uniform int pixelDivisions;

uniform int rayDepth;\r
uniform float roughness;\r
uniform vec3 sunDirection;\r
uniform float sunStrength;\r
uniform float backgroundMultiplier;

uniform vec3 color;

uniform vec3 emissionR;\r
uniform vec3 emissionG;\r
uniform vec3 emissionB;

#define PI 3.141592653589\r
#define E 2.718281828459

vec3 ortho(vec3 v) {\r
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\r
}\r

vec3 getSampleBiased(vec3 dir, float power) {\r
    dir = normalize(dir);\r
    vec3 o1 = normalize(ortho(dir));\r
    vec3 o2 = normalize(cross(dir, o1));\r
    vec2 r = rand2();\r
    r.x = r.x * 2.0 * PI;\r
    r.y = pow(r.y, 1.0 / (power + 1.0));\r
    float oneminus = sqrt(1.0 - r.y * r.y);\r
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\r
} 

vec3 getCosineWeightedSample(vec3 dir) {\r
    return getSampleBiased(dir, 1.0);\r
}

vec3 sampleBiased(vec3 normal) {\r
    return normalize(normal + sphericalRand());\r
}

vec3 sampleUnbiased(vec3 normal) {\r
    while(true) {\r
        vec3 dir = sphericalRand();\r
        if(dot(normal, dir) > 0.0) return dir;\r
    }

    return vec3(0);\r
}\r

vec3 raytrace(vec3 from, vec3 direction) {\r
    vec3 direct = vec3(0.0);\r
    vec3 luminance = vec3(1.0);

    for (int i = 0; i < rayDepth; i++) {\r
        Ray ray = raycast(from, direction);

        if(ray.hit) {\r
            
            vec3 reflected = reflect(direction, ray.normal);\r
            vec3 sampleDir = sampleBiased(ray.normal);
            float lerpFactor = roughness * roughness;

            vec3 c = linear(color);

            direction = normalize(mix(reflected, sampleDir, lerpFactor)); \r
            luminance *= clamp(c, 0.0, 1.0) * mix(max(dot(ray.normal, direction), 0.0), 1.0, lerpFactor);

            from = ray.position + ray.normal * epsilon;

            
            vec3 sunSampleDir = normalize(-sunDirection);\r
            float sunLight = dot(ray.normal, sunSampleDir);

            Ray directLightRay = raycast(from, sunSampleDir);

            if (sunLight > 0.0 && !directLightRay.hit) {\r
                direct += luminance * sunLight * sunStrength;\r
            }\r
        }

        else {\r
            return direct + luminance * linear(background(direction));\r
        }\r
    }\r
    return direct;\r
}\r

vec3 shading() {\r
    vec3 previousColor = texture2D(previousFrame, gl_FragCoord.xy / resolution).xyz;

    if(\r
        gl_FragCoord.x < offset.x ||\r
        gl_FragCoord.y < offset.y ||\r
        gl_FragCoord.x > offset.x + size.x ||\r
        gl_FragCoord.y > offset.y + size.y\r
    ) {\r
        return previousColor;\r
    }

   

    int subpixelIndex = sampleIndex % (pixelDivisions * pixelDivisions);\r
    int subX = subpixelIndex % pixelDivisions;\r
    int subY = subpixelIndex / pixelDivisions;

    seed = (subpixelCoord(subX, subY, pixelDivisions)) * (1.0 + float(sampleIndex) * 0.001);

    vec3 rayDirection = subpixelDirection(subX, subY, pixelDivisions);

    vec3 pixelColor = raytrace(cameraPos, rayDirection);

    return previousColor * float(sampleIndex) / float(sampleIndex + 1) + pixelColor / float(sampleIndex + 1);

    /*vec3 rayDirection = pixelDirection();

    
    vec3 pixelColor = vec3(0);

    for(int i = 0; i < samplesPerDrawCall; ++i) {\r
        seed = (1.0 * gl_FragCoord.xy) * (1.0 + float(sampleIndex) * 0.1);\r
        pixelColor += raytrace(cameraPos, rayDirection);\r
    }

    
    return previousColor * float(sampleIndex) / float(sampleIndex + samplesPerDrawCall) + pixelColor / float(sampleIndex + samplesPerDrawCall);*/\r
}`,ExtensionType=(O=>(O.Application="application",O.WebGLPipes="webgl-pipes",O.WebGLPipesAdaptor="webgl-pipes-adaptor",O.WebGLSystem="webgl-system",O.WebGPUPipes="webgpu-pipes",O.WebGPUPipesAdaptor="webgpu-pipes-adaptor",O.WebGPUSystem="webgpu-system",O.CanvasSystem="canvas-system",O.CanvasPipesAdaptor="canvas-pipes-adaptor",O.CanvasPipes="canvas-pipes",O.Asset="asset",O.LoadParser="load-parser",O.ResolveParser="resolve-parser",O.CacheParser="cache-parser",O.DetectionParser="detection-parser",O.MaskEffect="mask-effect",O.BlendMode="blend-mode",O.TextureSource="texture-source",O.Environment="environment",O.ShapeBuilder="shape-builder",O))(ExtensionType||{});const normalizeExtension=O=>{if(typeof O=="function"||typeof O=="object"&&O.extension){if(!O.extension)throw new Error("Extension class must have an extension object");O={...typeof O.extension!="object"?{type:O.extension}:O.extension,ref:O}}if(typeof O=="object")O={...O};else throw new Error("Invalid extension type");return typeof O.type=="string"&&(O.type=[O.type]),O},normalizeExtensionPriority=(O,C)=>{var A;return(A=normalizeExtension(O).priority)!=null?A:C},extensions={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...O){return O.map(normalizeExtension).forEach(C=>{C.type.forEach(A=>{var z,I;return(I=(z=this._removeHandlers)[A])==null?void 0:I.call(z,C)})}),this},add(...O){return O.map(normalizeExtension).forEach(C=>{C.type.forEach(A=>{var L,K;const z=this._addHandlers,I=this._queue;z[A]?(K=z[A])==null||K.call(z,C):(I[A]=I[A]||[],(L=I[A])==null||L.push(C))})}),this},handle(O,C,A){var K;const z=this._addHandlers,I=this._removeHandlers;if(z[O]||I[O])throw new Error(`Extension type ${O} already has a handler`);z[O]=C,I[O]=A;const L=this._queue;return L[O]&&((K=L[O])==null||K.forEach(te=>C(te)),delete L[O]),this},handleByMap(O,C){return this.handle(O,A=>{A.name&&(C[A.name]=A.ref)},A=>{A.name&&delete C[A.name]})},handleByNamedList(O,C,A=-1){return this.handle(O,z=>{C.findIndex(L=>L.name===z.name)>=0||(C.push({name:z.name,value:z.ref}),C.sort((L,K)=>normalizeExtensionPriority(K.value,A)-normalizeExtensionPriority(L.value,A)))},z=>{const I=C.findIndex(L=>L.name===z.name);I!==-1&&C.splice(I,1)})},handleByList(O,C,A=-1){return this.handle(O,z=>{C.includes(z.ref)||(C.push(z.ref),C.sort((I,L)=>normalizeExtensionPriority(L,A)-normalizeExtensionPriority(I,A)))},z=>{const I=C.indexOf(z.ref);I!==-1&&C.splice(I,1)})}},browserExt={extension:{type:ExtensionType.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await Promise.resolve().then(function(){return browserAll})}},webworkerExt={extension:{type:ExtensionType.Environment,name:"webworker",priority:0},test:()=>typeof self!="undefined"&&self.WorkerGlobalScope!==void 0,load:async()=>{await Promise.resolve().then(function(){return webworkerAll})}};class ObservablePoint{constructor(C,A,z){this._x=A||0,this._y=z||0,this._observer=C}clone(C){return new ObservablePoint(C!=null?C:this._observer,this._x,this._y)}set(C=0,A=C){return(this._x!==C||this._y!==A)&&(this._x=C,this._y=A,this._observer._onUpdate(this)),this}copyFrom(C){return(this._x!==C.x||this._y!==C.y)&&(this._x=C.x,this._y=C.y,this._observer._onUpdate(this)),this}copyTo(C){return C.set(this._x,this._y),C}equals(C){return C.x===this._x&&C.y===this._y}toString(){return`[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`}get x(){return this._x}set x(C){this._x!==C&&(this._x=C,this._observer._onUpdate(this))}get y(){return this._y}set y(C){this._y!==C&&(this._y=C,this._observer._onUpdate(this))}}var eventemitter3={exports:{}};(function(O){var C=Object.prototype.hasOwnProperty,A="~";function z(){}Object.create&&(z.prototype=Object.create(null),new z().__proto__||(A=!1));function I(ne,ie,oe){this.fn=ne,this.context=ie,this.once=oe||!1}function L(ne,ie,oe,ue,de){if(typeof oe!="function")throw new TypeError("The listener must be a function");var he=new I(oe,ue||ne,de),fe=A?A+ie:ie;return ne._events[fe]?ne._events[fe].fn?ne._events[fe]=[ne._events[fe],he]:ne._events[fe].push(he):(ne._events[fe]=he,ne._eventsCount++),ne}function K(ne,ie){--ne._eventsCount===0?ne._events=new z:delete ne._events[ie]}function te(){this._events=new z,this._eventsCount=0}te.prototype.eventNames=function(){var ie=[],oe,ue;if(this._eventsCount===0)return ie;for(ue in oe=this._events)C.call(oe,ue)&&ie.push(A?ue.slice(1):ue);return Object.getOwnPropertySymbols?ie.concat(Object.getOwnPropertySymbols(oe)):ie},te.prototype.listeners=function(ie){var oe=A?A+ie:ie,ue=this._events[oe];if(!ue)return[];if(ue.fn)return[ue.fn];for(var de=0,he=ue.length,fe=new Array(he);de<he;de++)fe[de]=ue[de].fn;return fe},te.prototype.listenerCount=function(ie){var oe=A?A+ie:ie,ue=this._events[oe];return ue?ue.fn?1:ue.length:0},te.prototype.emit=function(ie,oe,ue,de,he,fe){var be=A?A+ie:ie;if(!this._events[be])return!1;var xe=this._events[be],Se=arguments.length,Fe,Ce;if(xe.fn){switch(xe.once&&this.removeListener(ie,xe.fn,void 0,!0),Se){case 1:return xe.fn.call(xe.context),!0;case 2:return xe.fn.call(xe.context,oe),!0;case 3:return xe.fn.call(xe.context,oe,ue),!0;case 4:return xe.fn.call(xe.context,oe,ue,de),!0;case 5:return xe.fn.call(xe.context,oe,ue,de,he),!0;case 6:return xe.fn.call(xe.context,oe,ue,de,he,fe),!0}for(Ce=1,Fe=new Array(Se-1);Ce<Se;Ce++)Fe[Ce-1]=arguments[Ce];xe.fn.apply(xe.context,Fe)}else{var Ge=xe.length,Ve;for(Ce=0;Ce<Ge;Ce++)switch(xe[Ce].once&&this.removeListener(ie,xe[Ce].fn,void 0,!0),Se){case 1:xe[Ce].fn.call(xe[Ce].context);break;case 2:xe[Ce].fn.call(xe[Ce].context,oe);break;case 3:xe[Ce].fn.call(xe[Ce].context,oe,ue);break;case 4:xe[Ce].fn.call(xe[Ce].context,oe,ue,de);break;default:if(!Fe)for(Ve=1,Fe=new Array(Se-1);Ve<Se;Ve++)Fe[Ve-1]=arguments[Ve];xe[Ce].fn.apply(xe[Ce].context,Fe)}}return!0},te.prototype.on=function(ie,oe,ue){return L(this,ie,oe,ue,!1)},te.prototype.once=function(ie,oe,ue){return L(this,ie,oe,ue,!0)},te.prototype.removeListener=function(ie,oe,ue,de){var he=A?A+ie:ie;if(!this._events[he])return this;if(!oe)return K(this,he),this;var fe=this._events[he];if(fe.fn)fe.fn===oe&&(!de||fe.once)&&(!ue||fe.context===ue)&&K(this,he);else{for(var be=0,xe=[],Se=fe.length;be<Se;be++)(fe[be].fn!==oe||de&&!fe[be].once||ue&&fe[be].context!==ue)&&xe.push(fe[be]);xe.length?this._events[he]=xe.length===1?xe[0]:xe:K(this,he)}return this},te.prototype.removeAllListeners=function(ie){var oe;return ie?(oe=A?A+ie:ie,this._events[oe]&&K(this,oe)):(this._events=new z,this._eventsCount=0),this},te.prototype.off=te.prototype.removeListener,te.prototype.addListener=te.prototype.on,te.prefixed=A,te.EventEmitter=te,O.exports=te})(eventemitter3);var EventEmitter=eventemitter3.exports;const PI_2=Math.PI*2,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;class Point{constructor(C=0,A=0){this.x=0,this.y=0,this.x=C,this.y=A}clone(){return new Point(this.x,this.y)}copyFrom(C){return this.set(C.x,C.y),this}copyTo(C){return C.set(this.x,this.y),C}equals(C){return C.x===this.x&&C.y===this.y}set(C=0,A=C){return this.x=C,this.y=A,this}toString(){return`[pixi.js/math:Point x=${this.x} y=${this.y}]`}static get shared(){return tempPoint.x=0,tempPoint.y=0,tempPoint}}const tempPoint=new Point;class Matrix{constructor(C=1,A=0,z=0,I=1,L=0,K=0){this.array=null,this.a=C,this.b=A,this.c=z,this.d=I,this.tx=L,this.ty=K}fromArray(C){this.a=C[0],this.b=C[1],this.c=C[3],this.d=C[4],this.tx=C[2],this.ty=C[5]}set(C,A,z,I,L,K){return this.a=C,this.b=A,this.c=z,this.d=I,this.tx=L,this.ty=K,this}toArray(C,A){this.array||(this.array=new Float32Array(9));const z=A||this.array;return C?(z[0]=this.a,z[1]=this.b,z[2]=0,z[3]=this.c,z[4]=this.d,z[5]=0,z[6]=this.tx,z[7]=this.ty,z[8]=1):(z[0]=this.a,z[1]=this.c,z[2]=this.tx,z[3]=this.b,z[4]=this.d,z[5]=this.ty,z[6]=0,z[7]=0,z[8]=1),z}apply(C,A){A=A||new Point;const z=C.x,I=C.y;return A.x=this.a*z+this.c*I+this.tx,A.y=this.b*z+this.d*I+this.ty,A}applyInverse(C,A){A=A||new Point;const z=this.a,I=this.b,L=this.c,K=this.d,te=this.tx,ne=this.ty,ie=1/(z*K+L*-I),oe=C.x,ue=C.y;return A.x=K*ie*oe+-L*ie*ue+(ne*L-te*K)*ie,A.y=z*ie*ue+-I*ie*oe+(-ne*z+te*I)*ie,A}translate(C,A){return this.tx+=C,this.ty+=A,this}scale(C,A){return this.a*=C,this.d*=A,this.c*=C,this.b*=A,this.tx*=C,this.ty*=A,this}rotate(C){const A=Math.cos(C),z=Math.sin(C),I=this.a,L=this.c,K=this.tx;return this.a=I*A-this.b*z,this.b=I*z+this.b*A,this.c=L*A-this.d*z,this.d=L*z+this.d*A,this.tx=K*A-this.ty*z,this.ty=K*z+this.ty*A,this}append(C){const A=this.a,z=this.b,I=this.c,L=this.d;return this.a=C.a*A+C.b*I,this.b=C.a*z+C.b*L,this.c=C.c*A+C.d*I,this.d=C.c*z+C.d*L,this.tx=C.tx*A+C.ty*I+this.tx,this.ty=C.tx*z+C.ty*L+this.ty,this}appendFrom(C,A){const z=C.a,I=C.b,L=C.c,K=C.d,te=C.tx,ne=C.ty,ie=A.a,oe=A.b,ue=A.c,de=A.d;return this.a=z*ie+I*ue,this.b=z*oe+I*de,this.c=L*ie+K*ue,this.d=L*oe+K*de,this.tx=te*ie+ne*ue+A.tx,this.ty=te*oe+ne*de+A.ty,this}setTransform(C,A,z,I,L,K,te,ne,ie){return this.a=Math.cos(te+ie)*L,this.b=Math.sin(te+ie)*L,this.c=-Math.sin(te-ne)*K,this.d=Math.cos(te-ne)*K,this.tx=C-(z*this.a+I*this.c),this.ty=A-(z*this.b+I*this.d),this}prepend(C){const A=this.tx;if(C.a!==1||C.b!==0||C.c!==0||C.d!==1){const z=this.a,I=this.c;this.a=z*C.a+this.b*C.c,this.b=z*C.b+this.b*C.d,this.c=I*C.a+this.d*C.c,this.d=I*C.b+this.d*C.d}return this.tx=A*C.a+this.ty*C.c+C.tx,this.ty=A*C.b+this.ty*C.d+C.ty,this}decompose(C){const A=this.a,z=this.b,I=this.c,L=this.d,K=C.pivot,te=-Math.atan2(-I,L),ne=Math.atan2(z,A),ie=Math.abs(te+ne);return ie<1e-5||Math.abs(PI_2-ie)<1e-5?(C.rotation=ne,C.skew.x=C.skew.y=0):(C.rotation=0,C.skew.x=te,C.skew.y=ne),C.scale.x=Math.sqrt(A*A+z*z),C.scale.y=Math.sqrt(I*I+L*L),C.position.x=this.tx+(K.x*A+K.y*I),C.position.y=this.ty+(K.x*z+K.y*L),C}invert(){const C=this.a,A=this.b,z=this.c,I=this.d,L=this.tx,K=C*I-A*z;return this.a=I/K,this.b=-A/K,this.c=-z/K,this.d=C/K,this.tx=(z*this.ty-I*L)/K,this.ty=-(C*this.ty-A*L)/K,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const C=new Matrix;return C.a=this.a,C.b=this.b,C.c=this.c,C.d=this.d,C.tx=this.tx,C.ty=this.ty,C}copyTo(C){return C.a=this.a,C.b=this.b,C.c=this.c,C.d=this.d,C.tx=this.tx,C.ty=this.ty,C}copyFrom(C){return this.a=C.a,this.b=C.b,this.c=C.c,this.d=C.d,this.tx=C.tx,this.ty=C.ty,this}equals(C){return C.a===this.a&&C.b===this.b&&C.c===this.c&&C.d===this.d&&C.tx===this.tx&&C.ty===this.ty}toString(){return`[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`}static get IDENTITY(){return identityMatrix.identity()}static get shared(){return tempMatrix$3.identity()}}const tempMatrix$3=new Matrix,identityMatrix=new Matrix,ux=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],uy=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],vx=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],vy=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],rotationCayley=[],rotationMatrices=[],signum=Math.sign;function init(){for(let O=0;O<16;O++){const C=[];rotationCayley.push(C);for(let A=0;A<16;A++){const z=signum(ux[O]*ux[A]+vx[O]*uy[A]),I=signum(uy[O]*ux[A]+vy[O]*uy[A]),L=signum(ux[O]*vx[A]+vx[O]*vy[A]),K=signum(uy[O]*vx[A]+vy[O]*vy[A]);for(let te=0;te<16;te++)if(ux[te]===z&&uy[te]===I&&vx[te]===L&&vy[te]===K){C.push(te);break}}}for(let O=0;O<16;O++){const C=new Matrix;C.set(ux[O],uy[O],vx[O],vy[O],0,0),rotationMatrices.push(C)}}init();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:O=>ux[O],uY:O=>uy[O],vX:O=>vx[O],vY:O=>vy[O],inv:O=>O&8?O&15:-O&7,add:(O,C)=>rotationCayley[O][C],sub:(O,C)=>rotationCayley[O][groupD8.inv(C)],rotate180:O=>O^4,isVertical:O=>(O&3)===2,byDirection:(O,C)=>Math.abs(O)*2<=Math.abs(C)?C>=0?groupD8.S:groupD8.N:Math.abs(C)*2<=Math.abs(O)?O>0?groupD8.E:groupD8.W:C>0?O>0?groupD8.SE:groupD8.SW:O>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(O,C,A=0,z=0)=>{const I=rotationMatrices[groupD8.inv(C)];I.tx=A,I.ty=z,O.append(I)}},tempPoints=[new Point,new Point,new Point,new Point];class Rectangle{constructor(C=0,A=0,z=0,I=0){this.type="rectangle",this.x=Number(C),this.y=Number(A),this.width=Number(z),this.height=Number(I)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}isEmpty(){return this.left===this.right||this.top===this.bottom}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFromBounds(C){return this.x=C.minX,this.y=C.minY,this.width=C.maxX-C.minX,this.height=C.maxY-C.minY,this}copyFrom(C){return this.x=C.x,this.y=C.y,this.width=C.width,this.height=C.height,this}copyTo(C){return C.copyFrom(this),C}contains(C,A){return this.width<=0||this.height<=0?!1:C>=this.x&&C<this.x+this.width&&A>=this.y&&A<this.y+this.height}strokeContains(C,A,z){const{width:I,height:L}=this;if(I<=0||L<=0)return!1;const K=this.x,te=this.y,ne=K-z/2,ie=K+I+z/2,oe=te-z/2,ue=te+L+z/2,de=K+z/2,he=K+I-z/2,fe=te+z/2,be=te+L-z/2;return C>=ne&&C<=ie&&A>=oe&&A<=ue&&!(C>de&&C<he&&A>fe&&A<be)}intersects(C,A){if(!A){const ct=this.x<C.x?C.x:this.x;if((this.right>C.right?C.right:this.right)<=ct)return!1;const We=this.y<C.y?C.y:this.y;return(this.bottom>C.bottom?C.bottom:this.bottom)>We}const z=this.left,I=this.right,L=this.top,K=this.bottom;if(I<=z||K<=L)return!1;const te=tempPoints[0].set(C.left,C.top),ne=tempPoints[1].set(C.left,C.bottom),ie=tempPoints[2].set(C.right,C.top),oe=tempPoints[3].set(C.right,C.bottom);if(ie.x<=te.x||ne.y<=te.y)return!1;const ue=Math.sign(A.a*A.d-A.b*A.c);if(ue===0||(A.apply(te,te),A.apply(ne,ne),A.apply(ie,ie),A.apply(oe,oe),Math.max(te.x,ne.x,ie.x,oe.x)<=z||Math.min(te.x,ne.x,ie.x,oe.x)>=I||Math.max(te.y,ne.y,ie.y,oe.y)<=L||Math.min(te.y,ne.y,ie.y,oe.y)>=K))return!1;const de=ue*(ne.y-te.y),he=ue*(te.x-ne.x),fe=de*z+he*L,be=de*I+he*L,xe=de*z+he*K,Se=de*I+he*K;if(Math.max(fe,be,xe,Se)<=de*te.x+he*te.y||Math.min(fe,be,xe,Se)>=de*oe.x+he*oe.y)return!1;const Fe=ue*(te.y-ie.y),Ce=ue*(ie.x-te.x),Ge=Fe*z+Ce*L,Ve=Fe*I+Ce*L,pt=Fe*z+Ce*K,Ze=Fe*I+Ce*K;return!(Math.max(Ge,Ve,pt,Ze)<=Fe*te.x+Ce*te.y||Math.min(Ge,Ve,pt,Ze)>=Fe*oe.x+Ce*oe.y)}pad(C=0,A=C){return this.x-=C,this.y-=A,this.width+=C*2,this.height+=A*2,this}fit(C){const A=Math.max(this.x,C.x),z=Math.min(this.x+this.width,C.x+C.width),I=Math.max(this.y,C.y),L=Math.min(this.y+this.height,C.y+C.height);return this.x=A,this.width=Math.max(z-A,0),this.y=I,this.height=Math.max(L-I,0),this}ceil(C=1,A=.001){const z=Math.ceil((this.x+this.width-A)*C)/C,I=Math.ceil((this.y+this.height-A)*C)/C;return this.x=Math.floor((this.x+A)*C)/C,this.y=Math.floor((this.y+A)*C)/C,this.width=z-this.x,this.height=I-this.y,this}enlarge(C){const A=Math.min(this.x,C.x),z=Math.max(this.x+this.width,C.x+C.width),I=Math.min(this.y,C.y),L=Math.max(this.y+this.height,C.y+C.height);return this.x=A,this.width=z-A,this.y=I,this.height=L-I,this}getBounds(C){return C=C||new Rectangle,C.copyFrom(this),C}toString(){return`[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`}}const uidCache={default:-1};function uid(O="default"){return uidCache[O]===void 0&&(uidCache[O]=-1),++uidCache[O]}const warnings={},v8_0_0="8.0.0";function deprecation(O,C,A=3){if(warnings[C])return;let z=new Error().stack;typeof z=="undefined"?console.warn("PixiJS Deprecation Warning: ",`${C}
Deprecated since v${O}`):(z=z.split(`
`).splice(A).join(`
`),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${C}
Deprecated since v${O}`),console.warn(z),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${C}
Deprecated since v${O}`),console.warn(z))),warnings[C]=!0}const NOOP=()=>{};function nextPow2(O){return O+=O===0?1:0,--O,O|=O>>>1,O|=O>>>2,O|=O>>>4,O|=O>>>8,O|=O>>>16,O+1}function isPow2(O){return!(O&O-1)&&!!O}function definedProps(O){const C={};for(const A in O)O[A]!==void 0&&(C[A]=O[A]);return C}const idHash$1=Object.create(null);function createResourceIdFromString(O){const C=idHash$1[O];return C===void 0&&(idHash$1[O]=uid("resource")),C}const _TextureStyle=class Hr extends EventEmitter{constructor(C={}){var A,z,I,L,K,te,ne;super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,this.destroyed=!1,C={...Hr.defaultOptions,...C},this.addressMode=C.addressMode,this.addressModeU=(A=C.addressModeU)!=null?A:this.addressModeU,this.addressModeV=(z=C.addressModeV)!=null?z:this.addressModeV,this.addressModeW=(I=C.addressModeW)!=null?I:this.addressModeW,this.scaleMode=C.scaleMode,this.magFilter=(L=C.magFilter)!=null?L:this.magFilter,this.minFilter=(K=C.minFilter)!=null?K:this.minFilter,this.mipmapFilter=(te=C.mipmapFilter)!=null?te:this.mipmapFilter,this.lodMinClamp=C.lodMinClamp,this.lodMaxClamp=C.lodMaxClamp,this.compare=C.compare,this.maxAnisotropy=(ne=C.maxAnisotropy)!=null?ne:1}set addressMode(C){this.addressModeU=C,this.addressModeV=C,this.addressModeW=C}get addressMode(){return this.addressModeU}set wrapMode(C){deprecation(v8_0_0,"TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=C}get wrapMode(){return this.addressMode}set scaleMode(C){this.magFilter=C,this.minFilter=C,this.mipmapFilter=C}get scaleMode(){return this.magFilter}set maxAnisotropy(C){this._maxAnisotropy=Math.min(C,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this.emit("change",this),this._sharedResourceId=null}_generateResourceId(){const C=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=createResourceIdFromString(C),this._resourceId}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this.removeAllListeners()}};_TextureStyle.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};let TextureStyle=_TextureStyle;const _TextureSource=class Xr extends EventEmitter{constructor(C={}){var A,z,I;super(),this.options=C,this.uid=uid("textureSource"),this._resourceType="textureSource",this._resourceId=uid("resource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,C={...Xr.defaultOptions,...C},this.label=(A=C.label)!=null?A:"",this.resource=C.resource,this.autoGarbageCollect=C.autoGarbageCollect,this._resolution=C.resolution,C.width?this.pixelWidth=C.width*this._resolution:this.pixelWidth=this.resource&&(z=this.resourceWidth)!=null?z:1,C.height?this.pixelHeight=C.height*this._resolution:this.pixelHeight=this.resource&&(I=this.resourceHeight)!=null?I:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=C.format,this.dimension=C.dimensions,this.mipLevelCount=C.mipLevelCount,this.autoGenerateMipmaps=C.autoGenerateMipmaps,this.sampleCount=C.sampleCount,this.antialias=C.antialias,this.alphaMode=C.alphaMode,this.style=new TextureStyle(definedProps(C)),this.destroyed=!1,this._refreshPOT()}get source(){return this}get style(){return this._style}set style(C){var A,z;this.style!==C&&((A=this._style)==null||A.off("change",this._onStyleChange,this),this._style=C,(z=this._style)==null||z.on("change",this._onStyleChange,this),this._onStyleChange())}get addressMode(){return this._style.addressMode}set addressMode(C){this._style.addressMode=C}get repeatMode(){return this._style.addressMode}set repeatMode(C){this._style.addressMode=C}get magFilter(){return this._style.magFilter}set magFilter(C){this._style.magFilter=C}get minFilter(){return this._style.minFilter}set minFilter(C){this._style.minFilter=C}get mipmapFilter(){return this._style.mipmapFilter}set mipmapFilter(C){this._style.mipmapFilter=C}get lodMinClamp(){return this._style.lodMinClamp}set lodMinClamp(C){this._style.lodMinClamp=C}get lodMaxClamp(){return this._style.lodMaxClamp}set lodMaxClamp(C){this._style.lodMaxClamp=C}_onStyleChange(){this.emit("styleChange",this)}update(){if(this.resource){const C=this._resolution;if(this.resize(this.resourceWidth/C,this.resourceHeight/C))return}this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId=uid("resource"),this.emit("change",this),this.emit("unload",this)}get resourceWidth(){const{resource:C}=this;return C.naturalWidth||C.videoWidth||C.displayWidth||C.width}get resourceHeight(){const{resource:C}=this;return C.naturalHeight||C.videoHeight||C.displayHeight||C.height}get resolution(){return this._resolution}set resolution(C){this._resolution!==C&&(this._resolution=C,this.width=this.pixelWidth/C,this.height=this.pixelHeight/C)}resize(C,A,z){z=z||this._resolution,C=C||this.width,A=A||this.height;const I=Math.round(C*z),L=Math.round(A*z);return this.width=I/z,this.height=L/z,this._resolution=z,this.pixelWidth===I&&this.pixelHeight===L?!1:(this._refreshPOT(),this.pixelWidth=I,this.pixelHeight=L,this.emit("resize",this),this._resourceId=uid("resource"),this.emit("change",this),!0)}updateMipmaps(){this.autoGenerateMipmaps&&this.mipLevelCount>1&&this.emit("updateMipmaps",this)}set wrapMode(C){this._style.wrapMode=C}get wrapMode(){return this._style.wrapMode}set scaleMode(C){this._style.scaleMode=C}get scaleMode(){return this._style.scaleMode}_refreshPOT(){this.isPowerOfTwo=isPow2(this.pixelWidth)&&isPow2(this.pixelHeight)}static test(C){throw new Error("Unimplemented")}};_TextureSource.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,autoGarbageCollect:!1};let TextureSource=_TextureSource;class BufferImageSource extends TextureSource{constructor(C){const A=C.resource||new Float32Array(C.width*C.height*4);let z=C.format;z||(A instanceof Float32Array?z="rgba32float":A instanceof Int32Array||A instanceof Uint32Array?z="rgba32uint":A instanceof Int16Array||A instanceof Uint16Array?z="rgba16uint":(A instanceof Int8Array,z="bgra8unorm")),super({...C,resource:A,format:z}),this.uploadMethodId="buffer"}static test(C){return C instanceof Int8Array||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Int16Array||C instanceof Uint16Array||C instanceof Int32Array||C instanceof Uint32Array||C instanceof Float32Array}}BufferImageSource.extension=ExtensionType.TextureSource;const tempMat=new Matrix;class TextureMatrix{constructor(C,A){this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof A=="undefined"?this.clampMargin=C.width<10?0:.5:this.clampMargin=A,this.isSimple=!1,this.texture=C}get texture(){return this._texture}set texture(C){var A;this.texture!==C&&((A=this._texture)==null||A.removeListener("update",this.update,this),this._texture=C,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(C,A){A===void 0&&(A=C);const z=this.mapCoord;for(let I=0;I<C.length;I+=2){const L=C[I],K=C[I+1];A[I]=L*z.a+K*z.c+z.tx,A[I+1]=L*z.b+K*z.d+z.ty}return A}update(){const C=this._texture;this._updateID++;const A=C.uvs;this.mapCoord.set(A.x1-A.x0,A.y1-A.y0,A.x3-A.x0,A.y3-A.y0,A.x0,A.y0);const z=C.orig,I=C.trim;I&&(tempMat.set(z.width/I.width,0,0,z.height/I.height,-I.x/I.width,-I.y/I.height),this.mapCoord.append(tempMat));const L=C.source,K=this.uClampFrame,te=this.clampMargin/L._resolution,ne=this.clampOffset/L._resolution;return K[0]=(C.frame.x+te+ne)/L.width,K[1]=(C.frame.y+te+ne)/L.height,K[2]=(C.frame.x+C.frame.width-te+ne)/L.width,K[3]=(C.frame.y+C.frame.height-te+ne)/L.height,this.uClampOffset[0]=this.clampOffset/L.pixelWidth,this.uClampOffset[1]=this.clampOffset/L.pixelHeight,this.isSimple=C.frame.width===L.width&&C.frame.height===L.height&&C.rotate===0,!0}}class Texture extends EventEmitter{constructor({source:C,label:A,frame:z,orig:I,trim:L,defaultAnchor:K,defaultBorders:te,rotate:ne,dynamic:ie}={}){var oe;if(super(),this.uid=uid("texture"),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=new Rectangle,this.noFrame=!1,this.dynamic=!1,this.isTexture=!0,this.label=A,this.source=(oe=C==null?void 0:C.source)!=null?oe:new TextureSource,this.noFrame=!z,z)this.frame.copyFrom(z);else{const{width:ue,height:de}=this._source;this.frame.width=ue,this.frame.height=de}this.orig=I||this.frame,this.trim=L,this.rotate=ne!=null?ne:0,this.defaultAnchor=K,this.defaultBorders=te,this.destroyed=!1,this.dynamic=ie||!1,this.updateUvs()}set source(C){this._source&&this._source.off("resize",this.update,this),this._source=C,C.on("resize",this.update,this),this.emit("update",this)}get source(){return this._source}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new TextureMatrix(this)),this._textureMatrix}get width(){return this.orig.width}get height(){return this.orig.height}updateUvs(){const{uvs:C,frame:A}=this,{width:z,height:I}=this._source,L=A.x/z,K=A.y/I,te=A.width/z,ne=A.height/I;let ie=this.rotate;if(ie){const oe=te/2,ue=ne/2,de=L+oe,he=K+ue;ie=groupD8.add(ie,groupD8.NW),C.x0=de+oe*groupD8.uX(ie),C.y0=he+ue*groupD8.uY(ie),ie=groupD8.add(ie,2),C.x1=de+oe*groupD8.uX(ie),C.y1=he+ue*groupD8.uY(ie),ie=groupD8.add(ie,2),C.x2=de+oe*groupD8.uX(ie),C.y2=he+ue*groupD8.uY(ie),ie=groupD8.add(ie,2),C.x3=de+oe*groupD8.uX(ie),C.y3=he+ue*groupD8.uY(ie)}else C.x0=L,C.y0=K,C.x1=L+te,C.y1=K,C.x2=L+te,C.y2=K+ne,C.x3=L,C.y3=K+ne}destroy(C=!1){this._source&&C&&(this._source.destroy(),this._source=null),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}update(){this.noFrame&&(this.frame.width=this._source.width,this.frame.height=this._source.height),this.updateUvs(),this.emit("update",this)}get baseTexture(){return deprecation(v8_0_0,"Texture.baseTexture is now Texture.source"),this._source}}Texture.EMPTY=new Texture({label:"EMPTY",source:new TextureSource({label:"EMPTY"})}),Texture.EMPTY.destroy=NOOP,Texture.WHITE=new Texture({source:new BufferImageSource({resource:new Uint8Array([255,255,255,255]),width:1,height:1,alphaMode:"premultiply-alpha-on-upload",label:"WHITE"}),label:"WHITE"}),Texture.WHITE.destroy=NOOP;function updateQuadBounds(O,C,A,z){const{width:I,height:L}=A.orig,K=A.trim;if(K){const te=K.width,ne=K.height;O.minX=K.x-C._x*I-z,O.maxX=O.minX+te,O.minY=K.y-C._y*L-z,O.maxY=O.minY+ne}else O.minX=-C._x*I-z,O.maxX=O.minX+I,O.minY=-C._y*L-z,O.maxY=O.minY+L}const defaultMatrix=new Matrix;class Bounds{constructor(C=1/0,A=1/0,z=-1/0,I=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this.minX=C,this.minY=A,this.maxX=z,this.maxY=I}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}get rectangle(){this._rectangle||(this._rectangle=new Rectangle);const C=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(C.x=0,C.y=0,C.width=0,C.height=0):C.copyFromBounds(this),C}clear(){return this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this}set(C,A,z,I){this.minX=C,this.minY=A,this.maxX=z,this.maxY=I}addFrame(C,A,z,I,L){L||(L=this.matrix);const K=L.a,te=L.b,ne=L.c,ie=L.d,oe=L.tx,ue=L.ty;let de=this.minX,he=this.minY,fe=this.maxX,be=this.maxY,xe=K*C+ne*A+oe,Se=te*C+ie*A+ue;xe<de&&(de=xe),Se<he&&(he=Se),xe>fe&&(fe=xe),Se>be&&(be=Se),xe=K*z+ne*A+oe,Se=te*z+ie*A+ue,xe<de&&(de=xe),Se<he&&(he=Se),xe>fe&&(fe=xe),Se>be&&(be=Se),xe=K*C+ne*I+oe,Se=te*C+ie*I+ue,xe<de&&(de=xe),Se<he&&(he=Se),xe>fe&&(fe=xe),Se>be&&(be=Se),xe=K*z+ne*I+oe,Se=te*z+ie*I+ue,xe<de&&(de=xe),Se<he&&(he=Se),xe>fe&&(fe=xe),Se>be&&(be=Se),this.minX=de,this.minY=he,this.maxX=fe,this.maxY=be}addRect(C,A){this.addFrame(C.x,C.y,C.x+C.width,C.y+C.height,A)}addBounds(C,A){this.addFrame(C.minX,C.minY,C.maxX,C.maxY,A)}addBoundsMask(C){this.minX=this.minX>C.minX?this.minX:C.minX,this.minY=this.minY>C.minY?this.minY:C.minY,this.maxX=this.maxX<C.maxX?this.maxX:C.maxX,this.maxY=this.maxY<C.maxY?this.maxY:C.maxY}applyMatrix(C){const A=this.minX,z=this.minY,I=this.maxX,L=this.maxY,{a:K,b:te,c:ne,d:ie,tx:oe,ty:ue}=C;let de=K*A+ne*z+oe,he=te*A+ie*z+ue;this.minX=de,this.minY=he,this.maxX=de,this.maxY=he,de=K*I+ne*z+oe,he=te*I+ie*z+ue,this.minX=de<this.minX?de:this.minX,this.minY=he<this.minY?he:this.minY,this.maxX=de>this.maxX?de:this.maxX,this.maxY=he>this.maxY?he:this.maxY,de=K*A+ne*L+oe,he=te*A+ie*L+ue,this.minX=de<this.minX?de:this.minX,this.minY=he<this.minY?he:this.minY,this.maxX=de>this.maxX?de:this.maxX,this.maxY=he>this.maxY?he:this.maxY,de=K*I+ne*L+oe,he=te*I+ie*L+ue,this.minX=de<this.minX?de:this.minX,this.minY=he<this.minY?he:this.minY,this.maxX=de>this.maxX?de:this.maxX,this.maxY=he>this.maxY?he:this.maxY}fit(C){return this.minX<C.left&&(this.minX=C.left),this.maxX>C.right&&(this.maxX=C.right),this.minY<C.top&&(this.minY=C.top),this.maxY>C.bottom&&(this.maxY=C.bottom),this}fitBounds(C,A,z,I){return this.minX<C&&(this.minX=C),this.maxX>A&&(this.maxX=A),this.minY<z&&(this.minY=z),this.maxY>I&&(this.maxY=I),this}pad(C,A=C){return this.minX-=C,this.maxX+=C,this.minY-=A,this.maxY+=A,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new Bounds(this.minX,this.minY,this.maxX,this.maxY)}scale(C,A=C){return this.minX*=C,this.minY*=A,this.maxX*=C,this.maxY*=A,this}get x(){return this.minX}set x(C){const A=this.maxX-this.minX;this.minX=C,this.maxX=C+A}get y(){return this.minY}set y(C){const A=this.maxY-this.minY;this.minY=C,this.maxY=C+A}get width(){return this.maxX-this.minX}set width(C){this.maxX=this.minX+C}get height(){return this.maxY-this.minY}set height(C){this.maxY=this.minY+C}get left(){return this.minX}get right(){return this.maxX}get top(){return this.minY}get bottom(){return this.maxY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(C,A,z,I){let L=this.minX,K=this.minY,te=this.maxX,ne=this.maxY;I||(I=this.matrix);const ie=I.a,oe=I.b,ue=I.c,de=I.d,he=I.tx,fe=I.ty;for(let be=A;be<z;be+=2){const xe=C[be],Se=C[be+1],Fe=ie*xe+ue*Se+he,Ce=oe*xe+de*Se+fe;L=Fe<L?Fe:L,K=Ce<K?Ce:K,te=Fe>te?Fe:te,ne=Ce>ne?Ce:ne}this.minX=L,this.minY=K,this.maxX=te,this.maxY=ne}containsPoint(C,A){return this.minX<=C&&this.minY<=A&&this.maxX>=C&&this.maxY>=A}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}}var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(O){return typeof O=="string"?O.length>0:typeof O=="number"},n=function(O,C,A){return C===void 0&&(C=0),A===void 0&&(A=Math.pow(10,C)),Math.round(A*O)/A+0},e=function(O,C,A){return C===void 0&&(C=0),A===void 0&&(A=1),O>A?A:O>C?O:C},u=function(O){return(O=isFinite(O)?O%360:0)>0?O:O+360},a=function(O){return{r:e(O.r,0,255),g:e(O.g,0,255),b:e(O.b,0,255),a:e(O.a)}},o=function(O){return{r:n(O.r),g:n(O.g),b:n(O.b),a:n(O.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(O){var C=O.toString(16);return C.length<2?"0"+C:C},h$1=function(O){var C=O.r,A=O.g,z=O.b,I=O.a,L=Math.max(C,A,z),K=L-Math.min(C,A,z),te=K?L===C?(A-z)/K:L===A?2+(z-C)/K:4+(C-A)/K:0;return{h:60*(te<0?te+6:te),s:L?K/L*100:0,v:L/255*100,a:I}},b$1=function(O){var C=O.h,A=O.s,z=O.v,I=O.a;C=C/360*6,A/=100,z/=100;var L=Math.floor(C),K=z*(1-A),te=z*(1-(C-L)*A),ne=z*(1-(1-C+L)*A),ie=L%6;return{r:255*[z,te,K,K,ne,z][ie],g:255*[ne,z,z,te,K,K][ie],b:255*[K,K,ne,z,z,te][ie],a:I}},g$1=function(O){return{h:u(O.h),s:e(O.s,0,100),l:e(O.l,0,100),a:e(O.a)}},d=function(O){return{h:n(O.h),s:n(O.s),l:n(O.l),a:n(O.a,3)}},f=function(O){return b$1((A=(C=O).s,{h:C.h,s:(A*=((z=C.l)<50?z:100-z)/100)>0?2*A/(z+A)*100:0,v:z+A,a:C.a}));var C,A,z},c=function(O){return{h:(C=h$1(O)).h,s:(I=(200-(A=C.s))*(z=C.v)/100)>0&&I<200?A*z/100/(I<=100?I:200-I)*100:0,l:I/2,a:C.a};var C,A,z,I},l$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y$1={string:[[function(O){var C=i.exec(O);return C?(O=C[1]).length<=4?{r:parseInt(O[0]+O[0],16),g:parseInt(O[1]+O[1],16),b:parseInt(O[2]+O[2],16),a:O.length===4?n(parseInt(O[3]+O[3],16)/255,2):1}:O.length===6||O.length===8?{r:parseInt(O.substr(0,2),16),g:parseInt(O.substr(2,2),16),b:parseInt(O.substr(4,2),16),a:O.length===8?n(parseInt(O.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(O){var C=v$1.exec(O)||m.exec(O);return C?C[2]!==C[4]||C[4]!==C[6]?null:a({r:Number(C[1])/(C[2]?100/255:1),g:Number(C[3])/(C[4]?100/255:1),b:Number(C[5])/(C[6]?100/255:1),a:C[7]===void 0?1:Number(C[7])/(C[8]?100:1)}):null},"rgb"],[function(O){var C=l$1.exec(O)||p.exec(O);if(!C)return null;var A,z,I=g$1({h:(A=C[1],z=C[2],z===void 0&&(z="deg"),Number(A)*(r[z]||1)),s:Number(C[3]),l:Number(C[4]),a:C[5]===void 0?1:Number(C[5])/(C[6]?100:1)});return f(I)},"hsl"]],object:[[function(O){var C=O.r,A=O.g,z=O.b,I=O.a,L=I===void 0?1:I;return t(C)&&t(A)&&t(z)?a({r:Number(C),g:Number(A),b:Number(z),a:Number(L)}):null},"rgb"],[function(O){var C=O.h,A=O.s,z=O.l,I=O.a,L=I===void 0?1:I;if(!t(C)||!t(A)||!t(z))return null;var K=g$1({h:Number(C),s:Number(A),l:Number(z),a:Number(L)});return f(K)},"hsl"],[function(O){var C=O.h,A=O.s,z=O.v,I=O.a,L=I===void 0?1:I;if(!t(C)||!t(A)||!t(z))return null;var K=function(te){return{h:u(te.h),s:e(te.s,0,100),v:e(te.v,0,100),a:e(te.a)}}({h:Number(C),s:Number(A),v:Number(z),a:Number(L)});return b$1(K)},"hsv"]]},N$1=function(O,C){for(var A=0;A<C.length;A++){var z=C[A][0](O);if(z)return[z,C[A][1]]}return[null,void 0]},x=function(O){return typeof O=="string"?N$1(O.trim(),y$1.string):typeof O=="object"&&O!==null?N$1(O,y$1.object):[null,void 0]},M$1=function(O,C){var A=c(O);return{h:A.h,s:e(A.s+100*C,0,100),l:A.l,a:A.a}},H$1=function(O){return(299*O.r+587*O.g+114*O.b)/1e3/255},$=function(O,C){var A=c(O);return{h:A.h,s:A.s,l:e(A.l+100*C,0,100),a:A.a}},j$1=function(){function O(C){this.parsed=x(C)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return O.prototype.isValid=function(){return this.parsed!==null},O.prototype.brightness=function(){return n(H$1(this.rgba),2)},O.prototype.isDark=function(){return H$1(this.rgba)<.5},O.prototype.isLight=function(){return H$1(this.rgba)>=.5},O.prototype.toHex=function(){return C=o(this.rgba),A=C.r,z=C.g,I=C.b,K=(L=C.a)<1?s(n(255*L)):"","#"+s(A)+s(z)+s(I)+K;var C,A,z,I,L,K},O.prototype.toRgb=function(){return o(this.rgba)},O.prototype.toRgbString=function(){return C=o(this.rgba),A=C.r,z=C.g,I=C.b,(L=C.a)<1?"rgba("+A+", "+z+", "+I+", "+L+")":"rgb("+A+", "+z+", "+I+")";var C,A,z,I,L},O.prototype.toHsl=function(){return d(c(this.rgba))},O.prototype.toHslString=function(){return C=d(c(this.rgba)),A=C.h,z=C.s,I=C.l,(L=C.a)<1?"hsla("+A+", "+z+"%, "+I+"%, "+L+")":"hsl("+A+", "+z+"%, "+I+"%)";var C,A,z,I,L},O.prototype.toHsv=function(){return C=h$1(this.rgba),{h:n(C.h),s:n(C.s),v:n(C.v),a:n(C.a,3)};var C},O.prototype.invert=function(){return w$1({r:255-(C=this.rgba).r,g:255-C.g,b:255-C.b,a:C.a});var C},O.prototype.saturate=function(C){return C===void 0&&(C=.1),w$1(M$1(this.rgba,C))},O.prototype.desaturate=function(C){return C===void 0&&(C=.1),w$1(M$1(this.rgba,-C))},O.prototype.grayscale=function(){return w$1(M$1(this.rgba,-1))},O.prototype.lighten=function(C){return C===void 0&&(C=.1),w$1($(this.rgba,C))},O.prototype.darken=function(C){return C===void 0&&(C=.1),w$1($(this.rgba,-C))},O.prototype.rotate=function(C){return C===void 0&&(C=15),this.hue(this.hue()+C)},O.prototype.alpha=function(C){return typeof C=="number"?w$1({r:(A=this.rgba).r,g:A.g,b:A.b,a:C}):n(this.rgba.a,3);var A},O.prototype.hue=function(C){var A=c(this.rgba);return typeof C=="number"?w$1({h:C,s:A.s,l:A.l,a:A.a}):n(A.h)},O.prototype.isEqual=function(C){return this.toHex()===w$1(C).toHex()},O}(),w$1=function(O){return O instanceof j$1?O:new j$1(O)},S$1=[],k$1=function(O){O.forEach(function(C){S$1.indexOf(C)<0&&(C(j$1,y$1),S$1.push(C))})};function namesPlugin(O,C){var A={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},z={};for(var I in A)z[A[I]]=I;var L={};O.prototype.toName=function(K){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var te,ne,ie=z[this.toHex()];if(ie)return ie;if(K!=null&&K.closest){var oe=this.toRgb(),ue=1/0,de="black";if(!L.length)for(var he in A)L[he]=new O(A[he]).toRgb();for(var fe in A){var be=(te=oe,ne=L[fe],Math.pow(te.r-ne.r,2)+Math.pow(te.g-ne.g,2)+Math.pow(te.b-ne.b,2));be<ue&&(ue=be,de=fe)}return de}},C.string.push([function(K){var te=K.toLowerCase(),ne=te==="transparent"?"#0000":A[te];return ne?new O(ne).toRgb():null},"name"])}k$1([namesPlugin]);const _Color=class Pr{constructor(C=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=C}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(C){return this.value=C,this}set value(C){if(C instanceof Pr)this._value=this._cloneSource(C._value),this._int=C._int,this._components.set(C._components);else{if(C===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,C))&&(this._normalize(C),this._value=this._cloneSource(C))}}get value(){return this._value}_cloneSource(C){return typeof C=="string"||typeof C=="number"||C instanceof Number||C===null?C:Array.isArray(C)||ArrayBuffer.isView(C)?C.slice(0):typeof C=="object"&&C!==null?{...C}:C}_isSourceEqual(C,A){const z=typeof C;if(z!==typeof A)return!1;if(z==="number"||z==="string"||C instanceof Number)return C===A;if(Array.isArray(C)&&Array.isArray(A)||ArrayBuffer.isView(C)&&ArrayBuffer.isView(A))return C.length!==A.length?!1:C.every((L,K)=>L===A[K]);if(C!==null&&A!==null){const L=Object.keys(C),K=Object.keys(A);return L.length!==K.length?!1:L.every(te=>C[te]===A[te])}return C===A}toRgba(){const[C,A,z,I]=this._components;return{r:C,g:A,b:z,a:I}}toRgb(){const[C,A,z]=this._components;return{r:C,g:A,b:z}}toRgbaString(){const[C,A,z]=this.toUint8RgbArray();return`rgba(${C},${A},${z},${this.alpha})`}toUint8RgbArray(C){const[A,z,I]=this._components;return this._arrayRgb||(this._arrayRgb=[]),C=C||this._arrayRgb,C[0]=Math.round(A*255),C[1]=Math.round(z*255),C[2]=Math.round(I*255),C}toArray(C){this._arrayRgba||(this._arrayRgba=[]),C=C||this._arrayRgba;const[A,z,I,L]=this._components;return C[0]=A,C[1]=z,C[2]=I,C[3]=L,C}toRgbArray(C){this._arrayRgb||(this._arrayRgb=[]),C=C||this._arrayRgb;const[A,z,I]=this._components;return C[0]=A,C[1]=z,C[2]=I,C}toNumber(){return this._int}toBgrNumber(){const[C,A,z]=this.toUint8RgbArray();return(z<<16)+(A<<8)+C}toLittleEndianNumber(){const C=this._int;return(C>>16)+(C&65280)+((C&255)<<16)}multiply(C){const[A,z,I,L]=Pr._temp.setValue(C)._components;return this._components[0]*=A,this._components[1]*=z,this._components[2]*=I,this._components[3]*=L,this._refreshInt(),this._value=null,this}premultiply(C,A=!0){return A&&(this._components[0]*=C,this._components[1]*=C,this._components[2]*=C),this._components[3]=C,this._refreshInt(),this._value=null,this}toPremultiplied(C,A=!0){if(C===1)return(255<<24)+this._int;if(C===0)return A?0:this._int;let z=this._int>>16&255,I=this._int>>8&255,L=this._int&255;return A&&(z=z*C+.5|0,I=I*C+.5|0,L=L*C+.5|0),(C*255<<24)+(z<<16)+(I<<8)+L}toHex(){const C=this._int.toString(16);return`#${"000000".substring(0,6-C.length)+C}`}toHexa(){const A=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-A.length)+A}setAlpha(C){return this._components[3]=this._clamp(C),this}_normalize(C){let A,z,I,L;if((typeof C=="number"||C instanceof Number)&&C>=0&&C<=16777215){const K=C;A=(K>>16&255)/255,z=(K>>8&255)/255,I=(K&255)/255,L=1}else if((Array.isArray(C)||C instanceof Float32Array)&&C.length>=3&&C.length<=4)C=this._clamp(C),[A,z,I,L=1]=C;else if((C instanceof Uint8Array||C instanceof Uint8ClampedArray)&&C.length>=3&&C.length<=4)C=this._clamp(C,0,255),[A,z,I,L=255]=C,A/=255,z/=255,I/=255,L/=255;else if(typeof C=="string"||typeof C=="object"){if(typeof C=="string"){const te=Pr.HEX_PATTERN.exec(C);te&&(C=`#${te[2]}`)}const K=w$1(C);K.isValid()&&({r:A,g:z,b:I,a:L}=K.rgba,A/=255,z/=255,I/=255)}if(A!==void 0)this._components[0]=A,this._components[1]=z,this._components[2]=I,this._components[3]=L,this._refreshInt();else throw new Error(`Unable to convert color ${C}`)}_refreshInt(){this._clamp(this._components);const[C,A,z]=this._components;this._int=(C*255<<16)+(A*255<<8)+(z*255|0)}_clamp(C,A=0,z=1){return typeof C=="number"?Math.min(Math.max(C,A),z):(C.forEach((I,L)=>{C[L]=Math.min(Math.max(I,A),z)}),C)}static isColorLike(C){return typeof C=="number"||typeof C=="string"||C instanceof Number||C instanceof Pr||Array.isArray(C)||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Float32Array||C.r!==void 0&&C.g!==void 0&&C.b!==void 0||C.r!==void 0&&C.g!==void 0&&C.b!==void 0&&C.a!==void 0||C.h!==void 0&&C.s!==void 0&&C.l!==void 0||C.h!==void 0&&C.s!==void 0&&C.l!==void 0&&C.a!==void 0||C.h!==void 0&&C.s!==void 0&&C.v!==void 0||C.h!==void 0&&C.s!==void 0&&C.v!==void 0&&C.a!==void 0}};_Color.shared=new _Color,_Color._temp=new _Color,_Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;let Color=_Color;const cullingMixin={cullArea:null,cullable:!1,cullableChildren:!0};class Pool{constructor(C,A){this._pool=[],this._count=0,this._index=0,this._classType=C,A&&this.prepopulate(A)}prepopulate(C){for(let A=0;A<C;A++)this._pool[this._index++]=new this._classType;this._count+=C}get(C){var z;let A;return this._index>0?A=this._pool[--this._index]:A=new this._classType,(z=A.init)==null||z.call(A,C),A}return(C){var A;(A=C.reset)==null||A.call(C),this._pool[this._index++]=C}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}clear(){this._pool.length=0,this._index=0}}class PoolGroupClass{constructor(){this._poolsByClass=new Map}prepopulate(C,A){this.getPool(C).prepopulate(A)}get(C,A){return this.getPool(C).get(A)}return(C){this.getPool(C.constructor).return(C)}getPool(C){return this._poolsByClass.has(C)||this._poolsByClass.set(C,new Pool(C)),this._poolsByClass.get(C)}stats(){const C={};return this._poolsByClass.forEach(A=>{const z=C[A._classType.name]?A._classType.name+A._classType.ID:A._classType.name;C[z]={free:A.totalFree,used:A.totalUsed,size:A.totalSize}}),C}}const BigPool=new PoolGroupClass;function removeItems(O,C,A){const z=O.length;let I;if(C>=z||A===0)return;A=C+A>z?z-C:A;const L=z-A;for(I=C;I<L;++I)O[I]=O[I+A];O.length=L}const childrenHelperMixin={allowChildren:!0,removeChildren(O=0,C){const A=C!=null?C:this.children.length,z=A-O,I=[];if(z>0&&z<=A){for(let K=A-1;K>=O;K--){const te=this.children[K];!te||(I.push(te),te.parent=null)}removeItems(this.children,O,A);const L=this.renderGroup||this.parentRenderGroup;L&&L.removeChildren(I);for(let K=0;K<I.length;++K)this.emit("childRemoved",I[K],this,K),I[K].emit("removed",this);return I}else if(z===0&&this.children.length===0)return I;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(O){const C=this.getChildAt(O);return this.removeChild(C)},getChildAt(O){if(O<0||O>=this.children.length)throw new Error(`getChildAt: Index (${O}) does not exist.`);return this.children[O]},setChildIndex(O,C){if(C<0||C>=this.children.length)throw new Error(`The index ${C} supplied is out of bounds ${this.children.length}`);this.getChildIndex(O),this.addChildAt(O,C)},getChildIndex(O){const C=this.children.indexOf(O);if(C===-1)throw new Error("The supplied Container must be a child of the caller");return C},addChildAt(O,C){this.allowChildren||deprecation(v8_0_0,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:A}=this;if(C<0||C>A.length)throw new Error(`${O}addChildAt: The index ${C} supplied is out of bounds ${A.length}`);if(O.parent){const I=O.parent.children.indexOf(O);if(O.parent===this&&I===C)return O;I!==-1&&O.parent.children.splice(I,1)}C===A.length?A.push(O):A.splice(C,0,O),O.parent=this,O.didChange=!0,O.didViewUpdate=!1,O._updateFlags=15;const z=this.renderGroup||this.parentRenderGroup;return z&&z.addChild(O),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",O,this,C),O.emit("added",this),O},swapChildren(O,C){if(O===C)return;const A=this.getChildIndex(O),z=this.getChildIndex(C);this.children[A]=C,this.children[z]=O;const I=this.renderGroup||this.parentRenderGroup;I&&(I.structureDidChange=!0),this._didContainerChangeTick++},removeFromParent(){var O;(O=this.parent)==null||O.removeChild(this)},reparentChild(...O){return O.length===1?this.reparentChildAt(O[0],this.children.length):(O.forEach(C=>this.reparentChildAt(C,this.children.length)),O[0])},reparentChildAt(O,C){if(O.parent===this)return this.setChildIndex(O,C),O;const A=O.worldTransform.clone();O.removeFromParent(),this.addChildAt(O,C);const z=this.worldTransform.clone();return z.invert(),A.prepend(z),O.setFromMatrix(A),O}};class FilterEffect{constructor(){this.pipe="filter",this.priority=1}destroy(){for(let C=0;C<this.filters.length;C++)this.filters[C].destroy();this.filters=null,this.filterArea=null}}class MaskEffectManagerClass{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(C=>{this.add({test:C.test,maskClass:C})}))}add(C){this._tests.push(C)}getMaskEffect(C){this._initialized||this.init();for(let A=0;A<this._tests.length;A++){const z=this._tests[A];if(z.test(C))return BigPool.get(z.maskClass,C)}return C}returnMaskEffect(C){BigPool.return(C)}}const MaskEffectManager=new MaskEffectManagerClass;extensions.handleByList(ExtensionType.MaskEffect,MaskEffectManager._effectClasses);const effectsMixin={_maskEffect:null,_filterEffect:null,effects:[],addEffect(O){if(this.effects.indexOf(O)!==-1)return;this.effects.push(O),this.effects.sort((z,I)=>z.priority-I.priority);const A=this.renderGroup||this.parentRenderGroup;A&&(A.structureDidChange=!0),this._updateIsSimple()},removeEffect(O){const C=this.effects.indexOf(O);C!==-1&&(this.effects.splice(C,1),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateIsSimple())},set mask(O){const C=this._maskEffect;(C==null?void 0:C.mask)!==O&&(C&&(this.removeEffect(C),MaskEffectManager.returnMaskEffect(C),this._maskEffect=null),O!=null&&(this._maskEffect=MaskEffectManager.getMaskEffect(O),this.addEffect(this._maskEffect)))},get mask(){var O;return(O=this._maskEffect)==null?void 0:O.mask},set filters(O){var L;!Array.isArray(O)&&O&&(O=[O]);const C=this._filterEffect||(this._filterEffect=new FilterEffect);O=O;const A=(O==null?void 0:O.length)>0,z=((L=C.filters)==null?void 0:L.length)>0,I=A!==z;O=Array.isArray(O)?O.slice(0):O,C.filters=Object.freeze(O),I&&(A?this.addEffect(C):(this.removeEffect(C),C.filters=O!=null?O:null))},get filters(){var O;return(O=this._filterEffect)==null?void 0:O.filters},set filterArea(O){this._filterEffect||(this._filterEffect=new FilterEffect),this._filterEffect.filterArea=O},get filterArea(){var O;return(O=this._filterEffect)==null?void 0:O.filterArea}},findMixin={label:null,get name(){return deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label},set name(O){deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label=O},getChildByName(O,C=!1){return this.getChildByLabel(O,C)},getChildByLabel(O,C=!1){const A=this.children;for(let z=0;z<A.length;z++){const I=A[z];if(I.label===O||O instanceof RegExp&&O.test(I.label))return I}if(C)for(let z=0;z<A.length;z++){const L=A[z].getChildByLabel(O,!0);if(L)return L}return null},getChildrenByLabel(O,C=!1,A=[]){const z=this.children;for(let I=0;I<z.length;I++){const L=z[I];(L.label===O||O instanceof RegExp&&O.test(L.label))&&A.push(L)}if(C)for(let I=0;I<z.length;I++)z[I].getChildrenByLabel(O,!0,A);return A}},matrixPool=new Pool(Matrix),boundsPool=new Pool(Bounds);function getGlobalBounds(O,C,A){A.clear();let z,I;return O.parent?C?z=O.parent.worldTransform:(I=matrixPool.get().identity(),z=updateTransformBackwards(O,I)):z=Matrix.IDENTITY,_getGlobalBounds(O,A,z,C),I&&matrixPool.return(I),A.isValid||A.set(0,0,0,0),A}function _getGlobalBounds(O,C,A,z){var te,ne;if(!O.visible||!O.measurable)return;let I;z?I=O.worldTransform:(O.updateLocalTransform(),I=matrixPool.get(),I.appendFrom(O.localTransform,A));const L=C,K=!!O.effects.length;if(K&&(C=boundsPool.get().clear()),O.boundsArea)C.addRect(O.boundsArea,I);else{O.addBounds&&(C.matrix=I,O.addBounds(C));for(let ie=0;ie<O.children.length;ie++)_getGlobalBounds(O.children[ie],C,I,z)}if(K){for(let ie=0;ie<O.effects.length;ie++)(ne=(te=O.effects[ie]).addBounds)==null||ne.call(te,C);L.addBounds(C,Matrix.IDENTITY),boundsPool.return(C)}z||matrixPool.return(I)}function updateTransformBackwards(O,C){const A=O.parent;return A&&(updateTransformBackwards(A,C),A.updateLocalTransform(),C.append(A.localTransform)),C}let warnCount=0;const maxWarnings=500;function warn(...O){warnCount!==maxWarnings&&(warnCount++,warnCount===maxWarnings?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...O))}function getLocalBounds(O,C,A){return C.clear(),A||(A=Matrix.IDENTITY),_getLocalBounds(O,C,A,O,!0),C.isValid||C.set(0,0,0,0),C}function _getLocalBounds(O,C,A,z,I){var ne,ie;let L;if(I)L=matrixPool.get(),L=A.copyTo(L);else{if(!O.visible||!O.measurable)return;O.updateLocalTransform();const oe=O.localTransform;L=matrixPool.get(),L.appendFrom(oe,A)}const K=C,te=!!O.effects.length;if(te&&(C=boundsPool.get().clear()),O.boundsArea)C.addRect(O.boundsArea,L);else{O.renderPipeId&&(C.matrix=L,O.addBounds(C));const oe=O.children;for(let ue=0;ue<oe.length;ue++)_getLocalBounds(oe[ue],C,L,z,!1)}if(te){for(let oe=0;oe<O.effects.length;oe++)(ie=(ne=O.effects[oe]).addLocalBounds)==null||ie.call(ne,C,z);K.addBounds(C,Matrix.IDENTITY),boundsPool.return(C)}matrixPool.return(L)}function checkChildrenDidChange(O,C){const A=O.children;for(let z=0;z<A.length;z++){const I=A[z],L=I.uid,K=(I._didViewChangeTick&65535)<<16|I._didContainerChangeTick&65535,te=C.index;(C.data[te]!==L||C.data[te+1]!==K)&&(C.data[C.index]=L,C.data[C.index+1]=K,C.didChange=!0),C.index=te+2,I.children.length&&checkChildrenDidChange(I,C)}return C.didChange}const tempMatrix$2=new Matrix,measureMixin={_localBoundsCacheId:-1,_localBoundsCacheData:null,_setWidth(O,C){const A=Math.sign(this.scale.x)||1;C!==0?this.scale.x=O/C*A:this.scale.x=A},_setHeight(O,C){const A=Math.sign(this.scale.y)||1;C!==0?this.scale.y=O/C*A:this.scale.y=A},getLocalBounds(){this._localBoundsCacheData||(this._localBoundsCacheData={data:[],index:1,didChange:!1,localBounds:new Bounds});const O=this._localBoundsCacheData;return O.index=1,O.didChange=!1,O.data[0]!==this._didViewChangeTick&&(O.didChange=!0,O.data[0]=this._didViewChangeTick),checkChildrenDidChange(this,O),O.didChange&&getLocalBounds(this,O.localBounds,tempMatrix$2),O.localBounds},getBounds(O,C){return getGlobalBounds(this,O,C||new Bounds)}},onRenderMixin={_onRender:null,set onRender(O){const C=this.renderGroup||this.parentRenderGroup;if(!O){this._onRender&&(C==null||C.removeOnRender(this)),this._onRender=null;return}this._onRender||C==null||C.addOnRender(this),this._onRender=O},get onRender(){return this._onRender}},sortMixin={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(O){this._zIndex!==O&&(this._zIndex=O,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0)},sortChildren(){!this.sortDirty||(this.sortDirty=!1,this.children.sort(sortChildren))}};function sortChildren(O,C){return O._zIndex-C._zIndex}const toLocalGlobalMixin={getGlobalPosition(O=new Point,C=!1){return this.parent?this.parent.toGlobal(this._position,O,C):(O.x=this._position.x,O.y=this._position.y),O},toGlobal(O,C,A=!1){if(!A){this.updateLocalTransform();const z=updateTransformBackwards(this,new Matrix);return z.append(this.localTransform),z.apply(O,C)}return this.worldTransform.apply(O,C)},toLocal(O,C,A,z){if(C&&(O=C.toGlobal(O,A,z)),!z){this.updateLocalTransform();const I=updateTransformBackwards(this,new Matrix);return I.append(this.localTransform),I.applyInverse(O,A)}return this.worldTransform.applyInverse(O,A)}};let _tick=0;class InstructionSet{constructor(){this.uid=uid("instructionSet"),this.instructions=[],this.instructionSize=0,this.renderables=[],this.tick=0}reset(){this.instructionSize=0,this.tick=_tick++}add(C){this.instructions[this.instructionSize++]=C}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}class RenderGroup{constructor(){this.renderPipeId="renderGroup",this.root=null,this.canBundle=!1,this.renderGroupParent=null,this.renderGroupChildren=[],this.worldTransform=new Matrix,this.worldColorAlpha=4294967295,this.worldColor=16777215,this.worldAlpha=1,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new InstructionSet,this._onRenderContainers=[]}init(C){this.root=C,C._onRender&&this.addOnRender(C),C.didChange=!0;const A=C.children;for(let z=0;z<A.length;z++)this.addChild(A[z])}reset(){this.renderGroupChildren.length=0;for(const C in this.childrenToUpdate){const A=this.childrenToUpdate[C];A.list.fill(null),A.index=0}this.childrenRenderablesToUpdate.index=0,this.childrenRenderablesToUpdate.list.fill(null),this.root=null,this.updateTick=0,this.structureDidChange=!0,this._onRenderContainers.length=0,this.renderGroupParent=null}get localTransform(){return this.root.localTransform}addRenderGroupChild(C){C.renderGroupParent&&C.renderGroupParent._removeRenderGroupChild(C),C.renderGroupParent=this,this.renderGroupChildren.push(C)}_removeRenderGroupChild(C){const A=this.renderGroupChildren.indexOf(C);A>-1&&this.renderGroupChildren.splice(A,1),C.renderGroupParent=null}addChild(C){if(this.structureDidChange=!0,C.parentRenderGroup=this,C.updateTick=-1,C.parent===this.root?C.relativeRenderGroupDepth=1:C.relativeRenderGroupDepth=C.parent.relativeRenderGroupDepth+1,C.didChange=!0,this.onChildUpdate(C),C.renderGroup){this.addRenderGroupChild(C.renderGroup);return}C._onRender&&this.addOnRender(C);const A=C.children;for(let z=0;z<A.length;z++)this.addChild(A[z])}removeChild(C){if(this.structureDidChange=!0,C._onRender&&(C.renderGroup||this.removeOnRender(C)),C.parentRenderGroup=null,C.renderGroup){this._removeRenderGroupChild(C.renderGroup);return}const A=C.children;for(let z=0;z<A.length;z++)this.removeChild(A[z])}removeChildren(C){for(let A=0;A<C.length;A++)this.removeChild(C[A])}onChildUpdate(C){let A=this.childrenToUpdate[C.relativeRenderGroupDepth];A||(A=this.childrenToUpdate[C.relativeRenderGroupDepth]={index:0,list:[]}),A.list[A.index++]=C}updateRenderable(C){C.globalDisplayStatus<7||(C.didViewUpdate=!1,this.instructionSet.renderPipes[C.renderPipeId].updateRenderable(C))}onChildViewUpdate(C){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=C}get isRenderable(){return this.root.localDisplayStatus===7&&this.worldAlpha>0}addOnRender(C){this._onRenderContainers.push(C)}removeOnRender(C){this._onRenderContainers.splice(this._onRenderContainers.indexOf(C),1)}runOnRender(){for(let C=0;C<this._onRenderContainers.length;C++)this._onRenderContainers[C]._onRender()}destroy(){this.renderGroupParent=null,this.root=null,this.childrenRenderablesToUpdate=null,this.childrenToUpdate=null,this.renderGroupChildren=null,this._onRenderContainers=null,this.instructionSet=null}getChildren(C=[]){const A=this.root.children;for(let z=0;z<A.length;z++)this._getChildren(A[z],C);return C}_getChildren(C,A=[]){if(A.push(C),C.renderGroup)return A;const z=C.children;for(let I=0;I<z.length;I++)this._getChildren(z[I],A);return A}}function assignWithIgnore(O,C,A={}){for(const z in C)!A[z]&&C[z]!==void 0&&(O[z]=C[z])}const defaultSkew=new ObservablePoint(null),defaultPivot=new ObservablePoint(null),defaultScale=new ObservablePoint(null,1,1),UPDATE_COLOR=1,UPDATE_BLEND=2,UPDATE_VISIBLE=4;class Container extends EventEmitter{constructor(C={}){var A,z;super(),this.uid=uid("renderable"),this._updateFlags=15,this.renderGroup=null,this.parentRenderGroup=null,this.parentRenderGroupIndex=0,this.didChange=!1,this.didViewUpdate=!1,this.relativeRenderGroupDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.updateTick=-1,this.localTransform=new Matrix,this.relativeGroupTransform=new Matrix,this.groupTransform=this.relativeGroupTransform,this.destroyed=!1,this._position=new ObservablePoint(this,0,0),this._scale=defaultScale,this._pivot=defaultPivot,this._skew=defaultSkew,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=16777215,this.localAlpha=1,this.groupAlpha=1,this.groupColor=16777215,this.groupColorAlpha=4294967295,this.localBlendMode="inherit",this.groupBlendMode="normal",this.localDisplayStatus=7,this.globalDisplayStatus=7,this._didContainerChangeTick=0,this._didViewChangeTick=0,this._didLocalTransformChangeId=-1,this.effects=[],assignWithIgnore(this,C,{children:!0,parent:!0,effects:!0}),(A=C.children)==null||A.forEach(I=>this.addChild(I)),(z=C.parent)==null||z.addChild(this)}static mixin(C){Object.defineProperties(Container.prototype,Object.getOwnPropertyDescriptors(C))}set _didChangeId(C){this._didViewChangeTick=C>>12&4095,this._didContainerChangeTick=C&4095}get _didChangeId(){return this._didContainerChangeTick&4095|(this._didViewChangeTick&4095)<<12}addChild(...C){if(this.allowChildren||deprecation(v8_0_0,"addChild: Only Containers will be allowed to add children in v8.0.0"),C.length>1){for(let I=0;I<C.length;I++)this.addChild(C[I]);return C[0]}const A=C[0];if(A.parent===this)return this.children.splice(this.children.indexOf(A),1),this.children.push(A),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),A;A.parent&&A.parent.removeChild(A),this.children.push(A),this.sortableChildren&&(this.sortDirty=!0),A.parent=this,A.didChange=!0,A.didViewUpdate=!1,A._updateFlags=15;const z=this.renderGroup||this.parentRenderGroup;return z&&z.addChild(A),this.emit("childAdded",A,this,this.children.length-1),A.emit("added",this),this._didViewChangeTick++,A._zIndex!==0&&A.depthOfChildModified(),A}removeChild(...C){if(C.length>1){for(let I=0;I<C.length;I++)this.removeChild(C[I]);return C[0]}const A=C[0],z=this.children.indexOf(A);return z>-1&&(this._didViewChangeTick++,this.children.splice(z,1),this.renderGroup?this.renderGroup.removeChild(A):this.parentRenderGroup&&this.parentRenderGroup.removeChild(A),A.parent=null,this.emit("childRemoved",A,this,z),A.emit("removed",this)),A}_onUpdate(C){C&&C===this._skew&&this._updateSkew(),this._didContainerChangeTick++,!this.didChange&&(this.didChange=!0,this.parentRenderGroup&&this.parentRenderGroup.onChildUpdate(this))}set isRenderGroup(C){!!this.renderGroup!==C&&(C?this.enableRenderGroup():this.disableRenderGroup())}get isRenderGroup(){return!!this.renderGroup}enableRenderGroup(){if(this.renderGroup)return;const C=this.parentRenderGroup;C==null||C.removeChild(this),this.renderGroup=BigPool.get(RenderGroup,this),this.groupTransform=Matrix.IDENTITY,C==null||C.addChild(this),this._updateIsSimple()}disableRenderGroup(){if(!this.renderGroup)return;const C=this.parentRenderGroup;C==null||C.removeChild(this),BigPool.return(this.renderGroup),this.renderGroup=null,this.groupTransform=this.relativeGroupTransform,C==null||C.addChild(this),this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.renderGroup&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new Matrix),this.renderGroup?this._worldTransform.copyFrom(this.renderGroup.worldTransform):this.parentRenderGroup&&this._worldTransform.appendFrom(this.relativeGroupTransform,this.parentRenderGroup.worldTransform),this._worldTransform}get x(){return this._position.x}set x(C){this._position.x=C}get y(){return this._position.y}set y(C){this._position.y=C}get position(){return this._position}set position(C){this._position.copyFrom(C)}get rotation(){return this._rotation}set rotation(C){this._rotation!==C&&(this._rotation=C,this._onUpdate(this._skew))}get angle(){return this.rotation*RAD_TO_DEG}set angle(C){this.rotation=C*DEG_TO_RAD}get pivot(){return this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot}set pivot(C){this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),typeof C=="number"?this._pivot.set(C):this._pivot.copyFrom(C)}get skew(){return this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew}set skew(C){this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew.copyFrom(C)}get scale(){return this._scale===defaultScale&&(this._scale=new ObservablePoint(this,1,1)),this._scale}set scale(C){this._scale===defaultScale&&(this._scale=new ObservablePoint(this,0,0)),typeof C=="number"?this._scale.set(C):this._scale.copyFrom(C)}get width(){return Math.abs(this.scale.x*this.getLocalBounds().width)}set width(C){const A=this.getLocalBounds().width;this._setWidth(C,A)}get height(){return Math.abs(this.scale.y*this.getLocalBounds().height)}set height(C){const A=this.getLocalBounds().height;this._setHeight(C,A)}getSize(C){C||(C={});const A=this.getLocalBounds();return C.width=Math.abs(this.scale.x*A.width),C.height=Math.abs(this.scale.y*A.height),C}setSize(C,A){var I;const z=this.getLocalBounds();typeof C=="object"?(A=(I=C.height)!=null?I:C.width,C=C.width):A!=null||(A=C),C!==void 0&&this._setWidth(C,z.width),A!==void 0&&this._setHeight(A,z.height)}_updateSkew(){const C=this._rotation,A=this._skew;this._cx=Math.cos(C+A._y),this._sx=Math.sin(C+A._y),this._cy=-Math.sin(C-A._x),this._sy=Math.cos(C-A._x)}updateTransform(C){return this.position.set(typeof C.x=="number"?C.x:this.position.x,typeof C.y=="number"?C.y:this.position.y),this.scale.set(typeof C.scaleX=="number"?C.scaleX||1:this.scale.x,typeof C.scaleY=="number"?C.scaleY||1:this.scale.y),this.rotation=typeof C.rotation=="number"?C.rotation:this.rotation,this.skew.set(typeof C.skewX=="number"?C.skewX:this.skew.x,typeof C.skewY=="number"?C.skewY:this.skew.y),this.pivot.set(typeof C.pivotX=="number"?C.pivotX:this.pivot.x,typeof C.pivotY=="number"?C.pivotY:this.pivot.y),this}setFromMatrix(C){C.decompose(this)}updateLocalTransform(){const C=this._didContainerChangeTick;if(this._didLocalTransformChangeId===C)return;this._didLocalTransformChangeId=C;const A=this.localTransform,z=this._scale,I=this._pivot,L=this._position,K=z._x,te=z._y,ne=I._x,ie=I._y;A.a=this._cx*K,A.b=this._sx*K,A.c=this._cy*te,A.d=this._sy*te,A.tx=L._x-(ne*A.a+ie*A.c),A.ty=L._y-(ne*A.b+ie*A.d)}set alpha(C){C!==this.localAlpha&&(this.localAlpha=C,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get alpha(){return this.localAlpha}set tint(C){const z=Color.shared.setValue(C!=null?C:16777215).toBgrNumber();z!==this.localColor&&(this.localColor=z,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get tint(){const C=this.localColor;return((C&255)<<16)+(C&65280)+(C>>16&255)}set blendMode(C){this.localBlendMode!==C&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_BLEND,this.localBlendMode=C,this._onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localDisplayStatus&2)}set visible(C){const A=C?2:0;(this.localDisplayStatus&2)!==A&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=2,this._onUpdate())}get culled(){return!(this.localDisplayStatus&4)}set culled(C){const A=C?0:4;(this.localDisplayStatus&4)!==A&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=4,this._onUpdate())}get renderable(){return!!(this.localDisplayStatus&1)}set renderable(C){const A=C?1:0;(this.localDisplayStatus&1)!==A&&(this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=1,this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._onUpdate())}get isRenderable(){return this.localDisplayStatus===7&&this.groupAlpha>0}destroy(C=!1){var I;if(this.destroyed)return;this.destroyed=!0;const A=this.removeChildren(0,this.children.length);if(this.removeFromParent(),this.parent=null,this._maskEffect=null,this._filterEffect=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._skew=null,this.emit("destroyed",this),this.removeAllListeners(),typeof C=="boolean"?C:C==null?void 0:C.children)for(let L=0;L<A.length;++L)A[L].destroy(C);(I=this.renderGroup)==null||I.destroy(),this.renderGroup=null}}Container.mixin(childrenHelperMixin),Container.mixin(toLocalGlobalMixin),Container.mixin(onRenderMixin),Container.mixin(measureMixin),Container.mixin(effectsMixin),Container.mixin(findMixin),Container.mixin(sortMixin),Container.mixin(cullingMixin);class ViewContainer extends Container{constructor(){super(...arguments),this.canBundle=!0,this.allowChildren=!1,this._roundPixels=0,this._lastUsed=0,this._lastInstructionTick=-1,this._bounds=new Bounds(0,1,0,0),this._boundsDirty=!0}_updateBounds(){}get roundPixels(){return!!this._roundPixels}set roundPixels(C){this._roundPixels=C?1:0}containsPoint(C){const A=this.bounds,{x:z,y:I}=C;return z>=A.minX&&z<=A.maxX&&I>=A.minY&&I<=A.maxY}destroy(C){super.destroy(C),this._bounds=null}}class Sprite extends ViewContainer{constructor(C=Texture.EMPTY){C instanceof Texture&&(C={texture:C});const{texture:A=Texture.EMPTY,anchor:z,roundPixels:I,width:L,height:K,...te}=C;super({label:"Sprite",...te}),this.renderPipeId="sprite",this.batched=!0,this._didSpriteUpdate=!1,this._sourceBounds={minX:0,maxX:1,minY:0,maxY:0},this._sourceBoundsDirty=!0,this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),z?this.anchor=z:A.defaultAnchor&&(this.anchor=A.defaultAnchor),this.texture=A,this.allowChildren=!1,this.roundPixels=I!=null?I:!1,L!==void 0&&(this.width=L),K!==void 0&&(this.height=K)}static from(C,A=!1){return C instanceof Texture?new Sprite(C):new Sprite(Texture.from(C,A))}set texture(C){C||(C=Texture.EMPTY);const A=this._texture;A!==C&&(A&&A.dynamic&&A.off("update",this.onViewUpdate,this),C.dynamic&&C.on("update",this.onViewUpdate,this),this._texture=C,this._width&&this._setWidth(this._width,this._texture.orig.width),this._height&&this._setHeight(this._height,this._texture.orig.height),this.onViewUpdate())}get texture(){return this._texture}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}get sourceBounds(){return this._sourceBoundsDirty&&(this._updateSourceBounds(),this._sourceBoundsDirty=!1),this._sourceBounds}containsPoint(C){const A=this.sourceBounds;return C.x>=A.maxX&&C.x<=A.minX&&C.y>=A.maxY&&C.y<=A.minY}addBounds(C){const A=this._texture.trim?this.sourceBounds:this.bounds;C.addFrame(A.minX,A.minY,A.maxX,A.maxY)}onViewUpdate(){if(this._didViewChangeTick++,this._didSpriteUpdate=!0,this._sourceBoundsDirty=this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const C=this.renderGroup||this.parentRenderGroup;C&&C.onChildViewUpdate(this)}_updateBounds(){updateQuadBounds(this._bounds,this._anchor,this._texture,0)}_updateSourceBounds(){const C=this._anchor,A=this._texture,z=this._sourceBounds,{width:I,height:L}=A.orig;z.maxX=-C._x*I,z.minX=z.maxX+I,z.maxY=-C._y*L,z.minY=z.maxY+L}destroy(C=!1){if(super.destroy(C),typeof C=="boolean"?C:C==null?void 0:C.texture){const z=typeof C=="boolean"?C:C==null?void 0:C.textureSource;this._texture.destroy(z)}this._texture=null,this._bounds=null,this._sourceBounds=null,this._anchor=null}get anchor(){return this._anchor}set anchor(C){typeof C=="number"?this._anchor.set(C):this._anchor.copyFrom(C)}get width(){return Math.abs(this.scale.x)*this._texture.orig.width}set width(C){this._setWidth(C,this._texture.orig.width),this._width=C}get height(){return Math.abs(this.scale.y)*this._texture.orig.height}set height(C){this._setHeight(C,this._texture.orig.height),this._height=C}getSize(C){return C||(C={}),C.width=Math.abs(this.scale.x)*this._texture.orig.width,C.height=Math.abs(this.scale.y)*this._texture.orig.height,C}setSize(C,A){var z;typeof C=="object"?(A=(z=C.height)!=null?z:C.width,C=C.width):A!=null||(A=C),C!==void 0&&this._setWidth(C,this._texture.orig.width),A!==void 0&&this._setHeight(A,this._texture.orig.height)}}const tempBounds$1=new Bounds;function addMaskBounds(O,C,A){const z=tempBounds$1;O.measurable=!0,getGlobalBounds(O,A,z),C.addBoundsMask(z),O.measurable=!1}function addMaskLocalBounds(O,C,A){const z=boundsPool.get();O.measurable=!0;const I=matrixPool.get().identity(),L=getMatrixRelativeToParent(O,A,I);getLocalBounds(O,z,L),O.measurable=!1,C.addBoundsMask(z),matrixPool.return(I),boundsPool.return(z)}function getMatrixRelativeToParent(O,C,A){return O?(O!==C&&(getMatrixRelativeToParent(O.parent,C,A),O.updateLocalTransform(),A.append(O.localTransform)),A):(warn("Mask bounds, renderable is not inside the root container"),A)}class AlphaMask{constructor(C){this.priority=0,this.pipe="alphaMask",C!=null&&C.mask&&this.init(C.mask)}init(C){this.mask=C,this.renderMaskToTexture=!(C instanceof Sprite),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask=null}addBounds(C,A){addMaskBounds(this.mask,C,A)}addLocalBounds(C,A){addMaskLocalBounds(this.mask,C,A)}containsPoint(C,A){const z=this.mask;return A(z,C)}destroy(){this.reset()}static test(C){return C instanceof Sprite}}AlphaMask.extension=ExtensionType.MaskEffect;class ColorMask{constructor(C){this.priority=0,this.pipe="colorMask",C!=null&&C.mask&&this.init(C.mask)}init(C){this.mask=C}destroy(){}static test(C){return typeof C=="number"}}ColorMask.extension=ExtensionType.MaskEffect;class StencilMask{constructor(C){this.priority=0,this.pipe="stencilMask",C!=null&&C.mask&&this.init(C.mask)}init(C){this.mask=C,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null}addBounds(C,A){addMaskBounds(this.mask,C,A)}addLocalBounds(C,A){addMaskLocalBounds(this.mask,C,A)}containsPoint(C,A){const z=this.mask;return A(z,C)}destroy(){this.reset()}static test(C){return C instanceof Container}}StencilMask.extension=ExtensionType.MaskEffect;const BrowserAdapter={createCanvas:(O,C)=>{const A=document.createElement("canvas");return A.width=O,A.height=C,A},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>{var O;return(O=document.baseURI)!=null?O:window.location.href},getFontFaceSet:()=>document.fonts,fetch:(O,C)=>fetch(O,C),parseXML:O=>new DOMParser().parseFromString(O,"text/xml")};let currentAdapter=BrowserAdapter;const DOMAdapter={get(){return currentAdapter},set(O){currentAdapter=O}};class CanvasSource extends TextureSource{constructor(C){C.resource||(C.resource=DOMAdapter.get().createCanvas()),C.width||(C.width=C.resource.width,C.autoDensity||(C.width/=C.resolution)),C.height||(C.height=C.resource.height,C.autoDensity||(C.height/=C.resolution)),super(C),this.uploadMethodId="image",this.autoDensity=C.autoDensity;const A=C.resource;(this.pixelWidth!==A.width||this.pixelWidth!==A.height)&&this.resizeCanvas(),this.transparent=!!C.transparent}resizeCanvas(){this.autoDensity&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),(this.resource.width!==this.pixelWidth||this.resource.height!==this.pixelHeight)&&(this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight)}resize(C=this.width,A=this.height,z=this._resolution){const I=super.resize(C,A,z);return I&&this.resizeCanvas(),I}static test(C){return globalThis.HTMLCanvasElement&&C instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&C instanceof OffscreenCanvas}}CanvasSource.extension=ExtensionType.TextureSource;class ImageSource extends TextureSource{constructor(C){if(C.resource&&globalThis.HTMLImageElement&&C.resource instanceof HTMLImageElement){const A=DOMAdapter.get().createCanvas(C.resource.width,C.resource.height);A.getContext("2d").drawImage(C.resource,0,0,C.resource.width,C.resource.height),C.resource=A,warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.")}super(C),this.uploadMethodId="image",this.autoGarbageCollect=!0}static test(C){return globalThis.HTMLImageElement&&C instanceof HTMLImageElement||typeof ImageBitmap!="undefined"&&C instanceof ImageBitmap||globalThis.VideoFrame&&C instanceof VideoFrame}}ImageSource.extension=ExtensionType.TextureSource;var UPDATE_PRIORITY=(O=>(O[O.INTERACTION=50]="INTERACTION",O[O.HIGH=25]="HIGH",O[O.NORMAL=0]="NORMAL",O[O.LOW=-25]="LOW",O[O.UTILITY=-50]="UTILITY",O))(UPDATE_PRIORITY||{});class TickerListener{constructor(C,A=null,z=0,I=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=C,this._context=A,this.priority=z,this._once=I}match(C,A=null){return this._fn===C&&this._context===A}emit(C){this._fn&&(this._context?this._fn.call(this._context,C):this._fn(C));const A=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),A}connect(C){this.previous=C,C.next&&(C.next.previous=this),this.next=C.next,C.next=this}destroy(C=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const A=this.next;return this.next=C?null:A,this.previous=null,A}}const _Ticker=class rr{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/rr.targetFPMS,this.elapsedMS=1/rr.targetFPMS,this._tick=C=>{this._requestId=null,this.started&&(this.update(C),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(C,A,z=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(C,A,z))}addOnce(C,A,z=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(C,A,z,!0))}_addListener(C){let A=this._head.next,z=this._head;if(!A)C.connect(z);else{for(;A;){if(C.priority>A.priority){C.connect(z);break}z=A,A=A.next}C.previous||C.connect(z)}return this._startIfPossible(),this}remove(C,A){let z=this._head.next;for(;z;)z.match(C,A)?z=z.destroy():z=z.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let C=0,A=this._head;for(;A=A.next;)C++;return C}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let C=this._head.next;for(;C;)C=C.destroy(!0);this._head.destroy(),this._head=null}}update(C=performance.now()){let A;if(C>this.lastTime){if(A=this.elapsedMS=C-this.lastTime,A>this._maxElapsedMS&&(A=this._maxElapsedMS),A*=this.speed,this._minElapsedMS){const L=C-this._lastFrame|0;if(L<this._minElapsedMS)return;this._lastFrame=C-L%this._minElapsedMS}this.deltaMS=A,this.deltaTime=this.deltaMS*rr.targetFPMS;const z=this._head;let I=z.next;for(;I;)I=I.emit(this);z.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=C}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(C){const A=Math.min(this.maxFPS,C),z=Math.min(Math.max(0,A)/1e3,rr.targetFPMS);this._maxElapsedMS=1/z}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(C){if(C===0)this._minElapsedMS=0;else{const A=Math.max(this.minFPS,C);this._minElapsedMS=1/(A/1e3)}}static get shared(){if(!rr._shared){const C=rr._shared=new rr;C.autoStart=!0,C._protected=!0}return rr._shared}static get system(){if(!rr._system){const C=rr._system=new rr;C.autoStart=!0,C._protected=!0}return rr._system}};_Ticker.targetFPMS=.06;let Ticker=_Ticker,promise;async function detectVideoAlphaMode(){return promise!=null||(promise=(async()=>{var K;const C=document.createElement("canvas").getContext("webgl");if(!C)return"premultiply-alpha-on-upload";const A=await new Promise(te=>{const ne=document.createElement("video");ne.onloadeddata=()=>te(ne),ne.onerror=()=>te(null),ne.autoplay=!1,ne.crossOrigin="anonymous",ne.preload="auto",ne.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",ne.load()});if(!A)return"premultiply-alpha-on-upload";const z=C.createTexture();C.bindTexture(C.TEXTURE_2D,z);const I=C.createFramebuffer();C.bindFramebuffer(C.FRAMEBUFFER,I),C.framebufferTexture2D(C.FRAMEBUFFER,C.COLOR_ATTACHMENT0,C.TEXTURE_2D,z,0),C.pixelStorei(C.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),C.pixelStorei(C.UNPACK_COLORSPACE_CONVERSION_WEBGL,C.NONE),C.texImage2D(C.TEXTURE_2D,0,C.RGBA,C.RGBA,C.UNSIGNED_BYTE,A);const L=new Uint8Array(4);return C.readPixels(0,0,1,1,C.RGBA,C.UNSIGNED_BYTE,L),C.deleteFramebuffer(I),C.deleteTexture(z),(K=C.getExtension("WEBGL_lose_context"))==null||K.loseContext(),L[0]<=L[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),promise}const _VideoSource=class Yr extends TextureSource{constructor(C){var A;super(C),this.isReady=!1,this.uploadMethodId="video",C={...Yr.defaultOptions,...C},this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=C.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=C.autoPlay!==!1,this.alphaMode=(A=C.alphaMode)!=null?A:"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),C.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const C=Ticker.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-C)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const C=this.resource,A=this.options;return(C.readyState===C.HAVE_ENOUGH_DATA||C.readyState===C.HAVE_FUTURE_DATA)&&C.width&&C.height&&(C.complete=!0),C.addEventListener("play",this._onPlayStart),C.addEventListener("pause",this._onPlayStop),C.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(A.preload||C.addEventListener("canplay",this._onCanPlay),C.addEventListener("canplaythrough",this._onCanPlayThrough),C.addEventListener("error",this._onError,!0)),this.alphaMode=await detectVideoAlphaMode(),this._load=new Promise((z,I)=>{this.isValid?z(this):(this._resolve=z,this._reject=I,A.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${A.preloadTimeoutMs}ms`))})),C.load())}),this._load}_onError(C){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",C),this._reject&&(this._reject(C),this._reject=null,this._resolve=null)}_isSourcePlaying(){const C=this.resource;return!C.paused&&!C.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const C=this.resource;this.isValid&&(this.isReady=!0,this.resize(C.videoWidth,C.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const C=this.resource;C&&(C.removeEventListener("play",this._onPlayStart),C.removeEventListener("pause",this._onPlayStop),C.removeEventListener("seeked",this._onSeeked),C.removeEventListener("canplay",this._onCanPlay),C.removeEventListener("canplaythrough",this._onCanPlayThrough),C.removeEventListener("error",this._onError,!0),C.pause(),C.src="",C.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(C){C!==this._autoUpdate&&(this._autoUpdate=C,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(C){C!==this._updateFPS&&(this._updateFPS=C,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.resource.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(C){return globalThis.HTMLVideoElement&&C instanceof HTMLVideoElement}};_VideoSource.extension=ExtensionType.TextureSource,_VideoSource.defaultOptions={...TextureSource.defaultOptions,autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1},_VideoSource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};let VideoSource=_VideoSource;const convertToList=(O,C,A=!1)=>(Array.isArray(O)||(O=[O]),C?O.map(z=>typeof z=="string"||A?C(z):z):O);class CacheClass{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(C){return this._cache.has(C)}get(C){const A=this._cache.get(C);return A||warn(`[Assets] Asset id ${C} was not found in the Cache`),A}set(C,A){const z=convertToList(C);let I;for(let ne=0;ne<this.parsers.length;ne++){const ie=this.parsers[ne];if(ie.test(A)){I=ie.getCacheableAssets(z,A);break}}const L=new Map(Object.entries(I||{}));I||z.forEach(ne=>{L.set(ne,A)});const K=[...L.keys()],te={cacheKeys:K,keys:z};z.forEach(ne=>{this._cacheMap.set(ne,te)}),K.forEach(ne=>{const ie=I?I[ne]:A;this._cache.has(ne)&&this._cache.get(ne)!==ie&&warn("[Cache] already has key:",ne),this._cache.set(ne,L.get(ne))})}remove(C){if(!this._cacheMap.has(C)){warn(`[Assets] Asset id ${C} was not found in the Cache`);return}const A=this._cacheMap.get(C);A.cacheKeys.forEach(I=>{this._cache.delete(I)}),A.keys.forEach(I=>{this._cacheMap.delete(I)})}get parsers(){return this._parsers}}const Cache=new CacheClass,sources=[];extensions.handleByList(ExtensionType.TextureSource,sources);function textureSourceFrom(O={}){const C=O&&O.resource,A=C?O.resource:O,z=C?O:{resource:O};for(let I=0;I<sources.length;I++){const L=sources[I];if(L.test(A))return new L(z)}throw new Error(`Could not find a source type for resource: ${z.resource}`)}function resourceToTexture(O={},C=!1){const A=O&&O.resource,z=A?O.resource:O,I=A?O:{resource:O};if(!C&&Cache.has(z))return Cache.get(z);const L=new Texture({source:textureSourceFrom(I)});return L.on("destroy",()=>{Cache.has(z)&&Cache.remove(z)}),C||Cache.set(z,L),L}function textureFrom(O,C=!1){return typeof O=="string"?Cache.get(O):O instanceof TextureSource?new Texture({source:O}):resourceToTexture(O,C)}Texture.from=textureFrom,TextureSource.from=textureSourceFrom,extensions.add(AlphaMask,ColorMask,StencilMask,VideoSource,ImageSource,CanvasSource,BufferImageSource);var LoaderParserPriority=(O=>(O[O.Low=0]="Low",O[O.Normal=1]="Normal",O[O.High=2]="High",O))(LoaderParserPriority||{});function assertPath(O){if(typeof O!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(O)}`)}function removeUrlParams(O){return O.split("?")[0].split("#")[0]}function escapeRegExp(O){return O.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function replaceAll(O,C,A){return O.replace(new RegExp(escapeRegExp(C),"g"),A)}function normalizeStringPosix(O,C){let A="",z=0,I=-1,L=0,K=-1;for(let te=0;te<=O.length;++te){if(te<O.length)K=O.charCodeAt(te);else{if(K===47)break;K=47}if(K===47){if(!(I===te-1||L===1))if(I!==te-1&&L===2){if(A.length<2||z!==2||A.charCodeAt(A.length-1)!==46||A.charCodeAt(A.length-2)!==46){if(A.length>2){const ne=A.lastIndexOf("/");if(ne!==A.length-1){ne===-1?(A="",z=0):(A=A.slice(0,ne),z=A.length-1-A.lastIndexOf("/")),I=te,L=0;continue}}else if(A.length===2||A.length===1){A="",z=0,I=te,L=0;continue}}C&&(A.length>0?A+="/..":A="..",z=2)}else A.length>0?A+=`/${O.slice(I+1,te)}`:A=O.slice(I+1,te),z=te-I-1;I=te,L=0}else K===46&&L!==-1?++L:L=-1}return A}const path={toPosix(O){return replaceAll(O,"\\","/")},isUrl(O){return/^https?:/.test(this.toPosix(O))},isDataUrl(O){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(O)},isBlobUrl(O){return O.startsWith("blob:")},hasProtocol(O){return/^[^/:]+:/.test(this.toPosix(O))},getProtocol(O){assertPath(O),O=this.toPosix(O);const C=/^file:\/\/\//.exec(O);if(C)return C[0];const A=/^[^/:]+:\/{0,2}/.exec(O);return A?A[0]:""},toAbsolute(O,C,A){if(assertPath(O),this.isDataUrl(O)||this.isBlobUrl(O))return O;const z=removeUrlParams(this.toPosix(C!=null?C:DOMAdapter.get().getBaseUrl())),I=removeUrlParams(this.toPosix(A!=null?A:this.rootname(z)));return O=this.toPosix(O),O.startsWith("/")?path.join(I,O.slice(1)):this.isAbsolute(O)?O:this.join(z,O)},normalize(O){if(assertPath(O),O.length===0)return".";if(this.isDataUrl(O)||this.isBlobUrl(O))return O;O=this.toPosix(O);let C="";const A=O.startsWith("/");this.hasProtocol(O)&&(C=this.rootname(O),O=O.slice(C.length));const z=O.endsWith("/");return O=normalizeStringPosix(O,!1),O.length>0&&z&&(O+="/"),A?`/${O}`:C+O},isAbsolute(O){return assertPath(O),O=this.toPosix(O),this.hasProtocol(O)?!0:O.startsWith("/")},join(...O){var A;if(O.length===0)return".";let C;for(let z=0;z<O.length;++z){const I=O[z];if(assertPath(I),I.length>0)if(C===void 0)C=I;else{const L=(A=O[z-1])!=null?A:"";this.joinExtensions.includes(this.extname(L).toLowerCase())?C+=`/../${I}`:C+=`/${I}`}}return C===void 0?".":this.normalize(C)},dirname(O){if(assertPath(O),O.length===0)return".";O=this.toPosix(O);let C=O.charCodeAt(0);const A=C===47;let z=-1,I=!0;const L=this.getProtocol(O),K=O;O=O.slice(L.length);for(let te=O.length-1;te>=1;--te)if(C=O.charCodeAt(te),C===47){if(!I){z=te;break}}else I=!1;return z===-1?A?"/":this.isUrl(K)?L+O:L:A&&z===1?"//":L+O.slice(0,z)},rootname(O){assertPath(O),O=this.toPosix(O);let C="";if(O.startsWith("/")?C="/":C=this.getProtocol(O),this.isUrl(O)){const A=O.indexOf("/",C.length);A!==-1?C=O.slice(0,A):C=O,C.endsWith("/")||(C+="/")}return C},basename(O,C){assertPath(O),C&&assertPath(C),O=removeUrlParams(this.toPosix(O));let A=0,z=-1,I=!0,L;if(C!==void 0&&C.length>0&&C.length<=O.length){if(C.length===O.length&&C===O)return"";let K=C.length-1,te=-1;for(L=O.length-1;L>=0;--L){const ne=O.charCodeAt(L);if(ne===47){if(!I){A=L+1;break}}else te===-1&&(I=!1,te=L+1),K>=0&&(ne===C.charCodeAt(K)?--K===-1&&(z=L):(K=-1,z=te))}return A===z?z=te:z===-1&&(z=O.length),O.slice(A,z)}for(L=O.length-1;L>=0;--L)if(O.charCodeAt(L)===47){if(!I){A=L+1;break}}else z===-1&&(I=!1,z=L+1);return z===-1?"":O.slice(A,z)},extname(O){assertPath(O),O=removeUrlParams(this.toPosix(O));let C=-1,A=0,z=-1,I=!0,L=0;for(let K=O.length-1;K>=0;--K){const te=O.charCodeAt(K);if(te===47){if(!I){A=K+1;break}continue}z===-1&&(I=!1,z=K+1),te===46?C===-1?C=K:L!==1&&(L=1):C!==-1&&(L=-1)}return C===-1||z===-1||L===0||L===1&&C===z-1&&C===A+1?"":O.slice(C,z)},parse(O){assertPath(O);const C={root:"",dir:"",base:"",ext:"",name:""};if(O.length===0)return C;O=removeUrlParams(this.toPosix(O));let A=O.charCodeAt(0);const z=this.isAbsolute(O);let I;C.root=this.rootname(O),z||this.hasProtocol(O)?I=1:I=0;let L=-1,K=0,te=-1,ne=!0,ie=O.length-1,oe=0;for(;ie>=I;--ie){if(A=O.charCodeAt(ie),A===47){if(!ne){K=ie+1;break}continue}te===-1&&(ne=!1,te=ie+1),A===46?L===-1?L=ie:oe!==1&&(oe=1):L!==-1&&(oe=-1)}return L===-1||te===-1||oe===0||oe===1&&L===te-1&&L===K+1?te!==-1&&(K===0&&z?C.base=C.name=O.slice(1,te):C.base=C.name=O.slice(K,te)):(K===0&&z?(C.name=O.slice(1,L),C.base=O.slice(1,te)):(C.name=O.slice(K,L),C.base=O.slice(K,te)),C.ext=O.slice(L,te)),C.dir=this.dirname(O),C},sep:"/",delimiter:":",joinExtensions:[".html"]};function processX(O,C,A,z,I){const L=C[A];for(let K=0;K<L.length;K++){const te=L[K];A<C.length-1?processX(O.replace(z[A],te),C,A+1,z,I):I.push(O.replace(z[A],te))}}function createStringVariations(O){const C=/\{(.*?)\}/g,A=O.match(C),z=[];if(A){const I=[];A.forEach(L=>{const K=L.substring(1,L.length-1).split(",");I.push(K)}),processX(O,I,0,A,z)}else z.push(O);return z}const isSingleItem=O=>!Array.isArray(O);class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(C,A)=>`${C}${this._bundleIdConnector}${A}`,extractAssetIdFromBundle:(C,A)=>A.replace(`${C}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(C){var A,z,I;if(this._bundleIdConnector=(A=C.connector)!=null?A:this._bundleIdConnector,this._createBundleAssetId=(z=C.createBundleAssetId)!=null?z:this._createBundleAssetId,this._extractAssetIdFromBundle=(I=C.extractAssetIdFromBundle)!=null?I:this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...C){C.forEach(A=>{this._preferredOrder.push(A),A.priority||(A.priority=Object.keys(A.params))}),this._resolverHash={}}set basePath(C){this._basePath=C}get basePath(){return this._basePath}set rootPath(C){this._rootPath=C}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(C){if(typeof C=="string")this._defaultSearchParams=C;else{const A=C;this._defaultSearchParams=Object.keys(A).map(z=>`${encodeURIComponent(z)}=${encodeURIComponent(A[z])}`).join("&")}}getAlias(C){const{alias:A,src:z}=C;return convertToList(A||z,L=>typeof L=="string"?L:Array.isArray(L)?L.map(K=>{var te;return(te=K==null?void 0:K.src)!=null?te:K}):L!=null&&L.src?L.src:L,!0)}addManifest(C){this._manifest&&warn("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=C,C.bundles.forEach(A=>{this.addBundle(A.name,A.assets)})}addBundle(C,A){const z=[];let I=A;Array.isArray(A)||(I=Object.entries(A).map(([L,K])=>typeof K=="string"||Array.isArray(K)?{alias:L,src:K}:{alias:L,...K})),I.forEach(L=>{const K=L.src,te=L.alias;let ne;if(typeof te=="string"){const ie=this._createBundleAssetId(C,te);z.push(ie),ne=[te,ie]}else{const ie=te.map(oe=>this._createBundleAssetId(C,oe));z.push(...ie),ne=[...te,...ie]}this.add({...L,alias:ne,src:K})}),this._bundles[C]=z}add(C){const A=[];Array.isArray(C)?A.push(...C):A.push(C);let z;z=L=>{this.hasKey(L)&&warn(`[Resolver] already has key: ${L} overwriting`)},convertToList(A).forEach(L=>{const{src:K}=L;let{data:te,format:ne,loadParser:ie}=L;const oe=convertToList(K).map(he=>typeof he=="string"?createStringVariations(he):Array.isArray(he)?he:[he]),ue=this.getAlias(L);Array.isArray(ue)?ue.forEach(z):z(ue);const de=[];oe.forEach(he=>{he.forEach(fe=>{var xe,Se,Fe;let be={};if(typeof fe!="object"){be.src=fe;for(let Ce=0;Ce<this._parsers.length;Ce++){const Ge=this._parsers[Ce];if(Ge.test(fe)){be=Ge.parse(fe);break}}}else te=(xe=fe.data)!=null?xe:te,ne=(Se=fe.format)!=null?Se:ne,ie=(Fe=fe.loadParser)!=null?Fe:ie,be={...be,...fe};if(!ue)throw new Error(`[Resolver] alias is undefined for this asset: ${be.src}`);be=this._buildResolvedAsset(be,{aliases:ue,data:te,format:ne,loadParser:ie}),de.push(be)})}),ue.forEach(he=>{this._assetMap[he]=de})})}resolveBundle(C){const A=isSingleItem(C);C=convertToList(C);const z={};return C.forEach(I=>{const L=this._bundles[I];if(L){const K=this.resolve(L),te={};for(const ne in K){const ie=K[ne];te[this._extractAssetIdFromBundle(I,ne)]=ie}z[I]=te}}),A?z[C[0]]:z}resolveUrl(C){const A=this.resolve(C);if(typeof C!="string"){const z={};for(const I in A)z[I]=A[I].src;return z}return A.src}resolve(C){const A=isSingleItem(C);C=convertToList(C);const z={};return C.forEach(I=>{if(!this._resolverHash[I])if(this._assetMap[I]){let L=this._assetMap[I];const K=this._getPreferredOrder(L);K==null||K.priority.forEach(te=>{K.params[te].forEach(ne=>{const ie=L.filter(oe=>oe[te]?oe[te]===ne:!1);ie.length&&(L=ie)})}),this._resolverHash[I]=L[0]}else this._resolverHash[I]=this._buildResolvedAsset({alias:[I],src:I},{});z[I]=this._resolverHash[I]}),A?z[C[0]]:z}hasKey(C){return!!this._assetMap[C]}hasBundle(C){return!!this._bundles[C]}_getPreferredOrder(C){for(let A=0;A<C.length;A++){const z=C[0],I=this._preferredOrder.find(L=>L.params.format.includes(z.format));if(I)return I}return this._preferredOrder[0]}_appendDefaultSearchParams(C){if(!this._defaultSearchParams)return C;const A=/\?/.test(C)?"&":"?";return`${C}${A}${this._defaultSearchParams}`}_buildResolvedAsset(C,A){var te,ne;const{aliases:z,data:I,loadParser:L,format:K}=A;return(this._basePath||this._rootPath)&&(C.src=path.toAbsolute(C.src,this._basePath,this._rootPath)),C.alias=(te=z!=null?z:C.alias)!=null?te:[C.src],C.src=this._appendDefaultSearchParams(C.src),C.data={...I||{},...C.data},C.loadParser=L!=null?L:C.loadParser,C.format=(ne=K!=null?K:C.format)!=null?ne:getUrlExtension(C.src),C}}Resolver.RETINA_PREFIX=/@([0-9\.]+)x/;function getUrlExtension(O){return O.split(".").pop().split("?").shift().split("#").shift()}const copySearchParams=(O,C)=>{const A=C.split("?")[1];return A&&(O+=`?${A}`),O},_Spritesheet=class Er{constructor(C,A){this.linkedSheets=[],this._texture=C instanceof Texture?C:null,this.textureSource=C.source,this.textures={},this.animations={},this.data=A;const z=parseFloat(A.meta.scale);z?(this.resolution=z,C.source.resolution=this.resolution):this.resolution=C.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(C=>{this._callback=C,this._batchIndex=0,this._frameKeys.length<=Er.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(C){let A=C;const z=Er.BATCH_SIZE;for(;A-C<z&&A<this._frameKeys.length;){const I=this._frameKeys[A],L=this._frames[I],K=L.frame;if(K){let te=null,ne=null;const ie=L.trimmed!==!1&&L.sourceSize?L.sourceSize:L.frame,oe=new Rectangle(0,0,Math.floor(ie.w)/this.resolution,Math.floor(ie.h)/this.resolution);L.rotated?te=new Rectangle(Math.floor(K.x)/this.resolution,Math.floor(K.y)/this.resolution,Math.floor(K.h)/this.resolution,Math.floor(K.w)/this.resolution):te=new Rectangle(Math.floor(K.x)/this.resolution,Math.floor(K.y)/this.resolution,Math.floor(K.w)/this.resolution,Math.floor(K.h)/this.resolution),L.trimmed!==!1&&L.spriteSourceSize&&(ne=new Rectangle(Math.floor(L.spriteSourceSize.x)/this.resolution,Math.floor(L.spriteSourceSize.y)/this.resolution,Math.floor(K.w)/this.resolution,Math.floor(K.h)/this.resolution)),this.textures[I]=new Texture({source:this.textureSource,frame:te,orig:oe,trim:ne,rotate:L.rotated?2:0,defaultAnchor:L.anchor,defaultBorders:L.borders,label:I.toString()})}A++}}_processAnimations(){const C=this.data.animations||{};for(const A in C){this.animations[A]=[];for(let z=0;z<C[A].length;z++){const I=C[A][z];this.animations[A].push(this.textures[I])}}}_parseComplete(){const C=this._callback;this._callback=null,this._batchIndex=0,C.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*Er.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*Er.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(C=!1){var A;for(const z in this.textures)this.textures[z].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,C&&((A=this._texture)==null||A.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};_Spritesheet.BATCH_SIZE=1e3;let Spritesheet=_Spritesheet;const validImages=["jpg","png","jpeg","avif","webp","basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"];function getCacheableAssets(O,C,A){const z={};if(O.forEach(I=>{z[I]=C}),Object.keys(C.textures).forEach(I=>{z[I]=C.textures[I]}),!A){const I=path.dirname(O[0]);C.linkedSheets.forEach((L,K)=>{const te=getCacheableAssets([`${I}/${C.data.meta.related_multi_packs[K]}`],L,!0);Object.assign(z,te)})}return z}const spritesheetAsset={extension:ExtensionType.Asset,cache:{test:O=>O instanceof Spritesheet,getCacheableAssets:(O,C)=>getCacheableAssets(O,C,!1)},resolver:{extension:{type:ExtensionType.ResolveParser,name:"resolveSpritesheet"},test:O=>{const A=O.split("?")[0].split("."),z=A.pop(),I=A.pop();return z==="json"&&validImages.includes(I)},parse:O=>{var A,z;const C=O.split(".");return{resolution:parseFloat((z=(A=Resolver.RETINA_PREFIX.exec(O))==null?void 0:A[1])!=null?z:"1"),format:C[C.length-2],src:O}}},loader:{name:"spritesheetLoader",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Normal,name:"spritesheetLoader"},async testParse(O,C){return path.extname(C.src).toLowerCase()===".json"&&!!O.frames},async parse(O,C,A){var ie,oe,ue;const{texture:z,imageFilename:I}=(ie=C==null?void 0:C.data)!=null?ie:{};let L=path.dirname(C.src);L&&L.lastIndexOf("/")!==L.length-1&&(L+="/");let K;if(z instanceof Texture)K=z;else{const de=copySearchParams(L+(I!=null?I:O.meta.image),C.src);K=(await A.load([de]))[de]}const te=new Spritesheet(K.source,O);await te.parse();const ne=(oe=O==null?void 0:O.meta)==null?void 0:oe.related_multi_packs;if(Array.isArray(ne)){const de=[];for(const fe of ne){if(typeof fe!="string")continue;let be=L+fe;(ue=C.data)!=null&&ue.ignoreMultiPack||(be=copySearchParams(be,C.src),de.push(A.load({src:be,data:{ignoreMultiPack:!0}})))}const he=await Promise.all(de);te.linkedSheets=he,he.forEach(fe=>{fe.linkedSheets=[te].concat(te.linkedSheets.filter(be=>be!==fe))})}return te},async unload(O,C,A){await A.unload(O.textureSource._sourceOrigin),O.destroy(!1)}}};extensions.add(spritesheetAsset);class FederatedEvent{constructor(C){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=FederatedEvent.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new Point,this.page=new Point,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=C}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(C,A,z){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(C,A,z,I,L){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var appleIphone=/iPhone/i,appleIpod=/iPod/i,appleTablet=/iPad/i,appleUniversal=/\biOS-universal(?:.+)Mac\b/i,androidPhone=/\bAndroid(?:.+)Mobile\b/i,androidTablet=/Android/i,amazonPhone=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,amazonTablet=/Silk/i,windowsPhone=/Windows Phone/i,windowsTablet=/\bWindows(?:.+)ARM\b/i,otherBlackBerry=/BlackBerry/i,otherBlackBerry10=/BB10/i,otherOpera=/Opera Mini/i,otherChrome=/\b(CriOS|Chrome)(?:.+)Mobile/i,otherFirefox=/Mobile(?:.+)Firefox\b/i,isAppleTabletOnIos13=function(O){return typeof O!="undefined"&&O.platform==="MacIntel"&&typeof O.maxTouchPoints=="number"&&O.maxTouchPoints>1&&typeof MSStream=="undefined"};function createMatch(O){return function(C){return C.test(O)}}function isMobile$1(O){var C={userAgent:"",platform:"",maxTouchPoints:0};!O&&typeof navigator!="undefined"?C={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof O=="string"?C.userAgent=O:O&&O.userAgent&&(C={userAgent:O.userAgent,platform:O.platform,maxTouchPoints:O.maxTouchPoints||0});var A=C.userAgent,z=A.split("[FBAN");typeof z[1]!="undefined"&&(A=z[0]),z=A.split("Twitter"),typeof z[1]!="undefined"&&(A=z[0]);var I=createMatch(A),L={apple:{phone:I(appleIphone)&&!I(windowsPhone),ipod:I(appleIpod),tablet:!I(appleIphone)&&(I(appleTablet)||isAppleTabletOnIos13(C))&&!I(windowsPhone),universal:I(appleUniversal),device:(I(appleIphone)||I(appleIpod)||I(appleTablet)||I(appleUniversal)||isAppleTabletOnIos13(C))&&!I(windowsPhone)},amazon:{phone:I(amazonPhone),tablet:!I(amazonPhone)&&I(amazonTablet),device:I(amazonPhone)||I(amazonTablet)},android:{phone:!I(windowsPhone)&&I(amazonPhone)||!I(windowsPhone)&&I(androidPhone),tablet:!I(windowsPhone)&&!I(amazonPhone)&&!I(androidPhone)&&(I(amazonTablet)||I(androidTablet)),device:!I(windowsPhone)&&(I(amazonPhone)||I(amazonTablet)||I(androidPhone)||I(androidTablet))||I(/\bokhttp\b/i)},windows:{phone:I(windowsPhone),tablet:I(windowsTablet),device:I(windowsPhone)||I(windowsTablet)},other:{blackberry:I(otherBlackBerry),blackberry10:I(otherBlackBerry10),opera:I(otherOpera),firefox:I(otherFirefox),chrome:I(otherChrome),device:I(otherBlackBerry)||I(otherBlackBerry10)||I(otherOpera)||I(otherFirefox)||I(otherChrome)},any:!1,phone:!1,tablet:!1};return L.any=L.apple.device||L.android.device||L.windows.device||L.other.device,L.phone=L.apple.phone||L.android.phone||L.windows.phone,L.tablet=L.apple.tablet||L.android.tablet||L.windows.tablet,L}const isMobileCall=(tr=isMobile$1.default)!=null?tr:isMobile$1,isMobile=isMobileCall(globalThis.navigator),KEY_CODE_TAB=9,DIV_TOUCH_SIZE=100,DIV_TOUCH_POS_X=0,DIV_TOUCH_POS_Y=0,DIV_TOUCH_ZINDEX=2,DIV_HOOK_SIZE=1,DIV_HOOK_POS_X=-1e3,DIV_HOOK_POS_Y=-1e3,DIV_HOOK_ZINDEX=2;class AccessibilitySystem{constructor(C,A=isMobile){this._mobileInfo=A,this.debug=!1,this._isActive=!1,this._isMobileAccessibility=!1,this._pool=[],this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._hookDiv=null,(A.tablet||A.phone)&&this._createTouchHook();const z=document.createElement("div");z.style.width=`${DIV_TOUCH_SIZE}px`,z.style.height=`${DIV_TOUCH_SIZE}px`,z.style.position="absolute",z.style.top=`${DIV_TOUCH_POS_X}px`,z.style.left=`${DIV_TOUCH_POS_Y}px`,z.style.zIndex=DIV_TOUCH_ZINDEX.toString(),this._div=z,this._renderer=C,this._onKeyDown=this._onKeyDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}_createTouchHook(){const C=document.createElement("button");C.style.width=`${DIV_HOOK_SIZE}px`,C.style.height=`${DIV_HOOK_SIZE}px`,C.style.position="absolute",C.style.top=`${DIV_HOOK_POS_X}px`,C.style.left=`${DIV_HOOK_POS_Y}px`,C.style.zIndex=DIV_HOOK_ZINDEX.toString(),C.style.backgroundColor="#FF0000",C.title="select to enable accessibility for this content",C.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(C),this._hookDiv=C}_destroyTouchHook(){!this._hookDiv||(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){var C;this._isActive||(this._isActive=!0,globalThis.document.addEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.add(this),(C=this._renderer.view.canvas.parentNode)==null||C.appendChild(this._div))}_deactivate(){var C;!this._isActive||this._isMobileAccessibility||(this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.addEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.remove(this),(C=this._div.parentNode)==null||C.removeChild(this._div))}_updateAccessibleObjects(C){if(!C.visible||!C.accessibleChildren)return;C.accessible&&C.isInteractive()&&(C._accessibleActive||this._addChild(C),C._renderId=this._renderId);const A=C.children;if(A)for(let z=0;z<A.length;z++)this._updateAccessibleObjects(A[z])}init(C){var A;this.debug=(A=C==null?void 0:C.debug)!=null?A:this.debug,this._renderer.runners.postrender.remove(this)}postrender(){const C=performance.now();if(this._mobileInfo.android.device&&C<this._androidUpdateCount||(this._androidUpdateCount=C+this._androidUpdateFrequency,!this._renderer.renderingToScreen||!this._renderer.view.canvas))return;this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered);const{x:A,y:z,width:I,height:L}=this._renderer.view.canvas.getBoundingClientRect(),{width:K,height:te,resolution:ne}=this._renderer,ie=I/K*ne,oe=L/te*ne;let ue=this._div;ue.style.left=`${A}px`,ue.style.top=`${z}px`,ue.style.width=`${K}px`,ue.style.height=`${te}px`;for(let de=0;de<this._children.length;de++){const he=this._children[de];if(he._renderId!==this._renderId)he._accessibleActive=!1,removeItems(this._children,de,1),this._div.removeChild(he._accessibleDiv),this._pool.push(he._accessibleDiv),he._accessibleDiv=null,de--;else{ue=he._accessibleDiv;let fe=he.hitArea;const be=he.worldTransform;he.hitArea?(ue.style.left=`${(be.tx+fe.x*be.a)*ie}px`,ue.style.top=`${(be.ty+fe.y*be.d)*oe}px`,ue.style.width=`${fe.width*be.a*ie}px`,ue.style.height=`${fe.height*be.d*oe}px`):(fe=he.getBounds().rectangle,this._capHitArea(fe),ue.style.left=`${fe.x*ie}px`,ue.style.top=`${fe.y*oe}px`,ue.style.width=`${fe.width*ie}px`,ue.style.height=`${fe.height*oe}px`,ue.title!==he.accessibleTitle&&he.accessibleTitle!==null&&(ue.title=he.accessibleTitle||""),ue.getAttribute("aria-label")!==he.accessibleHint&&he.accessibleHint!==null&&ue.setAttribute("aria-label",he.accessibleHint||"")),(he.accessibleTitle!==ue.title||he.tabIndex!==ue.tabIndex)&&(ue.title=he.accessibleTitle||"",ue.tabIndex=he.tabIndex,this.debug&&this._updateDebugHTML(ue))}}this._renderId++}_updateDebugHTML(C){C.innerHTML=`type: ${C.type}</br> title : ${C.title}</br> tabIndex: ${C.tabIndex}`}_capHitArea(C){C.x<0&&(C.width+=C.x,C.x=0),C.y<0&&(C.height+=C.y,C.y=0);const{width:A,height:z}=this._renderer;C.x+C.width>A&&(C.width=A-C.x),C.y+C.height>z&&(C.height=z-C.y)}_addChild(C){let A=this._pool.pop();A||(A=document.createElement("button"),A.style.width=`${DIV_TOUCH_SIZE}px`,A.style.height=`${DIV_TOUCH_SIZE}px`,A.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",A.style.position="absolute",A.style.zIndex=DIV_TOUCH_ZINDEX.toString(),A.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?A.setAttribute("aria-live","off"):A.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?A.setAttribute("aria-relevant","additions"):A.setAttribute("aria-relevant","text"),A.addEventListener("click",this._onClick.bind(this)),A.addEventListener("focus",this._onFocus.bind(this)),A.addEventListener("focusout",this._onFocusOut.bind(this))),A.style.pointerEvents=C.accessiblePointerEvents,A.type=C.accessibleType,C.accessibleTitle&&C.accessibleTitle!==null?A.title=C.accessibleTitle:(!C.accessibleHint||C.accessibleHint===null)&&(A.title=`container ${C.tabIndex}`),C.accessibleHint&&C.accessibleHint!==null&&A.setAttribute("aria-label",C.accessibleHint),this.debug&&this._updateDebugHTML(A),C._accessibleActive=!0,C._accessibleDiv=A,A.container=C,this._children.push(C),this._div.appendChild(C._accessibleDiv),C._accessibleDiv.tabIndex=C.tabIndex}_dispatchEvent(C,A){const{container:z}=C.target,I=this._renderer.events.rootBoundary,L=Object.assign(new FederatedEvent(I),{target:z});I.rootTarget=this._renderer.lastObjectRendered,A.forEach(K=>I.dispatchEvent(L,K))}_onClick(C){this._dispatchEvent(C,["click","pointertap","tap"])}_onFocus(C){C.target.getAttribute("aria-live")||C.target.setAttribute("aria-live","assertive"),this._dispatchEvent(C,["mouseover"])}_onFocusOut(C){C.target.getAttribute("aria-live")||C.target.setAttribute("aria-live","polite"),this._dispatchEvent(C,["mouseout"])}_onKeyDown(C){C.keyCode===KEY_CODE_TAB&&this._activate()}_onMouseMove(C){C.movementX===0&&C.movementY===0||this._deactivate()}destroy(){this._destroyTouchHook(),this._div=null,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown),this._pool=null,this._children=null,this._renderer=null}}AccessibilitySystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"accessibility"};const accessibilityTarget={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:null,accessibleType:"button",accessiblePointerEvents:"auto",accessibleChildren:!0,_renderId:-1},idCounts=Object.create(null),idHash=Object.create(null);function createIdFromString(O,C){let A=idHash[O];return A===void 0&&(idCounts[C]===void 0&&(idCounts[C]=1),idHash[O]=A=idCounts[C]++),A}let context;function getTestContext(){return(!context||(context==null?void 0:context.isContextLost()))&&(context=DOMAdapter.get().createCanvas().getContext("webgl",{})),context}let maxFragmentPrecision;function getMaxFragmentPrecision(){if(!maxFragmentPrecision){maxFragmentPrecision="mediump";const O=getTestContext();O&&O.getShaderPrecisionFormat&&(maxFragmentPrecision=O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.HIGH_FLOAT).precision?"highp":"mediump")}return maxFragmentPrecision}function addProgramDefines(O,C,A){return C?O:A?(O=O.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${O}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${O}
        `}function ensurePrecision(O,C,A){const z=A?C.maxSupportedFragmentPrecision:C.maxSupportedVertexPrecision;if(O.substring(0,9)!=="precision"){let I=A?C.requestedFragmentPrecision:C.requestedVertexPrecision;return I==="highp"&&z!=="highp"&&(I="mediump"),`precision ${I} float;
${O}`}else if(z!=="highp"&&O.substring(0,15)==="precision highp")return O.replace("precision highp","precision mediump");return O}function insertVersion(O,C){return C?`#version 300 es
${O}`:O}const fragmentNameCache={},VertexNameCache={};function setProgramName(O,{name:C="pixi-program"},A=!0){C=C.replace(/\s+/g,"-"),C+=A?"-fragment":"-vertex";const z=A?fragmentNameCache:VertexNameCache;return z[C]?(z[C]++,C+=`-${z[C]}`):z[C]=1,O.indexOf("#define SHADER_NAME")!==-1?O:`${`#define SHADER_NAME ${C}`}
${O}`}function stripVersion(O,C){return C?O.replace("#version 300 es",""):O}const processes={stripVersion,ensurePrecision,addProgramDefines,setProgramName,insertVersion},programCache$1=Object.create(null),_GlProgram=class Ir{constructor(C){C={...Ir.defaultOptions,...C};const A=C.fragment.indexOf("#version 300 es")!==-1,z={stripVersion:A,ensurePrecision:{requestedFragmentPrecision:C.preferredFragmentPrecision,requestedVertexPrecision:C.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:C.name},addProgramDefines:A,insertVersion:A};let I=C.fragment,L=C.vertex;Object.keys(processes).forEach(K=>{const te=z[K];I=processes[K](I,te,!0),L=processes[K](L,te,!1)}),this.fragment=I,this.vertex=L,this._key=createIdFromString(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(C){const A=`${C.vertex}:${C.fragment}`;return programCache$1[A]||(programCache$1[A]=new Ir(C)),programCache$1[A]}};_GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let GlProgram=_GlProgram;const attributeFormatData={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function getAttributeInfoFromFormat(O){var C;return(C=attributeFormatData[O])!=null?C:attributeFormatData.float32}const WGSL_TO_VERTEX_TYPES={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function extractAttributesFromGpuProgram({source:O,entryPoint:C}){var I;const A={},z=O.indexOf(`fn ${C}`);if(z!==-1){const L=O.indexOf("->",z);if(L!==-1){const K=O.substring(z,L),te=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let ne;for(;(ne=te.exec(K))!==null;){const ie=(I=WGSL_TO_VERTEX_TYPES[ne[3]])!=null?I:"float32";A[ne[2]]={location:parseInt(ne[1],10),format:ie,stride:getAttributeInfoFromFormat(ie).stride,offset:0,instance:!1,start:0}}}}return A}function extractStructAndGroups(O){var ue,de,he;const C=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,A=/@group\((\d+)\)/,z=/@binding\((\d+)\)/,I=/var(<[^>]+>)? (\w+)/,L=/:\s*(\w+)/,K=/struct\s+(\w+)\s*{([^}]+)}/g,te=/(\w+)\s*:\s*([\w\<\>]+)/g,ne=/struct\s+(\w+)/,ie=(ue=O.match(C))==null?void 0:ue.map(fe=>({group:parseInt(fe.match(A)[1],10),binding:parseInt(fe.match(z)[1],10),name:fe.match(I)[2],isUniform:fe.match(I)[1]==="<uniform>",type:fe.match(L)[1]}));if(!ie)return{groups:[],structs:[]};const oe=(he=(de=O.match(K))==null?void 0:de.map(fe=>{const be=fe.match(ne)[1],xe=fe.match(te).reduce((Se,Fe)=>{const[Ce,Ge]=Fe.split(":");return Se[Ce.trim()]=Ge.trim(),Se},{});return xe?{name:be,members:xe}:null}).filter(({name:fe})=>ie.some(be=>be.type===fe)))!=null?he:[];return{groups:ie,structs:oe}}var ShaderStage=(O=>(O[O.VERTEX=1]="VERTEX",O[O.FRAGMENT=2]="FRAGMENT",O[O.COMPUTE=4]="COMPUTE",O))(ShaderStage||{});function generateGpuLayoutGroups({groups:O}){const C=[];for(let A=0;A<O.length;A++){const z=O[A];C[z.group]||(C[z.group]=[]),z.isUniform?C[z.group].push({binding:z.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):z.type==="sampler"?C[z.group].push({binding:z.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):z.type==="texture_2d"&&C[z.group].push({binding:z.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return C}function generateLayoutHash({groups:O}){const C=[];for(let A=0;A<O.length;A++){const z=O[A];C[z.group]||(C[z.group]={}),C[z.group][z.name]=z.binding}return C}function removeStructAndGroupDuplicates(O,C){const A=new Set,z=new Set,I=[...O.structs,...C.structs].filter(K=>A.has(K.name)?!1:(A.add(K.name),!0)),L=[...O.groups,...C.groups].filter(K=>{const te=`${K.name}-${K.binding}`;return z.has(te)?!1:(z.add(te),!0)});return{structs:I,groups:L}}const programCache=Object.create(null);class GpuProgram{constructor(C){var te,ne;this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:A,vertex:z,layout:I,gpuLayout:L,name:K}=C;if(this.name=K,this.fragment=A,this.vertex=z,A.source===z.source){const ie=extractStructAndGroups(A.source);this.structsAndGroups=ie}else{const ie=extractStructAndGroups(z.source),oe=extractStructAndGroups(A.source);this.structsAndGroups=removeStructAndGroupDuplicates(ie,oe)}this.layout=I!=null?I:generateLayoutHash(this.structsAndGroups),this.gpuLayout=L!=null?L:generateGpuLayoutGroups(this.structsAndGroups),this.autoAssignGlobalUniforms=((te=this.layout[0])==null?void 0:te.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((ne=this.layout[1])==null?void 0:ne.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:C,fragment:A}=this,z=C.source+A.source+C.entryPoint+A.entryPoint;this._layoutKey=createIdFromString(z,"program")}get attributeData(){var C;return(C=this._attributeData)!=null||(this._attributeData=extractAttributesFromGpuProgram(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(C){const A=`${C.vertex.source}:${C.fragment.source}:${C.fragment.entryPoint}:${C.vertex.entryPoint}`;return programCache[A]||(programCache[A]=new GpuProgram(C)),programCache[A]}}const UNIFORM_TYPES_VALUES=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],UNIFORM_TYPES_MAP=UNIFORM_TYPES_VALUES.reduce((O,C)=>(O[C]=!0,O),{});function getDefaultUniformValue(O,C){switch(O){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*C);case"vec3<f32>":return new Float32Array(3*C);case"vec4<f32>":return new Float32Array(4*C);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const _UniformGroup=class jr{constructor(C,A){var I,L;this._touched=0,this.uid=uid("uniform"),this._resourceType="uniformGroup",this._resourceId=uid("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,A={...jr.defaultOptions,...A},this.uniformStructures=C;const z={};for(const K in C){const te=C[K];if(te.name=K,te.size=(I=te.size)!=null?I:1,!UNIFORM_TYPES_MAP[te.type])throw new Error(`Uniform type ${te.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);(L=te.value)!=null||(te.value=getDefaultUniformValue(te.type,te.size)),z[K]=te.value}this.uniforms=z,this._dirtyId=1,this.ubo=A.ubo,this.isStatic=A.isStatic,this._signature=createIdFromString(Object.keys(z).map(K=>`${K}-${C[K].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};_UniformGroup.defaultOptions={ubo:!1,isStatic:!1};let UniformGroup=_UniformGroup;class BindGroup{constructor(C){this.resources=Object.create(null),this._dirty=!0;let A=0;for(const z in C){const I=C[z];this.setResource(I,A++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const C=[];let A=0;for(const z in this.resources)C[A++]=this.resources[z]._resourceId;this._key=C.join("|")}setResource(C,A){var I,L;const z=this.resources[A];C!==z&&(z&&((I=C.off)==null||I.call(C,"change",this.onResourceChange,this)),(L=C.on)==null||L.call(C,"change",this.onResourceChange,this),this.resources[A]=C,this._dirty=!0)}getResource(C){return this.resources[C]}_touch(C){const A=this.resources;for(const z in A)A[z]._touched=C}destroy(){var A;const C=this.resources;for(const z in C){const I=C[z];(A=I.off)==null||A.call(I,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(C){if(this._dirty=!0,C.destroyed){const A=this.resources;for(const z in A)A[z]===C&&(A[z]=null)}else this._updateKey()}}var RendererType=(O=>(O[O.WEBGL=1]="WEBGL",O[O.WEBGPU=2]="WEBGPU",O[O.BOTH=3]="BOTH",O))(RendererType||{});class Shader extends EventEmitter{constructor(C){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:A,glProgram:z,groups:I,resources:L,compatibleRenderers:K,groupMap:te}=C;this.gpuProgram=A,this.glProgram=z,K===void 0&&(K=0,A&&(K|=RendererType.WEBGPU),z&&(K|=RendererType.WEBGL)),this.compatibleRenderers=K;const ne={};if(!L&&!I&&(L={}),L&&I)throw new Error("[Shader] Cannot have both resources and groups");if(!A&&I&&!te)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!A&&I&&te)for(const ie in te)for(const oe in te[ie]){const ue=te[ie][oe];ne[ue]={group:ie,binding:oe,name:ue}}else if(A&&I&&!te){const ie=A.structsAndGroups.groups;te={},ie.forEach(oe=>{te[oe.group]=te[oe.group]||{},te[oe.group][oe.binding]=oe.name,ne[oe.name]=oe})}else if(L){I={},te={},A&&A.structsAndGroups.groups.forEach(ue=>{te[ue.group]=te[ue.group]||{},te[ue.group][ue.binding]=ue.name,ne[ue.name]=ue});let ie=0;for(const oe in L)ne[oe]||(I[99]||(I[99]=new BindGroup,this._ownedBindGroups.push(I[99])),ne[oe]={group:99,binding:ie,name:oe},te[99]=te[99]||{},te[99][ie]=oe,ie++);for(const oe in L){const ue=oe;let de=L[oe];!de.source&&!de._resourceType&&(de=new UniformGroup(de));const he=ne[ue];he&&(I[he.group]||(I[he.group]=new BindGroup,this._ownedBindGroups.push(I[he.group])),I[he.group].setResource(de,he.binding))}}this.groups=I,this._uniformBindMap=te,this.resources=this._buildResourceAccessor(I,ne)}addResource(C,A,z){var I,L;(I=this._uniformBindMap)[A]||(I[A]={}),(L=this._uniformBindMap[A])[z]||(L[z]=C),this.groups[A]||(this.groups[A]=new BindGroup,this._ownedBindGroups.push(this.groups[A]))}_buildResourceAccessor(C,A){const z={};for(const I in A){const L=A[I];Object.defineProperty(z,L.name,{get(){return C[L.group].getResource(L.binding)},set(K){C[L.group].setResource(K,L.binding)}})}return z}destroy(C=!1){var A,z;this.emit("destroy",this),C&&((A=this.gpuProgram)==null||A.destroy(),(z=this.glProgram)==null||z.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(I=>{I.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(C){const{gpu:A,gl:z,...I}=C;let L,K;return A&&(L=GpuProgram.from(A)),z&&(K=GlProgram.from(z)),new Shader({gpuProgram:L,glProgram:K,...I})}}const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},BLEND=0,OFFSET=1,CULLING=2,DEPTH_TEST=3,WINDING=4,DEPTH_MASK=5,_State=class Zr{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<BLEND)}set blend(C){!!(this.data&1<<BLEND)!==C&&(this.data^=1<<BLEND)}get offsets(){return!!(this.data&1<<OFFSET)}set offsets(C){!!(this.data&1<<OFFSET)!==C&&(this.data^=1<<OFFSET)}set cullMode(C){if(C==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=C==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<CULLING)}set culling(C){!!(this.data&1<<CULLING)!==C&&(this.data^=1<<CULLING)}get depthTest(){return!!(this.data&1<<DEPTH_TEST)}set depthTest(C){!!(this.data&1<<DEPTH_TEST)!==C&&(this.data^=1<<DEPTH_TEST)}get depthMask(){return!!(this.data&1<<DEPTH_MASK)}set depthMask(C){!!(this.data&1<<DEPTH_MASK)!==C&&(this.data^=1<<DEPTH_MASK)}get clockwiseFrontFace(){return!!(this.data&1<<WINDING)}set clockwiseFrontFace(C){!!(this.data&1<<WINDING)!==C&&(this.data^=1<<WINDING)}get blendMode(){return this._blendMode}set blendMode(C){this.blend=C!=="none",this._blendMode=C,this._blendModeId=blendModeIds[C]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(C){this.offsets=!!C,this._polygonOffset=C}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const C=new Zr;return C.depthTest=!1,C.blend=!0,C}};_State.default2d=_State.for2d();let State=_State;const _Filter=class Ur extends Shader{constructor(C){C={...Ur.defaultOptions,...C},super(C),this.enabled=!0,this._state=State.for2d(),this.blendMode=C.blendMode,this.padding=C.padding,typeof C.antialias=="boolean"?this.antialias=C.antialias?"on":"off":this.antialias=C.antialias,this.resolution=C.resolution,this.blendRequired=C.blendRequired,this.addResource("uTexture",0,1)}apply(C,A,z,I){C.applyFilter(this,A,z,I)}get blendMode(){return this._state.blendMode}set blendMode(C){this._state.blendMode=C}static from(C){const{gpu:A,gl:z,...I}=C;let L,K;return A&&(L=GpuProgram.from(A)),z&&(K=GlProgram.from(z)),new Ur({gpuProgram:L,glProgram:K,...I})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1};let Filter=_Filter;var earcut$2={exports:{}};earcut$2.exports=earcut,earcut$2.exports.default=earcut;function earcut(O,C,A){A=A||2;var z=C&&C.length,I=z?C[0]*A:O.length,L=linkedList(O,0,I,A,!0),K=[];if(!L||L.next===L.prev)return K;var te,ne,ie,oe,ue,de,he;if(z&&(L=eliminateHoles(O,C,L,A)),O.length>80*A){te=ie=O[0],ne=oe=O[1];for(var fe=A;fe<I;fe+=A)ue=O[fe],de=O[fe+1],ue<te&&(te=ue),de<ne&&(ne=de),ue>ie&&(ie=ue),de>oe&&(oe=de);he=Math.max(ie-te,oe-ne),he=he!==0?32767/he:0}return earcutLinked(L,K,A,te,ne,he,0),K}function linkedList(O,C,A,z,I){var L,K;if(I===signedArea(O,C,A,z)>0)for(L=C;L<A;L+=z)K=insertNode(L,O[L],O[L+1],K);else for(L=A-z;L>=C;L-=z)K=insertNode(L,O[L],O[L+1],K);return K&&equals(K,K.next)&&(removeNode(K),K=K.next),K}function filterPoints(O,C){if(!O)return O;C||(C=O);var A=O,z;do if(z=!1,!A.steiner&&(equals(A,A.next)||area(A.prev,A,A.next)===0)){if(removeNode(A),A=C=A.prev,A===A.next)break;z=!0}else A=A.next;while(z||A!==C);return C}function earcutLinked(O,C,A,z,I,L,K){if(!!O){!K&&L&&indexCurve(O,z,I,L);for(var te=O,ne,ie;O.prev!==O.next;){if(ne=O.prev,ie=O.next,L?isEarHashed(O,z,I,L):isEar(O)){C.push(ne.i/A|0),C.push(O.i/A|0),C.push(ie.i/A|0),removeNode(O),O=ie.next,te=ie.next;continue}if(O=ie,O===te){K?K===1?(O=cureLocalIntersections(filterPoints(O),C,A),earcutLinked(O,C,A,z,I,L,2)):K===2&&splitEarcut(O,C,A,z,I,L):earcutLinked(filterPoints(O),C,A,z,I,L,1);break}}}}function isEar(O){var C=O.prev,A=O,z=O.next;if(area(C,A,z)>=0)return!1;for(var I=C.x,L=A.x,K=z.x,te=C.y,ne=A.y,ie=z.y,oe=I<L?I<K?I:K:L<K?L:K,ue=te<ne?te<ie?te:ie:ne<ie?ne:ie,de=I>L?I>K?I:K:L>K?L:K,he=te>ne?te>ie?te:ie:ne>ie?ne:ie,fe=z.next;fe!==C;){if(fe.x>=oe&&fe.x<=de&&fe.y>=ue&&fe.y<=he&&pointInTriangle(I,te,L,ne,K,ie,fe.x,fe.y)&&area(fe.prev,fe,fe.next)>=0)return!1;fe=fe.next}return!0}function isEarHashed(O,C,A,z){var I=O.prev,L=O,K=O.next;if(area(I,L,K)>=0)return!1;for(var te=I.x,ne=L.x,ie=K.x,oe=I.y,ue=L.y,de=K.y,he=te<ne?te<ie?te:ie:ne<ie?ne:ie,fe=oe<ue?oe<de?oe:de:ue<de?ue:de,be=te>ne?te>ie?te:ie:ne>ie?ne:ie,xe=oe>ue?oe>de?oe:de:ue>de?ue:de,Se=zOrder(he,fe,C,A,z),Fe=zOrder(be,xe,C,A,z),Ce=O.prevZ,Ge=O.nextZ;Ce&&Ce.z>=Se&&Ge&&Ge.z<=Fe;){if(Ce.x>=he&&Ce.x<=be&&Ce.y>=fe&&Ce.y<=xe&&Ce!==I&&Ce!==K&&pointInTriangle(te,oe,ne,ue,ie,de,Ce.x,Ce.y)&&area(Ce.prev,Ce,Ce.next)>=0||(Ce=Ce.prevZ,Ge.x>=he&&Ge.x<=be&&Ge.y>=fe&&Ge.y<=xe&&Ge!==I&&Ge!==K&&pointInTriangle(te,oe,ne,ue,ie,de,Ge.x,Ge.y)&&area(Ge.prev,Ge,Ge.next)>=0))return!1;Ge=Ge.nextZ}for(;Ce&&Ce.z>=Se;){if(Ce.x>=he&&Ce.x<=be&&Ce.y>=fe&&Ce.y<=xe&&Ce!==I&&Ce!==K&&pointInTriangle(te,oe,ne,ue,ie,de,Ce.x,Ce.y)&&area(Ce.prev,Ce,Ce.next)>=0)return!1;Ce=Ce.prevZ}for(;Ge&&Ge.z<=Fe;){if(Ge.x>=he&&Ge.x<=be&&Ge.y>=fe&&Ge.y<=xe&&Ge!==I&&Ge!==K&&pointInTriangle(te,oe,ne,ue,ie,de,Ge.x,Ge.y)&&area(Ge.prev,Ge,Ge.next)>=0)return!1;Ge=Ge.nextZ}return!0}function cureLocalIntersections(O,C,A){var z=O;do{var I=z.prev,L=z.next.next;!equals(I,L)&&intersects(I,z,z.next,L)&&locallyInside(I,L)&&locallyInside(L,I)&&(C.push(I.i/A|0),C.push(z.i/A|0),C.push(L.i/A|0),removeNode(z),removeNode(z.next),z=O=L),z=z.next}while(z!==O);return filterPoints(z)}function splitEarcut(O,C,A,z,I,L){var K=O;do{for(var te=K.next.next;te!==K.prev;){if(K.i!==te.i&&isValidDiagonal(K,te)){var ne=splitPolygon(K,te);K=filterPoints(K,K.next),ne=filterPoints(ne,ne.next),earcutLinked(K,C,A,z,I,L,0),earcutLinked(ne,C,A,z,I,L,0);return}te=te.next}K=K.next}while(K!==O)}function eliminateHoles(O,C,A,z){var I=[],L,K,te,ne,ie;for(L=0,K=C.length;L<K;L++)te=C[L]*z,ne=L<K-1?C[L+1]*z:O.length,ie=linkedList(O,te,ne,z,!1),ie===ie.next&&(ie.steiner=!0),I.push(getLeftmost(ie));for(I.sort(compareX),L=0;L<I.length;L++)A=eliminateHole(I[L],A);return A}function compareX(O,C){return O.x-C.x}function eliminateHole(O,C){var A=findHoleBridge(O,C);if(!A)return C;var z=splitPolygon(A,O);return filterPoints(z,z.next),filterPoints(A,A.next)}function findHoleBridge(O,C){var A=C,z=O.x,I=O.y,L=-1/0,K;do{if(I<=A.y&&I>=A.next.y&&A.next.y!==A.y){var te=A.x+(I-A.y)*(A.next.x-A.x)/(A.next.y-A.y);if(te<=z&&te>L&&(L=te,K=A.x<A.next.x?A:A.next,te===z))return K}A=A.next}while(A!==C);if(!K)return null;var ne=K,ie=K.x,oe=K.y,ue=1/0,de;A=K;do z>=A.x&&A.x>=ie&&z!==A.x&&pointInTriangle(I<oe?z:L,I,ie,oe,I<oe?L:z,I,A.x,A.y)&&(de=Math.abs(I-A.y)/(z-A.x),locallyInside(A,O)&&(de<ue||de===ue&&(A.x>K.x||A.x===K.x&&sectorContainsSector(K,A)))&&(K=A,ue=de)),A=A.next;while(A!==ne);return K}function sectorContainsSector(O,C){return area(O.prev,O,C.prev)<0&&area(C.next,O,O.next)<0}function indexCurve(O,C,A,z){var I=O;do I.z===0&&(I.z=zOrder(I.x,I.y,C,A,z)),I.prevZ=I.prev,I.nextZ=I.next,I=I.next;while(I!==O);I.prevZ.nextZ=null,I.prevZ=null,sortLinked(I)}function sortLinked(O){var C,A,z,I,L,K,te,ne,ie=1;do{for(A=O,O=null,L=null,K=0;A;){for(K++,z=A,te=0,C=0;C<ie&&(te++,z=z.nextZ,!!z);C++);for(ne=ie;te>0||ne>0&&z;)te!==0&&(ne===0||!z||A.z<=z.z)?(I=A,A=A.nextZ,te--):(I=z,z=z.nextZ,ne--),L?L.nextZ=I:O=I,I.prevZ=L,L=I;A=z}L.nextZ=null,ie*=2}while(K>1);return O}function zOrder(O,C,A,z,I){return O=(O-A)*I|0,C=(C-z)*I|0,O=(O|O<<8)&16711935,O=(O|O<<4)&252645135,O=(O|O<<2)&858993459,O=(O|O<<1)&1431655765,C=(C|C<<8)&16711935,C=(C|C<<4)&252645135,C=(C|C<<2)&858993459,C=(C|C<<1)&1431655765,O|C<<1}function getLeftmost(O){var C=O,A=O;do(C.x<A.x||C.x===A.x&&C.y<A.y)&&(A=C),C=C.next;while(C!==O);return A}function pointInTriangle(O,C,A,z,I,L,K,te){return(I-K)*(C-te)>=(O-K)*(L-te)&&(O-K)*(z-te)>=(A-K)*(C-te)&&(A-K)*(L-te)>=(I-K)*(z-te)}function isValidDiagonal(O,C){return O.next.i!==C.i&&O.prev.i!==C.i&&!intersectsPolygon(O,C)&&(locallyInside(O,C)&&locallyInside(C,O)&&middleInside(O,C)&&(area(O.prev,O,C.prev)||area(O,C.prev,C))||equals(O,C)&&area(O.prev,O,O.next)>0&&area(C.prev,C,C.next)>0)}function area(O,C,A){return(C.y-O.y)*(A.x-C.x)-(C.x-O.x)*(A.y-C.y)}function equals(O,C){return O.x===C.x&&O.y===C.y}function intersects(O,C,A,z){var I=sign(area(O,C,A)),L=sign(area(O,C,z)),K=sign(area(A,z,O)),te=sign(area(A,z,C));return!!(I!==L&&K!==te||I===0&&onSegment(O,A,C)||L===0&&onSegment(O,z,C)||K===0&&onSegment(A,O,z)||te===0&&onSegment(A,C,z))}function onSegment(O,C,A){return C.x<=Math.max(O.x,A.x)&&C.x>=Math.min(O.x,A.x)&&C.y<=Math.max(O.y,A.y)&&C.y>=Math.min(O.y,A.y)}function sign(O){return O>0?1:O<0?-1:0}function intersectsPolygon(O,C){var A=O;do{if(A.i!==O.i&&A.next.i!==O.i&&A.i!==C.i&&A.next.i!==C.i&&intersects(A,A.next,O,C))return!0;A=A.next}while(A!==O);return!1}function locallyInside(O,C){return area(O.prev,O,O.next)<0?area(O,C,O.next)>=0&&area(O,O.prev,C)>=0:area(O,C,O.prev)<0||area(O,O.next,C)<0}function middleInside(O,C){var A=O,z=!1,I=(O.x+C.x)/2,L=(O.y+C.y)/2;do A.y>L!=A.next.y>L&&A.next.y!==A.y&&I<(A.next.x-A.x)*(L-A.y)/(A.next.y-A.y)+A.x&&(z=!z),A=A.next;while(A!==O);return z}function splitPolygon(O,C){var A=new Node(O.i,O.x,O.y),z=new Node(C.i,C.x,C.y),I=O.next,L=C.prev;return O.next=C,C.prev=O,A.next=I,I.prev=A,z.next=A,A.prev=z,L.next=z,z.prev=L,z}function insertNode(O,C,A,z){var I=new Node(O,C,A);return z?(I.next=z.next,I.prev=z,z.next.prev=I,z.next=I):(I.prev=I,I.next=I),I}function removeNode(O){O.next.prev=O.prev,O.prev.next=O.next,O.prevZ&&(O.prevZ.nextZ=O.nextZ),O.nextZ&&(O.nextZ.prevZ=O.prevZ)}function Node(O,C,A){this.i=O,this.x=C,this.y=A,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}earcut.deviation=function(O,C,A,z){var I=C&&C.length,L=I?C[0]*A:O.length,K=Math.abs(signedArea(O,0,L,A));if(I)for(var te=0,ne=C.length;te<ne;te++){var ie=C[te]*A,oe=te<ne-1?C[te+1]*A:O.length;K-=Math.abs(signedArea(O,ie,oe,A))}var ue=0;for(te=0;te<z.length;te+=3){var de=z[te]*A,he=z[te+1]*A,fe=z[te+2]*A;ue+=Math.abs((O[de]-O[fe])*(O[he+1]-O[de+1])-(O[de]-O[he])*(O[fe+1]-O[de+1]))}return K===0&&ue===0?0:Math.abs((ue-K)/K)};function signedArea(O,C,A,z){for(var I=0,L=C,K=A-z;L<A;L+=z)I+=(O[K]-O[L])*(O[L+1]+O[K+1]),K=L;return I}earcut.flatten=function(O){for(var C=O[0][0].length,A={vertices:[],holes:[],dimensions:C},z=0,I=0;I<O.length;I++){for(var L=0;L<O[I].length;L++)for(var K=0;K<C;K++)A.vertices.push(O[I][L][K]);I>0&&(z+=O[I-1].length,A.holes.push(z))}return A};var earcut$1=earcut$2.exports;class ResizePlugin{static init(C){Object.defineProperty(this,"resizeTo",{set(A){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=A,A&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{!this._resizeTo||(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let A,z;if(this._resizeTo===globalThis.window)A=globalThis.innerWidth,z=globalThis.innerHeight;else{const{clientWidth:I,clientHeight:L}=this._resizeTo;A=I,z=L}this.renderer.resize(A,z),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=C.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=ExtensionType.Application;class TickerPlugin{static init(C){C=Object.assign({autoStart:!0,sharedTicker:!1},C),Object.defineProperty(this,"ticker",{set(A){this._ticker&&this._ticker.remove(this.render,this),this._ticker=A,A&&A.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=C.sharedTicker?Ticker.shared:new Ticker,C.autoStart&&this.start()}static destroy(){if(this._ticker){const C=this._ticker;this.ticker=null,C.destroy()}}}TickerPlugin.extension=ExtensionType.Application;class AbstractBitmapFont extends EventEmitter{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(C=!1){var A;this.emit("destroy",this),this.removeAllListeners();for(const z in this.chars)(A=this.chars[z].texture)==null||A.destroy();this.chars=null,C&&(this.pages.forEach(z=>z.texture.destroy(!0)),this.pages=null)}}const _FillGradient=class Gr{constructor(C,A,z,I){this.uid=uid("fillGradient"),this.type="linear",this.gradientStops=[],this._styleKey=null,this.x0=C,this.y0=A,this.x1=z,this.y1=I}addColorStop(C,A){return this.gradientStops.push({offset:C,color:Color.shared.setValue(A).toHexa()}),this._styleKey=null,this}buildLinearGradient(){const C=Gr.defaultTextureSize,{gradientStops:A}=this,z=DOMAdapter.get().createCanvas();z.width=C,z.height=C;const I=z.getContext("2d"),L=I.createLinearGradient(0,0,Gr.defaultTextureSize,1);for(let be=0;be<A.length;be++){const xe=A[be];L.addColorStop(xe.offset,xe.color)}I.fillStyle=L,I.fillRect(0,0,C,C),this.texture=new Texture({source:new ImageSource({resource:z,addressModeU:"clamp-to-edge",addressModeV:"repeat"})});const{x0:K,y0:te,x1:ne,y1:ie}=this,oe=new Matrix,ue=ne-K,de=ie-te,he=Math.sqrt(ue*ue+de*de),fe=Math.atan2(de,ue);oe.translate(-K,-te),oe.scale(1/C,1/C),oe.rotate(-fe),oe.scale(256/he,1),this.transform=oe,this._styleKey=null}get styleKey(){if(this._styleKey)return this._styleKey;const C=this.gradientStops.map(I=>`${I.offset}-${I.color}`).join("-"),A=this.texture.uid,z=this.transform.toArray().join("-");return`fill-gradient-${this.uid}-${C}-${A}-${z}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`}};_FillGradient.defaultTextureSize=256;let FillGradient=_FillGradient;const repetitionMap={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class FillPattern{constructor(C,A){this.uid=uid("fillPattern"),this.transform=new Matrix,this._styleKey=null,this.texture=C,this.transform.scale(1/C.frame.width,1/C.frame.height),A&&(C.source.style.addressModeU=repetitionMap[A].addressModeU,C.source.style.addressModeV=repetitionMap[A].addressModeV)}setTransform(C){const A=this.texture;this.transform.copyFrom(C),this.transform.invert(),this.transform.scale(1/A.frame.width,1/A.frame.height),this._styleKey=null}get styleKey(){return this._styleKey?this._styleKey:(this._styleKey=`fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`,this._styleKey)}}var parseSvgPath=parse$1,length={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},segment=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function parse$1(O){var C=[];return O.replace(segment,function(A,z,I){var L=z.toLowerCase();for(I=parseValues(I),L=="m"&&I.length>2&&(C.push([z].concat(I.splice(0,2))),L="l",z=z=="m"?"l":"L");;){if(I.length==length[L])return I.unshift(z),C.push(I);if(I.length<length[L])throw new Error("malformed path data");C.push([z].concat(I.splice(0,length[L])))}}),C}var number=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function parseValues(O){var C=O.match(number);return C?C.map(Number):[]}var parse$2=parseSvgPath;function SVGToGraphicsPath(O,C){const A=parse$2(O),z=[];let I=null,L=0,K=0;for(let te=0;te<A.length;te++){const ne=A[te],ie=ne[0],oe=ne;switch(ie){case"M":L=oe[1],K=oe[2],C.moveTo(L,K);break;case"m":L+=oe[1],K+=oe[2],C.moveTo(L,K);break;case"H":L=oe[1],C.lineTo(L,K);break;case"h":L+=oe[1],C.lineTo(L,K);break;case"V":K=oe[1],C.lineTo(L,K);break;case"v":K+=oe[1],C.lineTo(L,K);break;case"L":L=oe[1],K=oe[2],C.lineTo(L,K);break;case"l":L+=oe[1],K+=oe[2],C.lineTo(L,K);break;case"C":L=oe[5],K=oe[6],C.bezierCurveTo(oe[1],oe[2],oe[3],oe[4],L,K);break;case"c":C.bezierCurveTo(L+oe[1],K+oe[2],L+oe[3],K+oe[4],L+oe[5],K+oe[6]),L+=oe[5],K+=oe[6];break;case"S":L=oe[3],K=oe[4],C.bezierCurveToShort(oe[1],oe[2],L,K);break;case"s":C.bezierCurveToShort(L+oe[1],K+oe[2],L+oe[3],K+oe[4]),L+=oe[3],K+=oe[4];break;case"Q":L=oe[3],K=oe[4],C.quadraticCurveTo(oe[1],oe[2],L,K);break;case"q":C.quadraticCurveTo(L+oe[1],K+oe[2],L+oe[3],K+oe[4]),L+=oe[3],K+=oe[4];break;case"T":L=oe[1],K=oe[2],C.quadraticCurveToShort(L,K);break;case"t":L+=oe[1],K+=oe[2],C.quadraticCurveToShort(L,K);break;case"A":L=oe[6],K=oe[7],C.arcToSvg(oe[1],oe[2],oe[3],oe[4],oe[5],L,K);break;case"a":L+=oe[6],K+=oe[7],C.arcToSvg(oe[1],oe[2],oe[3],oe[4],oe[5],L,K);break;case"Z":case"z":C.closePath(),z.length>0&&(I=z.pop(),I?(L=I.startX,K=I.startY):(L=0,K=0)),I=null;break;default:warn(`Unknown SVG path command: ${ie}`)}ie!=="Z"&&ie!=="z"&&I===null&&(I={startX:L,startY:K},z.push(I))}return C}class Circle{constructor(C=0,A=0,z=0){this.type="circle",this.x=C,this.y=A,this.radius=z}clone(){return new Circle(this.x,this.y,this.radius)}contains(C,A){if(this.radius<=0)return!1;const z=this.radius*this.radius;let I=this.x-C,L=this.y-A;return I*=I,L*=L,I+L<=z}strokeContains(C,A,z){if(this.radius===0)return!1;const I=this.x-C,L=this.y-A,K=this.radius,te=z/2,ne=Math.sqrt(I*I+L*L);return ne<K+te&&ne>K-te}getBounds(C){return C=C||new Rectangle,C.x=this.x-this.radius,C.y=this.y-this.radius,C.width=this.radius*2,C.height=this.radius*2,C}copyFrom(C){return this.x=C.x,this.y=C.y,this.radius=C.radius,this}copyTo(C){return C.copyFrom(this),C}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Ellipse{constructor(C=0,A=0,z=0,I=0){this.type="ellipse",this.x=C,this.y=A,this.halfWidth=z,this.halfHeight=I}clone(){return new Ellipse(this.x,this.y,this.halfWidth,this.halfHeight)}contains(C,A){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let z=(C-this.x)/this.halfWidth,I=(A-this.y)/this.halfHeight;return z*=z,I*=I,z+I<=1}strokeContains(C,A,z){const{halfWidth:I,halfHeight:L}=this;if(I<=0||L<=0)return!1;const K=z/2,te=I-K,ne=L-K,ie=I+K,oe=L+K,ue=C-this.x,de=A-this.y,he=ue*ue/(te*te)+de*de/(ne*ne),fe=ue*ue/(ie*ie)+de*de/(oe*oe);return he>1&&fe<=1}getBounds(C){return C=C||new Rectangle,C.x=this.x-this.halfWidth,C.y=this.y-this.halfHeight,C.width=this.halfWidth*2,C.height=this.halfHeight*2,C}copyFrom(C){return this.x=C.x,this.y=C.y,this.halfWidth=C.halfWidth,this.halfHeight=C.halfHeight,this}copyTo(C){return C.copyFrom(this),C}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function squaredDistanceToLineSegment(O,C,A,z,I,L){const K=O-A,te=C-z,ne=I-A,ie=L-z,oe=K*ne+te*ie,ue=ne*ne+ie*ie;let de=-1;ue!==0&&(de=oe/ue);let he,fe;de<0?(he=A,fe=z):de>1?(he=I,fe=L):(he=A+de*ne,fe=z+de*ie);const be=O-he,xe=C-fe;return be*be+xe*xe}class Polygon{constructor(...C){this.type="polygon";let A=Array.isArray(C[0])?C[0]:C;if(typeof A[0]!="number"){const z=[];for(let I=0,L=A.length;I<L;I++)z.push(A[I].x,A[I].y);A=z}this.points=A,this.closePath=!0}clone(){const C=this.points.slice(),A=new Polygon(C);return A.closePath=this.closePath,A}contains(C,A){let z=!1;const I=this.points.length/2;for(let L=0,K=I-1;L<I;K=L++){const te=this.points[L*2],ne=this.points[L*2+1],ie=this.points[K*2],oe=this.points[K*2+1];ne>A!=oe>A&&C<(ie-te)*((A-ne)/(oe-ne))+te&&(z=!z)}return z}strokeContains(C,A,z){const I=z/2,L=I*I,{points:K}=this,te=K.length-(this.closePath?0:2);for(let ne=0;ne<te;ne+=2){const ie=K[ne],oe=K[ne+1],ue=K[(ne+2)%K.length],de=K[(ne+3)%K.length];if(squaredDistanceToLineSegment(C,A,ie,oe,ue,de)<=L)return!0}return!1}getBounds(C){C=C||new Rectangle;const A=this.points;let z=1/0,I=-1/0,L=1/0,K=-1/0;for(let te=0,ne=A.length;te<ne;te+=2){const ie=A[te],oe=A[te+1];z=ie<z?ie:z,I=ie>I?ie:I,L=oe<L?oe:L,K=oe>K?oe:K}return C.x=z,C.width=I-z,C.y=L,C.height=K-L,C}copyFrom(C){return this.points=C.points.slice(),this.closePath=C.closePath,this}copyTo(C){return C.copyFrom(this),C}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((C,A)=>`${C}, ${A}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const isCornerWithinStroke=(O,C,A,z,I,L)=>{const K=O-A,te=C-z,ne=Math.sqrt(K*K+te*te);return ne>=I-L&&ne<=I+L};class RoundedRectangle{constructor(C=0,A=0,z=0,I=0,L=20){this.type="roundedRectangle",this.x=C,this.y=A,this.width=z,this.height=I,this.radius=L}getBounds(C){return C=C||new Rectangle,C.x=this.x,C.y=this.y,C.width=this.width,C.height=this.height,C}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}copyFrom(C){return this.x=C.x,this.y=C.y,this.width=C.width,this.height=C.height,this}copyTo(C){return C.copyFrom(this),C}contains(C,A){if(this.width<=0||this.height<=0)return!1;if(C>=this.x&&C<=this.x+this.width&&A>=this.y&&A<=this.y+this.height){const z=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(A>=this.y+z&&A<=this.y+this.height-z||C>=this.x+z&&C<=this.x+this.width-z)return!0;let I=C-(this.x+z),L=A-(this.y+z);const K=z*z;if(I*I+L*L<=K||(I=C-(this.x+this.width-z),I*I+L*L<=K)||(L=A-(this.y+this.height-z),I*I+L*L<=K)||(I=C-(this.x+z),I*I+L*L<=K))return!0}return!1}strokeContains(C,A,z){const{x:I,y:L,width:K,height:te,radius:ne}=this,ie=z/2,oe=I+ne,ue=L+ne,de=K-ne*2,he=te-ne*2,fe=I+K,be=L+te;return(C>=I-ie&&C<=I+ie||C>=fe-ie&&C<=fe+ie)&&A>=ue&&A<=ue+he||(A>=L-ie&&A<=L+ie||A>=be-ie&&A<=be+ie)&&C>=oe&&C<=oe+de?!0:C<oe&&A<ue&&isCornerWithinStroke(C,A,oe,ue,ne,ie)||C>fe-ne&&A<ue&&isCornerWithinStroke(C,A,fe-ne,ue,ne,ie)||C>fe-ne&&A>be-ne&&isCornerWithinStroke(C,A,fe-ne,be-ne,ne,ie)||C<oe&&A>be-ne&&isCornerWithinStroke(C,A,oe,be-ne,ne,ie)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}const fragTemplate$1=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function generateIfTestSrc(O){let C="";for(let A=0;A<O;++A)A>0&&(C+=`
else `),A<O-1&&(C+=`if(test == ${A}.0){}`);return C}function checkMaxIfStatementsInShader(O,C){if(O===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const A=C.createShader(C.FRAGMENT_SHADER);try{for(;;){const z=fragTemplate$1.replace(/%forloop%/gi,generateIfTestSrc(O));if(C.shaderSource(A,z),C.compileShader(A),!C.getShaderParameter(A,C.COMPILE_STATUS))O=O/2|0;else break}}finally{C.deleteShader(A)}return O}let maxTexturesPerBatchCache=null;function getMaxTexturesPerBatch(){var C;if(maxTexturesPerBatchCache)return maxTexturesPerBatchCache;const O=getTestContext();return maxTexturesPerBatchCache=O.getParameter(O.MAX_TEXTURE_IMAGE_UNITS),maxTexturesPerBatchCache=checkMaxIfStatementsInShader(maxTexturesPerBatchCache,O),(C=O.getExtension("WEBGL_lose_context"))==null||C.loseContext(),maxTexturesPerBatchCache}const cachedGroups={};function getTextureBatchBindGroup(O,C){let A=2166136261;for(let z=0;z<C;z++)A^=O[z].uid,A=Math.imul(A,16777619),A>>>=0;return cachedGroups[A]||generateTextureBatchBindGroup(O,C,A)}let maxTextures=0;function generateTextureBatchBindGroup(O,C,A){const z={};let I=0;maxTextures||(maxTextures=getMaxTexturesPerBatch());for(let K=0;K<maxTextures;K++){const te=K<C?O[K]:Texture.EMPTY.source;z[I++]=te.source,z[I++]=te.style}const L=new BindGroup(z);return cachedGroups[A]=L,L}class ViewableBuffer{constructor(C){typeof C=="number"?this.rawBinaryData=new ArrayBuffer(C):C instanceof Uint8Array?this.rawBinaryData=C.buffer:this.rawBinaryData=C,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(C){return this[`${C}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(C){switch(C){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${C} isn't a valid view type`)}}}function fastCopy(O,C){const A=O.byteLength/8|0,z=new Float64Array(O,0,A);new Float64Array(C,0,A).set(z);const L=O.byteLength-A*8;if(L>0){const K=new Uint8Array(O,A*8,L);new Uint8Array(C,A*8,L).set(K)}}const BLEND_TO_NPM={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};function getAdjustedBlendModeBlend(O,C){return C.alphaMode==="no-premultiply-alpha"&&BLEND_TO_NPM[O]||O}class BatchTextureArray{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let C=0;C<this.count;C++){const A=this.textures[C];this.textures[C]=null,this.ids[A.uid]=null}this.count=0}}class Batch{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new BatchTextureArray,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const batchPool=[];let batchPoolIndex=0;function getBatchFromPool(){return batchPoolIndex>0?batchPool[--batchPoolIndex]:new Batch}function returnBatchToPool(O){batchPool[batchPoolIndex++]=O}let BATCH_TICK=0;const _Batcher=class Or{constructor(C={}){var L;this.uid=uid("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],Or.defaultOptions.maxTextures=(L=Or.defaultOptions.maxTextures)!=null?L:getMaxTexturesPerBatch(),C={...Or.defaultOptions,...C};const{vertexSize:A,indexSize:z,maxTextures:I}=C;this.attributeBuffer=new ViewableBuffer(A*this._vertexSize*4),this.indexBuffer=new Uint16Array(z),this.maxTextures=I}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let C=0;C<this.batchIndex;C++)returnBatchToPool(this.batches[C]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(C){this._elements[this.elementSize++]=C,C.indexStart=this.indexSize,C.location=this.attributeSize,C.batcher=this,this.indexSize+=C.indexSize,this.attributeSize+=C.vertexSize*this._vertexSize}checkAndUpdateTexture(C,A){const z=C.batch.textures.ids[A._source.uid];return!z&&z!==0?!1:(C.textureId=z,C.texture=A,!0)}updateElement(C){this.dirty=!0,C.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,C.location,C.textureId)}break(C){const A=this._elements;if(!A[this.elementStart])return;let z=getBatchFromPool(),I=z.textures;I.clear();const L=A[this.elementStart];let K=getAdjustedBlendModeBlend(L.blendMode,L.texture._source);this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const te=this.attributeBuffer.float32View,ne=this.attributeBuffer.uint32View,ie=this.indexBuffer;let oe=this._batchIndexSize,ue=this._batchIndexStart,de="startBatch";const he=this.maxTextures;for(let fe=this.elementStart;fe<this.elementSize;++fe){const be=A[fe];A[fe]=null;const Se=be.texture._source,Fe=getAdjustedBlendModeBlend(be.blendMode,Se),Ce=K!==Fe;if(Se._batchTick===BATCH_TICK&&!Ce){be.textureId=Se._textureBindLocation,oe+=be.indexSize,be.packAttributes(te,ne,be.location,be.textureId),be.packIndex(ie,be.indexStart,be.location/this._vertexSize),be.batch=z;continue}Se._batchTick=BATCH_TICK,(I.count>=he||Ce)&&(this._finishBatch(z,ue,oe-ue,I,K,C,de),de="renderBatch",ue=oe,K=Fe,z=getBatchFromPool(),I=z.textures,I.clear(),++BATCH_TICK),be.textureId=Se._textureBindLocation=I.count,I.ids[Se.uid]=I.count,I.textures[I.count++]=Se,be.batch=z,oe+=be.indexSize,be.packAttributes(te,ne,be.location,be.textureId),be.packIndex(ie,be.indexStart,be.location/this._vertexSize)}I.count>0&&(this._finishBatch(z,ue,oe-ue,I,K,C,de),ue=oe,++BATCH_TICK),this.elementStart=this.elementSize,this._batchIndexStart=ue,this._batchIndexSize=oe}_finishBatch(C,A,z,I,L,K,te){C.gpuBindGroup=null,C.bindGroup=null,C.action=te,C.batcher=this,C.textures=I,C.blendMode=L,C.start=A,C.size=z,++BATCH_TICK,this.batches[this.batchIndex++]=C,K.add(C)}finish(C){this.break(C)}ensureAttributeBuffer(C){C*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(C*4)}ensureIndexBuffer(C){C<=this.indexBuffer.length||this._resizeIndexBuffer(C)}_resizeAttributeBuffer(C){const A=Math.max(C,this.attributeBuffer.size*2),z=new ViewableBuffer(A);fastCopy(this.attributeBuffer.rawBinaryData,z.rawBinaryData),this.attributeBuffer=z}_resizeIndexBuffer(C){const A=this.indexBuffer;let z=Math.max(C,A.length*1.5);z+=z%2;const I=z>65535?new Uint32Array(z):new Uint16Array(z);if(I.BYTES_PER_ELEMENT!==A.BYTES_PER_ELEMENT)for(let L=0;L<A.length;L++)I[L]=A[L];else fastCopy(A.buffer,I.buffer);this.indexBuffer=I}destroy(){for(let C=0;C<this.batches.length;C++)returnBatchToPool(this.batches[C]);this.batches=null;for(let C=0;C<this._elements.length;C++)this._elements[C].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};_Batcher.defaultOptions={vertexSize:4,indexSize:6,maxTextures:null};let Batcher=_Batcher;var BufferUsage=(O=>(O[O.MAP_READ=1]="MAP_READ",O[O.MAP_WRITE=2]="MAP_WRITE",O[O.COPY_SRC=4]="COPY_SRC",O[O.COPY_DST=8]="COPY_DST",O[O.INDEX=16]="INDEX",O[O.VERTEX=32]="VERTEX",O[O.UNIFORM=64]="UNIFORM",O[O.STORAGE=128]="STORAGE",O[O.INDIRECT=256]="INDIRECT",O[O.QUERY_RESOLVE=512]="QUERY_RESOLVE",O[O.STATIC=1024]="STATIC",O))(BufferUsage||{});class Buffer extends EventEmitter{constructor(C){let{data:A,size:z}=C;const{usage:I,label:L,shrinkToFit:K}=C;super(),this.uid=uid("buffer"),this._resourceType="buffer",this._resourceId=uid("resource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,this.destroyed=!1,A instanceof Array&&(A=new Float32Array(A)),this._data=A,z=z!=null?z:A==null?void 0:A.byteLength;const te=!!A;this.descriptor={size:z,usage:I,mappedAtCreation:te,label:L},this.shrinkToFit=K!=null?K:!0}get data(){return this._data}set data(C){this.setDataWithSize(C,C.length,!0)}get static(){return!!(this.descriptor.usage&BufferUsage.STATIC)}set static(C){C?this.descriptor.usage|=BufferUsage.STATIC:this.descriptor.usage&=~BufferUsage.STATIC}setDataWithSize(C,A,z){if(this._updateID++,this._updateSize=A*C.BYTES_PER_ELEMENT,this._data===C){z&&this.emit("update",this);return}const I=this._data;if(this._data=C,I.length!==C.length){!this.shrinkToFit&&C.byteLength<I.byteLength?z&&this.emit("update",this):(this.descriptor.size=C.byteLength,this._resourceId=uid("resource"),this.emit("change",this));return}z&&this.emit("update",this)}update(C){this._updateSize=C!=null?C:this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function ensureIsBuffer(O,C){if(!(O instanceof Buffer)){let A=C?BufferUsage.INDEX:BufferUsage.VERTEX;O instanceof Array&&(C?(O=new Uint32Array(O),A=BufferUsage.INDEX|BufferUsage.COPY_DST):(O=new Float32Array(O),A=BufferUsage.VERTEX|BufferUsage.COPY_DST)),O=new Buffer({data:O,label:C?"index-mesh-buffer":"vertex-mesh-buffer",usage:A})}return O}function getGeometryBounds(O,C,A){const z=O.getAttribute(C);if(!z)return A.minX=0,A.minY=0,A.maxX=0,A.maxY=0,A;const I=z.buffer.data;let L=1/0,K=1/0,te=-1/0,ne=-1/0;const ie=I.BYTES_PER_ELEMENT,oe=(z.offset||0)/ie,ue=(z.stride||2*4)/ie;for(let de=oe;de<I.length;de+=ue){const he=I[de],fe=I[de+1];he>te&&(te=he),fe>ne&&(ne=fe),he<L&&(L=he),fe<K&&(K=fe)}return A.minX=L,A.minY=K,A.maxX=te,A.maxY=ne,A}function ensureIsAttribute(O){return(O instanceof Buffer||Array.isArray(O)||O.BYTES_PER_ELEMENT)&&(O={buffer:O}),O.buffer=ensureIsBuffer(O.buffer,!1),O}class Geometry extends EventEmitter{constructor(C){const{attributes:A,indexBuffer:z,topology:I}=C;super(),this.uid=uid("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Bounds,this._boundsDirty=!0,this.attributes=A,this.buffers=[],this.instanceCount=C.instanceCount||1;for(const L in A){const K=A[L]=ensureIsAttribute(A[L]);this.buffers.indexOf(K.buffer)===-1&&(this.buffers.push(K.buffer),K.buffer.on("update",this.onBufferUpdate,this),K.buffer.on("change",this.onBufferUpdate,this))}z&&(this.indexBuffer=ensureIsBuffer(z,!0),this.buffers.push(this.indexBuffer)),this.topology=I||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(C){return this.attributes[C]}getIndex(){return this.indexBuffer}getBuffer(C){return this.getAttribute(C).buffer}getSize(){for(const C in this.attributes){const A=this.attributes[C];return A.buffer.data.length/(A.stride/4||A.size)}return 0}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,getGeometryBounds(this,"aPosition",this._bounds)):this._bounds}destroy(C=!1){this.emit("destroy",this),this.removeAllListeners(),C&&this.buffers.forEach(A=>A.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const placeHolderBufferData=new Float32Array(1),placeHolderIndexData=new Uint32Array(1);class BatchGeometry extends Geometry{constructor(){const A=new Buffer({data:placeHolderBufferData,label:"attribute-batch-buffer",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST,shrinkToFit:!1}),z=new Buffer({data:placeHolderIndexData,label:"index-batch-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST,shrinkToFit:!1}),I=6*4;super({attributes:{aPosition:{buffer:A,format:"float32x2",stride:I,offset:0},aUV:{buffer:A,format:"float32x2",stride:I,offset:2*4},aColor:{buffer:A,format:"unorm8x4",stride:I,offset:4*4},aTextureIdAndRound:{buffer:A,format:"uint16x2",stride:I,offset:5*4}},indexBuffer:z})}}function buildUvs(O,C,A,z,I,L,K,te=null){let ne=0;A*=C,I*=L;const ie=te.a,oe=te.b,ue=te.c,de=te.d,he=te.tx,fe=te.ty;for(;ne<K;){const be=O[A],xe=O[A+1];z[I]=ie*be+ue*xe+he,z[I+1]=oe*be+de*xe+fe,I+=L,A+=C,ne++}}function buildSimpleUvs(O,C,A,z){let I=0;for(C*=A;I<z;)O[C]=0,O[C+1]=0,C+=A,I++}function transformVertices(O,C,A,z,I){const L=C.a,K=C.b,te=C.c,ne=C.d,ie=C.tx,oe=C.ty;A=A||0,z=z||2,I=I||O.length/z-A;let ue=A*z;for(let de=0;de<I;de++){const he=O[ue],fe=O[ue+1];O[ue]=L*he+te*fe+ie,O[ue+1]=K*he+ne*fe+oe,ue+=z}}function multiplyHexColors(O,C){if(O===16777215||!C)return C;if(C===16777215||!O)return O;const A=O>>16&255,z=O>>8&255,I=O&255,L=C>>16&255,K=C>>8&255,te=C&255,ne=A*L/255,ie=z*K/255,oe=I*te/255;return(ne<<16)+(ie<<8)+oe}class BatchableGraphics{constructor(){this.batcher=null,this.batch=null,this.applyTransform=!0,this.roundPixels=0}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}packIndex(C,A,z){const I=this.geometryData.indices;for(let L=0;L<this.indexSize;L++)C[A++]=I[L+this.indexOffset]+z-this.vertexOffset}packAttributes(C,A,z,I){const L=this.geometryData,K=this.renderable,te=L.vertices,ne=L.uvs,ie=this.vertexOffset*2,oe=(this.vertexOffset+this.vertexSize)*2,ue=this.color,de=ue>>16|ue&65280|(ue&255)<<16;if(this.applyTransform){const he=multiplyHexColors(de,K.groupColor)+(this.alpha*K.groupAlpha*255<<24),fe=K.groupTransform,be=I<<16|this.roundPixels&65535,xe=fe.a,Se=fe.b,Fe=fe.c,Ce=fe.d,Ge=fe.tx,Ve=fe.ty;for(let pt=ie;pt<oe;pt+=2){const Ze=te[pt],ct=te[pt+1];C[z]=xe*Ze+Fe*ct+Ge,C[z+1]=Se*Ze+Ce*ct+Ve,C[z+2]=ne[pt],C[z+3]=ne[pt+1],A[z+4]=he,A[z+5]=be,z+=6}}else{const he=de+(this.alpha*255<<24);for(let fe=ie;fe<oe;fe+=2)C[z]=te[fe],C[z+1]=te[fe+1],C[z+2]=ne[fe],C[z+3]=ne[fe+1],A[z+4]=he,A[z+5]=I<<16,z+=6}}get vertSize(){return this.vertexSize}copyTo(C){C.indexOffset=this.indexOffset,C.indexSize=this.indexSize,C.vertexOffset=this.vertexOffset,C.vertexSize=this.vertexSize,C.color=this.color,C.alpha=this.alpha,C.texture=this.texture,C.geometryData=this.geometryData}reset(){this.applyTransform=!0}}const buildCircle={extension:{type:ExtensionType.ShapeBuilder,name:"circle"},build(O,C){let A,z,I,L,K,te;if(O.type==="circle"){const Ge=O;A=Ge.x,z=Ge.y,K=te=Ge.radius,I=L=0}else if(O.type==="ellipse"){const Ge=O;A=Ge.x,z=Ge.y,K=Ge.halfWidth,te=Ge.halfHeight,I=L=0}else{const Ge=O,Ve=Ge.width/2,pt=Ge.height/2;A=Ge.x+Ve,z=Ge.y+pt,K=te=Math.max(0,Math.min(Ge.radius,Math.min(Ve,pt))),I=Ve-K,L=pt-te}if(!(K>=0&&te>=0&&I>=0&&L>=0))return C;const ne=Math.ceil(2.3*Math.sqrt(K+te)),ie=ne*8+(I?4:0)+(L?4:0);if(ie===0)return C;if(ne===0)return C[0]=C[6]=A+I,C[1]=C[3]=z+L,C[2]=C[4]=A-I,C[5]=C[7]=z-L,C;let oe=0,ue=ne*4+(I?2:0)+2,de=ue,he=ie,fe=I+K,be=L,xe=A+fe,Se=A-fe,Fe=z+be;if(C[oe++]=xe,C[oe++]=Fe,C[--ue]=Fe,C[--ue]=Se,L){const Ge=z-be;C[de++]=Se,C[de++]=Ge,C[--he]=Ge,C[--he]=xe}for(let Ge=1;Ge<ne;Ge++){const Ve=Math.PI/2*(Ge/ne),pt=I+Math.cos(Ve)*K,Ze=L+Math.sin(Ve)*te,ct=A+pt,Xe=A-pt,We=z+Ze,Mt=z-Ze;C[oe++]=ct,C[oe++]=We,C[--ue]=We,C[--ue]=Xe,C[de++]=Xe,C[de++]=Mt,C[--he]=Mt,C[--he]=ct}fe=I,be=L+te,xe=A+fe,Se=A-fe,Fe=z+be;const Ce=z-be;return C[oe++]=xe,C[oe++]=Fe,C[--he]=Ce,C[--he]=xe,I&&(C[oe++]=Se,C[oe++]=Fe,C[--he]=Ce,C[--he]=Se),C},triangulate(O,C,A,z,I,L){if(O.length===0)return;let K=0,te=0;for(let oe=0;oe<O.length;oe+=2)K+=O[oe],te+=O[oe+1];K/=O.length/2,te/=O.length/2;let ne=z;C[ne*A]=K,C[ne*A+1]=te;const ie=ne++;for(let oe=0;oe<O.length;oe+=2)C[ne*A]=O[oe],C[ne*A+1]=O[oe+1],oe>0&&(I[L++]=ne,I[L++]=ie,I[L++]=ne-1),ne++;I[L++]=ie+1,I[L++]=ie,I[L++]=ne-1}},buildEllipse={...buildCircle,extension:{...buildCircle.extension,name:"ellipse"}},buildRoundedRectangle={...buildCircle,extension:{...buildCircle.extension,name:"roundedRectangle"}},closePointEps=1e-4,curveEps=1e-4;function getOrientationOfPoints(O){const C=O.length;if(C<6)return 1;let A=0;for(let z=0,I=O[C-2],L=O[C-1];z<C;z+=2){const K=O[z],te=O[z+1];A+=(K-I)*(te+L),I=K,L=te}return A<0?-1:1}function square(O,C,A,z,I,L,K,te){const ne=O-A*I,ie=C-z*I,oe=O+A*L,ue=C+z*L;let de,he;K?(de=z,he=-A):(de=-z,he=A);const fe=ne+de,be=ie+he,xe=oe+de,Se=ue+he;return te.push(fe,be),te.push(xe,Se),2}function round(O,C,A,z,I,L,K,te){const ne=A-O,ie=z-C;let oe=Math.atan2(ne,ie),ue=Math.atan2(I-O,L-C);te&&oe<ue?oe+=Math.PI*2:!te&&oe>ue&&(ue+=Math.PI*2);let de=oe;const he=ue-oe,fe=Math.abs(he),be=Math.sqrt(ne*ne+ie*ie),xe=(15*fe*Math.sqrt(be)/Math.PI>>0)+1,Se=he/xe;if(de+=Se,te){K.push(O,C),K.push(A,z);for(let Fe=1,Ce=de;Fe<xe;Fe++,Ce+=Se)K.push(O,C),K.push(O+Math.sin(Ce)*be,C+Math.cos(Ce)*be);K.push(O,C),K.push(I,L)}else{K.push(A,z),K.push(O,C);for(let Fe=1,Ce=de;Fe<xe;Fe++,Ce+=Se)K.push(O+Math.sin(Ce)*be,C+Math.cos(Ce)*be),K.push(O,C);K.push(I,L),K.push(O,C)}return xe*2}function buildLine(O,C,A,z,I,L,K,te,ne){const ie=closePointEps;if(O.length===0)return;const oe=C;let ue=oe.alignment;if(C.alignment!==.5){let Ht=getOrientationOfPoints(O);A&&(Ht*=-1),ue=(ue-.5)*Ht+.5}const de=new Point(O[0],O[1]),he=new Point(O[O.length-2],O[O.length-1]),fe=z,be=Math.abs(de.x-he.x)<ie&&Math.abs(de.y-he.y)<ie;if(fe){O=O.slice(),be&&(O.pop(),O.pop(),he.set(O[O.length-2],O[O.length-1]));const Ht=(de.x+he.x)*.5,nr=(he.y+de.y)*.5;O.unshift(Ht,nr),O.push(Ht,nr)}const xe=I,Se=O.length/2;let Fe=O.length;const Ce=xe.length/2,Ge=oe.width/2,Ve=Ge*Ge,pt=oe.miterLimit*oe.miterLimit;let Ze=O[0],ct=O[1],Xe=O[2],We=O[3],Mt=0,jt=0,At=-(ct-We),_t=Ze-Xe,It=0,zt=0,xt=Math.sqrt(At*At+_t*_t);At/=xt,_t/=xt,At*=Ge,_t*=Ge;const Lt=ue,dt=(1-Lt)*2,Pt=Lt*2;fe||(oe.cap==="round"?Fe+=round(Ze-At*(dt-Pt)*.5,ct-_t*(dt-Pt)*.5,Ze-At*dt,ct-_t*dt,Ze+At*Pt,ct+_t*Pt,xe,!0)+2:oe.cap==="square"&&(Fe+=square(Ze,ct,At,_t,dt,Pt,!0,xe))),xe.push(Ze-At*dt,ct-_t*dt),xe.push(Ze+At*Pt,ct+_t*Pt);for(let Ht=1;Ht<Se-1;++Ht){Ze=O[(Ht-1)*2],ct=O[(Ht-1)*2+1],Xe=O[Ht*2],We=O[Ht*2+1],Mt=O[(Ht+1)*2],jt=O[(Ht+1)*2+1],At=-(ct-We),_t=Ze-Xe,xt=Math.sqrt(At*At+_t*_t),At/=xt,_t/=xt,At*=Ge,_t*=Ge,It=-(We-jt),zt=Xe-Mt,xt=Math.sqrt(It*It+zt*zt),It/=xt,zt/=xt,It*=Ge,zt*=Ge;const nr=Xe-Ze,hr=ct-We,pr=Xe-Mt,mr=jt-We,wr=nr*pr+hr*mr,gr=hr*pr-mr*nr,dr=gr<0;if(Math.abs(gr)<.001*Math.abs(wr)){xe.push(Xe-At*dt,We-_t*dt),xe.push(Xe+At*Pt,We+_t*Pt),wr>=0&&(oe.join==="round"?Fe+=round(Xe,We,Xe-At*dt,We-_t*dt,Xe-It*dt,We-zt*dt,xe,!1)+4:Fe+=2,xe.push(Xe-It*Pt,We-zt*Pt),xe.push(Xe+It*dt,We+zt*dt));continue}const Ar=(-At+Ze)*(-_t+We)-(-At+Xe)*(-_t+ct),Fr=(-It+Mt)*(-zt+We)-(-It+Xe)*(-zt+jt),xr=(nr*Fr-pr*Ar)/gr,fr=(mr*Ar-hr*Fr)/gr,vr=(xr-Xe)*(xr-Xe)+(fr-We)*(fr-We),or=Xe+(xr-Xe)*dt,ar=We+(fr-We)*dt,lr=Xe-(xr-Xe)*Pt,ir=We-(fr-We)*Pt,Mr=Math.min(nr*nr+hr*hr,pr*pr+mr*mr),Cr=dr?dt:Pt,Rr=Mr+Cr*Cr*Ve;vr<=Rr?oe.join==="bevel"||vr/Ve>pt?(dr?(xe.push(or,ar),xe.push(Xe+At*Pt,We+_t*Pt),xe.push(or,ar),xe.push(Xe+It*Pt,We+zt*Pt)):(xe.push(Xe-At*dt,We-_t*dt),xe.push(lr,ir),xe.push(Xe-It*dt,We-zt*dt),xe.push(lr,ir)),Fe+=2):oe.join==="round"?dr?(xe.push(or,ar),xe.push(Xe+At*Pt,We+_t*Pt),Fe+=round(Xe,We,Xe+At*Pt,We+_t*Pt,Xe+It*Pt,We+zt*Pt,xe,!0)+4,xe.push(or,ar),xe.push(Xe+It*Pt,We+zt*Pt)):(xe.push(Xe-At*dt,We-_t*dt),xe.push(lr,ir),Fe+=round(Xe,We,Xe-At*dt,We-_t*dt,Xe-It*dt,We-zt*dt,xe,!1)+4,xe.push(Xe-It*dt,We-zt*dt),xe.push(lr,ir)):(xe.push(or,ar),xe.push(lr,ir)):(xe.push(Xe-At*dt,We-_t*dt),xe.push(Xe+At*Pt,We+_t*Pt),oe.join==="round"?dr?Fe+=round(Xe,We,Xe+At*Pt,We+_t*Pt,Xe+It*Pt,We+zt*Pt,xe,!0)+2:Fe+=round(Xe,We,Xe-At*dt,We-_t*dt,Xe-It*dt,We-zt*dt,xe,!1)+2:oe.join==="miter"&&vr/Ve<=pt&&(dr?(xe.push(lr,ir),xe.push(lr,ir)):(xe.push(or,ar),xe.push(or,ar)),Fe+=2),xe.push(Xe-It*dt,We-zt*dt),xe.push(Xe+It*Pt,We+zt*Pt),Fe+=2)}Ze=O[(Se-2)*2],ct=O[(Se-2)*2+1],Xe=O[(Se-1)*2],We=O[(Se-1)*2+1],At=-(ct-We),_t=Ze-Xe,xt=Math.sqrt(At*At+_t*_t),At/=xt,_t/=xt,At*=Ge,_t*=Ge,xe.push(Xe-At*dt,We-_t*dt),xe.push(Xe+At*Pt,We+_t*Pt),fe||(oe.cap==="round"?Fe+=round(Xe-At*(dt-Pt)*.5,We-_t*(dt-Pt)*.5,Xe-At*dt,We-_t*dt,Xe+At*Pt,We+_t*Pt,xe,!1)+2:oe.cap==="square"&&(Fe+=square(Xe,We,At,_t,dt,Pt,!1,xe)));const br=curveEps*curveEps;for(let Ht=Ce;Ht<Fe+Ce-2;++Ht)Ze=xe[Ht*2],ct=xe[Ht*2+1],Xe=xe[(Ht+1)*2],We=xe[(Ht+1)*2+1],Mt=xe[(Ht+2)*2],jt=xe[(Ht+2)*2+1],!(Math.abs(Ze*(We-jt)+Xe*(jt-ct)+Mt*(ct-We))<br)&&te.push(Ht,Ht+1,Ht+2)}function triangulateWithHoles(O,C,A,z,I,L,K){const te=earcut$1(O,C,2);if(!te)return;for(let ie=0;ie<te.length;ie+=3)L[K++]=te[ie]+I,L[K++]=te[ie+1]+I,L[K++]=te[ie+2]+I;let ne=I*z;for(let ie=0;ie<O.length;ie+=2)A[ne]=O[ie],A[ne+1]=O[ie+1],ne+=z}const emptyArray=[],buildPolygon={extension:{type:ExtensionType.ShapeBuilder,name:"polygon"},build(O,C){for(let A=0;A<O.points.length;A++)C[A]=O.points[A];return C},triangulate(O,C,A,z,I,L){triangulateWithHoles(O,emptyArray,C,A,z,I,L)}},buildRectangle={extension:{type:ExtensionType.ShapeBuilder,name:"rectangle"},build(O,C){const A=O,z=A.x,I=A.y,L=A.width,K=A.height;return L>=0&&K>=0&&(C[0]=z,C[1]=I,C[2]=z+L,C[3]=I,C[4]=z+L,C[5]=I+K,C[6]=z,C[7]=I+K),C},triangulate(O,C,A,z,I,L){let K=0;z*=A,C[z+K]=O[0],C[z+K+1]=O[1],K+=A,C[z+K]=O[2],C[z+K+1]=O[3],K+=A,C[z+K]=O[6],C[z+K+1]=O[7],K+=A,C[z+K]=O[4],C[z+K+1]=O[5],K+=A;const te=z/A;I[L++]=te,I[L++]=te+1,I[L++]=te+2,I[L++]=te+1,I[L++]=te+3,I[L++]=te+2}},buildTriangle={extension:{type:ExtensionType.ShapeBuilder,name:"triangle"},build(O,C){return C[0]=O.x,C[1]=O.y,C[2]=O.x2,C[3]=O.y2,C[4]=O.x3,C[5]=O.y3,C},triangulate(O,C,A,z,I,L){let K=0;z*=A,C[z+K]=O[0],C[z+K+1]=O[1],K+=A,C[z+K]=O[2],C[z+K+1]=O[3],K+=A,C[z+K]=O[4],C[z+K+1]=O[5];const te=z/A;I[L++]=te,I[L++]=te+1,I[L++]=te+2}},shapeBuilders={};extensions.handleByMap(ExtensionType.ShapeBuilder,shapeBuilders),extensions.add(buildRectangle,buildPolygon,buildTriangle,buildCircle,buildEllipse,buildRoundedRectangle);const tempRect=new Rectangle;function buildContextBatches(O,C){const{geometryData:A,batches:z}=C;z.length=0,A.indices.length=0,A.vertices.length=0,A.uvs.length=0;for(let I=0;I<O.instructions.length;I++){const L=O.instructions[I];if(L.action==="texture")addTextureToGeometryData(L.data,z,A);else if(L.action==="fill"||L.action==="stroke"){const K=L.action==="stroke",te=L.data.path.shapePath,ne=L.data.style,ie=L.data.hole;K&&ie&&addShapePathToGeometryData(ie.shapePath,ne,null,!0,z,A),addShapePathToGeometryData(te,ne,ie,K,z,A)}}}function addTextureToGeometryData(O,C,A){const{vertices:z,uvs:I,indices:L}=A,K=L.length,te=z.length/2,ne=[],ie=shapeBuilders.rectangle,oe=tempRect,ue=O.image;oe.x=O.dx,oe.y=O.dy,oe.width=O.dw,oe.height=O.dh;const de=O.transform;ie.build(oe,ne),de&&transformVertices(ne,de),ie.triangulate(ne,z,2,te,L,K);const he=ue.uvs;I.push(he.x0,he.y0,he.x1,he.y1,he.x3,he.y3,he.x2,he.y2);const fe=BigPool.get(BatchableGraphics);fe.indexOffset=K,fe.indexSize=L.length-K,fe.vertexOffset=te,fe.vertexSize=z.length/2-te,fe.color=O.style,fe.alpha=O.alpha,fe.texture=ue,fe.geometryData=A,C.push(fe)}function addShapePathToGeometryData(O,C,A,z,I,L){const{vertices:K,uvs:te,indices:ne}=L,ie=O.shapePrimitives.length-1;O.shapePrimitives.forEach(({shape:oe,transform:ue},de)=>{var Ge;const he=ne.length,fe=K.length/2,be=[],xe=shapeBuilders[oe.type];if(xe.build(oe,be),ue&&transformVertices(be,ue),z){const Ve=(Ge=oe.closePath)!=null?Ge:!0;buildLine(be,C,!1,Ve,K,2,fe,ne)}else if(A&&ie===de){ie!==0&&console.warn("[Pixi Graphics] only the last shape have be cut out");const Ve=[],pt=be.slice();getHoleArrays(A.shapePath).forEach(ct=>{Ve.push(pt.length/2),pt.push(...ct)}),triangulateWithHoles(pt,Ve,K,2,fe,ne,he)}else xe.triangulate(be,K,2,fe,ne,he);const Se=te.length/2,Fe=C.texture;if(Fe!==Texture.WHITE){const Ve=C.matrix;Ve&&(ue&&Ve.append(ue.clone().invert()),buildUvs(K,2,fe,te,Se,2,K.length/2-fe,Ve))}else buildSimpleUvs(te,Se,2,K.length/2-fe);const Ce=BigPool.get(BatchableGraphics);Ce.indexOffset=he,Ce.indexSize=ne.length-he,Ce.vertexOffset=fe,Ce.vertexSize=K.length/2-fe,Ce.color=C.color,Ce.alpha=C.alpha,Ce.texture=Fe,Ce.geometryData=L,I.push(Ce)})}function getHoleArrays(O){if(!O)return[];const C=O.shapePrimitives,A=[];for(let z=0;z<C.length;z++){const I=C[z].shape,L=[];shapeBuilders[I.type].build(I,L),A.push(L)}return A}class GpuGraphicsContext{constructor(){this.batcher=new Batcher,this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class GraphicsContextRenderData{constructor(){this.geometry=new BatchGeometry,this.instructions=new InstructionSet}init(){this.instructions.reset()}}const _GraphicsContextSystem=class Dr{constructor(){this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null)}init(C){var A;Dr.defaultOptions.bezierSmoothness=(A=C==null?void 0:C.bezierSmoothness)!=null?A:Dr.defaultOptions.bezierSmoothness}getContextRenderData(C){return this._graphicsDataContextHash[C.uid]||this._initContextRenderData(C)}updateGpuContext(C){let A=this._gpuContextHash[C.uid]||this._initContext(C);if(C.dirty){A?this._cleanGraphicsContextData(C):A=this._initContext(C),buildContextBatches(C,A);const z=C.batchMode;C.customShader||z==="no-batch"?A.isBatchable=!1:z==="auto"&&(A.isBatchable=A.geometryData.vertices.length<400),C.dirty=!1}return A}getGpuContext(C){return this._gpuContextHash[C.uid]||this._initContext(C)}_initContextRenderData(C){const A=BigPool.get(GraphicsContextRenderData),{batches:z,geometryData:I,batcher:L}=this._gpuContextHash[C.uid],K=I.vertices.length,te=I.indices.length;for(let oe=0;oe<z.length;oe++)z[oe].applyTransform=!1;L.ensureAttributeBuffer(K),L.ensureIndexBuffer(te),L.begin();for(let oe=0;oe<z.length;oe++){const ue=z[oe];L.add(ue)}L.finish(A.instructions);const ne=A.geometry;ne.indexBuffer.setDataWithSize(L.indexBuffer,L.indexSize,!0),ne.buffers[0].setDataWithSize(L.attributeBuffer.float32View,L.attributeSize,!0);const ie=L.batches;for(let oe=0;oe<ie.length;oe++){const ue=ie[oe];ue.bindGroup=getTextureBatchBindGroup(ue.textures.textures,ue.textures.count)}return this._graphicsDataContextHash[C.uid]=A,A}_initContext(C){const A=new GpuGraphicsContext;return A.context=C,this._gpuContextHash[C.uid]=A,C.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[C.uid]}onGraphicsContextDestroy(C){this._cleanGraphicsContextData(C),C.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[C.uid]=null}_cleanGraphicsContextData(C){const A=this._gpuContextHash[C.uid];A.isBatchable||this._graphicsDataContextHash[C.uid]&&(BigPool.return(this.getContextRenderData(C)),this._graphicsDataContextHash[C.uid]=null),A.batches&&A.batches.forEach(z=>{BigPool.return(z)})}destroy(){for(const C in this._gpuContextHash)this._gpuContextHash[C]&&this.onGraphicsContextDestroy(this._gpuContextHash[C].context)}};_GraphicsContextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"graphicsContext"},_GraphicsContextSystem.defaultOptions={bezierSmoothness:.5};let GraphicsContextSystem=_GraphicsContextSystem;const RECURSION_LIMIT$1=8,FLT_EPSILON$1=11920929e-14,PATH_DISTANCE_EPSILON$1=1;function buildAdaptiveBezier(O,C,A,z,I,L,K,te,ne,ie){const ue=Math.min(.99,Math.max(0,ie!=null?ie:GraphicsContextSystem.defaultOptions.bezierSmoothness));let de=(PATH_DISTANCE_EPSILON$1-ue)/1;return de*=de,begin$1(C,A,z,I,L,K,te,ne,O,de),O}function begin$1(O,C,A,z,I,L,K,te,ne,ie){recursive$1(O,C,A,z,I,L,K,te,ne,ie,0),ne.push(K,te)}function recursive$1(O,C,A,z,I,L,K,te,ne,ie,oe){if(oe>RECURSION_LIMIT$1)return;const ue=(O+A)/2,de=(C+z)/2,he=(A+I)/2,fe=(z+L)/2,be=(I+K)/2,xe=(L+te)/2,Se=(ue+he)/2,Fe=(de+fe)/2,Ce=(he+be)/2,Ge=(fe+xe)/2,Ve=(Se+Ce)/2,pt=(Fe+Ge)/2;if(oe>0){let Ze=K-O,ct=te-C;const Xe=Math.abs((A-K)*ct-(z-te)*Ze),We=Math.abs((I-K)*ct-(L-te)*Ze);if(Xe>FLT_EPSILON$1&&We>FLT_EPSILON$1){if((Xe+We)*(Xe+We)<=ie*(Ze*Ze+ct*ct)){ne.push(Ve,pt);return}}else if(Xe>FLT_EPSILON$1){if(Xe*Xe<=ie*(Ze*Ze+ct*ct)){ne.push(Ve,pt);return}}else if(We>FLT_EPSILON$1){if(We*We<=ie*(Ze*Ze+ct*ct)){ne.push(Ve,pt);return}}else if(Ze=Ve-(O+K)/2,ct=pt-(C+te)/2,Ze*Ze+ct*ct<=ie){ne.push(Ve,pt);return}}recursive$1(O,C,ue,de,Se,Fe,Ve,pt,ne,ie,oe+1),recursive$1(Ve,pt,Ce,Ge,be,xe,K,te,ne,ie,oe+1)}const RECURSION_LIMIT=8,FLT_EPSILON=11920929e-14,PATH_DISTANCE_EPSILON=1;function buildAdaptiveQuadratic(O,C,A,z,I,L,K,te){const ie=Math.min(.99,Math.max(0,te!=null?te:GraphicsContextSystem.defaultOptions.bezierSmoothness));let oe=(PATH_DISTANCE_EPSILON-ie)/1;return oe*=oe,begin(C,A,z,I,L,K,O,oe),O}function begin(O,C,A,z,I,L,K,te){recursive(K,O,C,A,z,I,L,te,0),K.push(I,L)}function recursive(O,C,A,z,I,L,K,te,ne){if(ne>RECURSION_LIMIT)return;const ie=(C+z)/2,oe=(A+I)/2,ue=(z+L)/2,de=(I+K)/2,he=(ie+ue)/2,fe=(oe+de)/2;let be=L-C,xe=K-A;const Se=Math.abs((z-L)*xe-(I-K)*be);if(Se>FLT_EPSILON){if(Se*Se<=te*(be*be+xe*xe)){O.push(he,fe);return}}else if(be=he-(C+L)/2,xe=fe-(A+K)/2,be*be+xe*xe<=te){O.push(he,fe);return}recursive(O,C,A,ie,oe,he,fe,te,ne+1),recursive(O,he,fe,ue,de,L,K,te,ne+1)}function buildArc(O,C,A,z,I,L,K,te){let ne=Math.abs(I-L);(!K&&I>L||K&&L>I)&&(ne=2*Math.PI-ne),te=te||Math.max(6,Math.floor(6*Math.pow(z,1/3)*(ne/Math.PI))),te=Math.max(te,3);let ie=ne/te,oe=I;ie*=K?-1:1;for(let ue=0;ue<te+1;ue++){const de=Math.cos(oe),he=Math.sin(oe),fe=C+de*z,be=A+he*z;O.push(fe,be),oe+=ie}}function buildArcTo(O,C,A,z,I,L){const K=O[O.length-2],ne=O[O.length-1]-A,ie=K-C,oe=I-A,ue=z-C,de=Math.abs(ne*ue-ie*oe);if(de<1e-8||L===0){(O[O.length-2]!==C||O[O.length-1]!==A)&&O.push(C,A);return}const he=ne*ne+ie*ie,fe=oe*oe+ue*ue,be=ne*oe+ie*ue,xe=L*Math.sqrt(he)/de,Se=L*Math.sqrt(fe)/de,Fe=xe*be/he,Ce=Se*be/fe,Ge=xe*ue+Se*ie,Ve=xe*oe+Se*ne,pt=ie*(Se+Fe),Ze=ne*(Se+Fe),ct=ue*(xe+Ce),Xe=oe*(xe+Ce),We=Math.atan2(Ze-Ve,pt-Ge),Mt=Math.atan2(Xe-Ve,ct-Ge);buildArc(O,Ge+C,Ve+A,L,We,Mt,ie*oe>ue*ne)}const TAU=Math.PI*2,out={centerX:0,centerY:0,ang1:0,ang2:0},mapToEllipse=({x:O,y:C},A,z,I,L,K,te,ne)=>{O*=A,C*=z;const ie=I*O-L*C,oe=L*O+I*C;return ne.x=ie+K,ne.y=oe+te,ne};function approxUnitArc(O,C){const A=C===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(C/4),z=C===1.5707963267948966?.551915024494:A,I=Math.cos(O),L=Math.sin(O),K=Math.cos(O+C),te=Math.sin(O+C);return[{x:I-L*z,y:L+I*z},{x:K+te*z,y:te-K*z},{x:K,y:te}]}const vectorAngle=(O,C,A,z)=>{const I=O*z-C*A<0?-1:1;let L=O*A+C*z;return L>1&&(L=1),L<-1&&(L=-1),I*Math.acos(L)},getArcCenter=(O,C,A,z,I,L,K,te,ne,ie,oe,ue,de)=>{const he=Math.pow(I,2),fe=Math.pow(L,2),be=Math.pow(oe,2),xe=Math.pow(ue,2);let Se=he*fe-he*xe-fe*be;Se<0&&(Se=0),Se/=he*xe+fe*be,Se=Math.sqrt(Se)*(K===te?-1:1);const Fe=Se*I/L*ue,Ce=Se*-L/I*oe,Ge=ie*Fe-ne*Ce+(O+A)/2,Ve=ne*Fe+ie*Ce+(C+z)/2,pt=(oe-Fe)/I,Ze=(ue-Ce)/L,ct=(-oe-Fe)/I,Xe=(-ue-Ce)/L,We=vectorAngle(1,0,pt,Ze);let Mt=vectorAngle(pt,Ze,ct,Xe);te===0&&Mt>0&&(Mt-=TAU),te===1&&Mt<0&&(Mt+=TAU),de.centerX=Ge,de.centerY=Ve,de.ang1=We,de.ang2=Mt};function buildArcToSvg(O,C,A,z,I,L,K,te=0,ne=0,ie=0){if(L===0||K===0)return;const oe=Math.sin(te*TAU/360),ue=Math.cos(te*TAU/360),de=ue*(C-z)/2+oe*(A-I)/2,he=-oe*(C-z)/2+ue*(A-I)/2;if(de===0&&he===0)return;L=Math.abs(L),K=Math.abs(K);const fe=Math.pow(de,2)/Math.pow(L,2)+Math.pow(he,2)/Math.pow(K,2);fe>1&&(L*=Math.sqrt(fe),K*=Math.sqrt(fe)),getArcCenter(C,A,z,I,L,K,ne,ie,oe,ue,de,he,out);let{ang1:be,ang2:xe}=out;const{centerX:Se,centerY:Fe}=out;let Ce=Math.abs(xe)/(TAU/4);Math.abs(1-Ce)<1e-7&&(Ce=1);const Ge=Math.max(Math.ceil(Ce),1);xe/=Ge;let Ve=O[O.length-2],pt=O[O.length-1];const Ze={x:0,y:0};for(let ct=0;ct<Ge;ct++){const Xe=approxUnitArc(be,xe),{x:We,y:Mt}=mapToEllipse(Xe[0],L,K,ue,oe,Se,Fe,Ze),{x:jt,y:At}=mapToEllipse(Xe[1],L,K,ue,oe,Se,Fe,Ze),{x:_t,y:It}=mapToEllipse(Xe[2],L,K,ue,oe,Se,Fe,Ze);buildAdaptiveBezier(O,Ve,pt,We,Mt,jt,At,_t,It),Ve=_t,pt=It,be+=xe}}function roundedShapeArc(O,C,A){var K;const z=(te,ne)=>{const ie=ne.x-te.x,oe=ne.y-te.y,ue=Math.sqrt(ie*ie+oe*oe),de=ie/ue,he=oe/ue;return{len:ue,nx:de,ny:he}},I=(te,ne)=>{te===0?O.moveTo(ne.x,ne.y):O.lineTo(ne.x,ne.y)};let L=C[C.length-1];for(let te=0;te<C.length;te++){const ne=C[te%C.length],ie=(K=ne.radius)!=null?K:A;if(ie<=0){I(te,ne),L=ne;continue}const oe=C[(te+1)%C.length],ue=z(ne,L),de=z(ne,oe);if(ue.len<1e-4||de.len<1e-4){I(te,ne),L=ne;continue}let he=Math.asin(ue.nx*de.ny-ue.ny*de.nx),fe=1,be=!1;ue.nx*de.nx-ue.ny*-de.ny<0?he<0?he=Math.PI+he:(he=Math.PI-he,fe=-1,be=!0):he>0&&(fe=-1,be=!0);const xe=he/2;let Se,Fe=Math.abs(Math.cos(xe)*ie/Math.sin(xe));Fe>Math.min(ue.len/2,de.len/2)?(Fe=Math.min(ue.len/2,de.len/2),Se=Math.abs(Fe*Math.sin(xe)/Math.cos(xe))):Se=ie;const Ce=ne.x+de.nx*Fe+-de.ny*Se*fe,Ge=ne.y+de.ny*Fe+de.nx*Se*fe,Ve=Math.atan2(ue.ny,ue.nx)+Math.PI/2*fe,pt=Math.atan2(de.ny,de.nx)-Math.PI/2*fe;te===0&&O.moveTo(Ce+Math.cos(Ve)*Se,Ge+Math.sin(Ve)*Se),O.arc(Ce,Ge,Se,Ve,pt,be),L=ne}}function roundedShapeQuadraticCurve(O,C,A,z){var te;const I=(ne,ie)=>Math.sqrt((ne.x-ie.x)**2+(ne.y-ie.y)**2),L=(ne,ie,oe)=>({x:ne.x+(ie.x-ne.x)*oe,y:ne.y+(ie.y-ne.y)*oe}),K=C.length;for(let ne=0;ne<K;ne++){const ie=C[(ne+1)%K],oe=(te=ie.radius)!=null?te:A;if(oe<=0){ne===0?O.moveTo(ie.x,ie.y):O.lineTo(ie.x,ie.y);continue}const ue=C[ne],de=C[(ne+2)%K],he=I(ue,ie);let fe;if(he<1e-4)fe=ie;else{const Se=Math.min(he/2,oe);fe=L(ie,ue,Se/he)}const be=I(de,ie);let xe;if(be<1e-4)xe=ie;else{const Se=Math.min(be/2,oe);xe=L(ie,de,Se/be)}ne===0?O.moveTo(fe.x,fe.y):O.lineTo(fe.x,fe.y),O.quadraticCurveTo(ie.x,ie.y,xe.x,xe.y,z)}}const tempRectangle=new Rectangle;class ShapePath{constructor(C){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Bounds,this._graphicsPath2D=C}moveTo(C,A){return this.startPoly(C,A),this}lineTo(C,A){this._ensurePoly();const z=this._currentPoly.points,I=z[z.length-2],L=z[z.length-1];return(I!==C||L!==A)&&z.push(C,A),this}arc(C,A,z,I,L,K){this._ensurePoly(!1);const te=this._currentPoly.points;return buildArc(te,C,A,z,I,L,K),this}arcTo(C,A,z,I,L){this._ensurePoly();const K=this._currentPoly.points;return buildArcTo(K,C,A,z,I,L),this}arcToSvg(C,A,z,I,L,K,te){const ne=this._currentPoly.points;return buildArcToSvg(ne,this._currentPoly.lastX,this._currentPoly.lastY,K,te,C,A,z,I,L),this}bezierCurveTo(C,A,z,I,L,K,te){this._ensurePoly();const ne=this._currentPoly;return buildAdaptiveBezier(this._currentPoly.points,ne.lastX,ne.lastY,C,A,z,I,L,K,te),this}quadraticCurveTo(C,A,z,I,L){this._ensurePoly();const K=this._currentPoly;return buildAdaptiveQuadratic(this._currentPoly.points,K.lastX,K.lastY,C,A,z,I,L),this}closePath(){return this.endPoly(!0),this}addPath(C,A){this.endPoly(),A&&!A.isIdentity()&&(C=C.clone(!0),C.transform(A));for(let z=0;z<C.instructions.length;z++){const I=C.instructions[z];this[I.action](...I.data)}return this}finish(C=!1){this.endPoly(C)}rect(C,A,z,I,L){return this.drawShape(new Rectangle(C,A,z,I),L),this}circle(C,A,z,I){return this.drawShape(new Circle(C,A,z),I),this}poly(C,A,z){const I=new Polygon(C);return I.closePath=A,this.drawShape(I,z),this}regularPoly(C,A,z,I,L=0,K){I=Math.max(I|0,3);const te=-1*Math.PI/2+L,ne=Math.PI*2/I,ie=[];for(let oe=0;oe<I;oe++){const ue=oe*ne+te;ie.push(C+z*Math.cos(ue),A+z*Math.sin(ue))}return this.poly(ie,!0,K),this}roundPoly(C,A,z,I,L,K=0,te){if(I=Math.max(I|0,3),L<=0)return this.regularPoly(C,A,z,I,K);const ne=z*Math.sin(Math.PI/I)-.001;L=Math.min(L,ne);const ie=-1*Math.PI/2+K,oe=Math.PI*2/I,ue=(I-2)*Math.PI/I/2;for(let de=0;de<I;de++){const he=de*oe+ie,fe=C+z*Math.cos(he),be=A+z*Math.sin(he),xe=he+Math.PI+ue,Se=he-Math.PI-ue,Fe=fe+L*Math.cos(xe),Ce=be+L*Math.sin(xe),Ge=fe+L*Math.cos(Se),Ve=be+L*Math.sin(Se);de===0?this.moveTo(Fe,Ce):this.lineTo(Fe,Ce),this.quadraticCurveTo(fe,be,Ge,Ve,te)}return this.closePath()}roundShape(C,A,z=!1,I){return C.length<3?this:(z?roundedShapeQuadraticCurve(this,C,A,I):roundedShapeArc(this,C,A),this.closePath())}filletRect(C,A,z,I,L){if(L===0)return this.rect(C,A,z,I);const K=Math.min(z,I)/2,te=Math.min(K,Math.max(-K,L)),ne=C+z,ie=A+I,oe=te<0?-te:0,ue=Math.abs(te);return this.moveTo(C,A+ue).arcTo(C+oe,A+oe,C+ue,A,ue).lineTo(ne-ue,A).arcTo(ne-oe,A+oe,ne,A+ue,ue).lineTo(ne,ie-ue).arcTo(ne-oe,ie-oe,C+z-ue,ie,ue).lineTo(C+ue,ie).arcTo(C+oe,ie-oe,C,ie-ue,ue).closePath()}chamferRect(C,A,z,I,L,K){if(L<=0)return this.rect(C,A,z,I);const te=Math.min(L,Math.min(z,I)/2),ne=C+z,ie=A+I,oe=[C+te,A,ne-te,A,ne,A+te,ne,ie-te,ne-te,ie,C+te,ie,C,ie-te,C,A+te];for(let ue=oe.length-1;ue>=2;ue-=2)oe[ue]===oe[ue-2]&&oe[ue-1]===oe[ue-3]&&oe.splice(ue-1,2);return this.poly(oe,!0,K)}ellipse(C,A,z,I,L){return this.drawShape(new Ellipse(C,A,z,I),L),this}roundRect(C,A,z,I,L,K){return this.drawShape(new RoundedRectangle(C,A,z,I,L),K),this}drawShape(C,A){return this.endPoly(),this.shapePrimitives.push({shape:C,transform:A}),this}startPoly(C,A){let z=this._currentPoly;return z&&this.endPoly(),z=new Polygon,z.points.push(C,A),this._currentPoly=z,this}endPoly(C=!1){const A=this._currentPoly;return A&&A.points.length>2&&(A.closePath=C,this.shapePrimitives.push({shape:A})),this._currentPoly=null,this}_ensurePoly(C=!0){if(!this._currentPoly&&(this._currentPoly=new Polygon,C)){const A=this.shapePrimitives[this.shapePrimitives.length-1];if(A){let z=A.shape.x,I=A.shape.y;if(A.transform&&!A.transform.isIdentity()){const L=A.transform,K=z;z=L.a*z+L.c*I+L.tx,I=L.b*K+L.d*I+L.ty}this._currentPoly.points.push(z,I)}else this._currentPoly.points.push(0,0)}}buildPath(){const C=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let A=0;A<C.instructions.length;A++){const z=C.instructions[A];this[z.action](...z.data)}this.finish()}get bounds(){const C=this._bounds;C.clear();const A=this.shapePrimitives;for(let z=0;z<A.length;z++){const I=A[z],L=I.shape.getBounds(tempRectangle);I.transform?C.addRect(L,I.transform):C.addRect(L)}return C}}class GraphicsPath{constructor(C){var A;this.instructions=[],this.uid=uid("graphicsPath"),this._dirty=!0,typeof C=="string"?SVGToGraphicsPath(C,this):this.instructions=(A=C==null?void 0:C.slice())!=null?A:[]}get shapePath(){return this._shapePath||(this._shapePath=new ShapePath(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(C,A){return C=C.clone(),this.instructions.push({action:"addPath",data:[C,A]}),this._dirty=!0,this}arc(...C){return this.instructions.push({action:"arc",data:C}),this._dirty=!0,this}arcTo(...C){return this.instructions.push({action:"arcTo",data:C}),this._dirty=!0,this}arcToSvg(...C){return this.instructions.push({action:"arcToSvg",data:C}),this._dirty=!0,this}bezierCurveTo(...C){return this.instructions.push({action:"bezierCurveTo",data:C}),this._dirty=!0,this}bezierCurveToShort(C,A,z,I,L){const K=this.instructions[this.instructions.length-1],te=this.getLastPoint(Point.shared);let ne=0,ie=0;if(!K||K.action!=="bezierCurveTo")ne=te.x,ie=te.y;else{ne=K.data[2],ie=K.data[3];const oe=te.x,ue=te.y;ne=oe+(oe-ne),ie=ue+(ue-ie)}return this.instructions.push({action:"bezierCurveTo",data:[ne,ie,C,A,z,I,L]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...C){return this.instructions.push({action:"ellipse",data:C}),this._dirty=!0,this}lineTo(...C){return this.instructions.push({action:"lineTo",data:C}),this._dirty=!0,this}moveTo(...C){return this.instructions.push({action:"moveTo",data:C}),this}quadraticCurveTo(...C){return this.instructions.push({action:"quadraticCurveTo",data:C}),this._dirty=!0,this}quadraticCurveToShort(C,A,z){const I=this.instructions[this.instructions.length-1],L=this.getLastPoint(Point.shared);let K=0,te=0;if(!I||I.action!=="quadraticCurveTo")K=L.x,te=L.y;else{K=I.data[0],te=I.data[1];const ne=L.x,ie=L.y;K=ne+(ne-K),te=ie+(ie-te)}return this.instructions.push({action:"quadraticCurveTo",data:[K,te,C,A,z]}),this._dirty=!0,this}rect(C,A,z,I,L){return this.instructions.push({action:"rect",data:[C,A,z,I,L]}),this._dirty=!0,this}circle(C,A,z,I){return this.instructions.push({action:"circle",data:[C,A,z,I]}),this._dirty=!0,this}roundRect(...C){return this.instructions.push({action:"roundRect",data:C}),this._dirty=!0,this}poly(...C){return this.instructions.push({action:"poly",data:C}),this._dirty=!0,this}regularPoly(...C){return this.instructions.push({action:"regularPoly",data:C}),this._dirty=!0,this}roundPoly(...C){return this.instructions.push({action:"roundPoly",data:C}),this._dirty=!0,this}roundShape(...C){return this.instructions.push({action:"roundShape",data:C}),this._dirty=!0,this}filletRect(...C){return this.instructions.push({action:"filletRect",data:C}),this._dirty=!0,this}chamferRect(...C){return this.instructions.push({action:"chamferRect",data:C}),this._dirty=!0,this}star(C,A,z,I,L,K,te){L=L||I/2;const ne=-1*Math.PI/2+K,ie=z*2,oe=Math.PI*2/ie,ue=[];for(let de=0;de<ie;de++){const he=de%2?L:I,fe=de*oe+ne;ue.push(C+he*Math.cos(fe),A+he*Math.sin(fe))}return this.poly(ue,!0,te),this}clone(C=!1){const A=new GraphicsPath;if(!C)A.instructions=this.instructions.slice();else for(let z=0;z<this.instructions.length;z++){const I=this.instructions[z];A.instructions.push({action:I.action,data:I.data.slice()})}return A}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(C){if(C.isIdentity())return this;const A=C.a,z=C.b,I=C.c,L=C.d,K=C.tx,te=C.ty;let ne=0,ie=0,oe=0,ue=0,de=0,he=0,fe=0,be=0;for(let xe=0;xe<this.instructions.length;xe++){const Se=this.instructions[xe],Fe=Se.data;switch(Se.action){case"moveTo":case"lineTo":ne=Fe[0],ie=Fe[1],Fe[0]=A*ne+I*ie+K,Fe[1]=z*ne+L*ie+te;break;case"bezierCurveTo":oe=Fe[0],ue=Fe[1],de=Fe[2],he=Fe[3],ne=Fe[4],ie=Fe[5],Fe[0]=A*oe+I*ue+K,Fe[1]=z*oe+L*ue+te,Fe[2]=A*de+I*he+K,Fe[3]=z*de+L*he+te,Fe[4]=A*ne+I*ie+K,Fe[5]=z*ne+L*ie+te;break;case"quadraticCurveTo":oe=Fe[0],ue=Fe[1],ne=Fe[2],ie=Fe[3],Fe[0]=A*oe+I*ue+K,Fe[1]=z*oe+L*ue+te,Fe[2]=A*ne+I*ie+K,Fe[3]=z*ne+L*ie+te;break;case"arcToSvg":ne=Fe[5],ie=Fe[6],fe=Fe[0],be=Fe[1],Fe[0]=A*fe+I*be,Fe[1]=z*fe+L*be,Fe[5]=A*ne+I*ie+K,Fe[6]=z*ne+L*ie+te;break;case"circle":Fe[4]=adjustTransform(Fe[3],C);break;case"rect":Fe[4]=adjustTransform(Fe[4],C);break;case"ellipse":Fe[8]=adjustTransform(Fe[8],C);break;case"roundRect":Fe[5]=adjustTransform(Fe[5],C);break;case"addPath":Fe[0].transform(C);break;case"poly":Fe[2]=adjustTransform(Fe[2],C);break;default:warn("unknown transform action",Se.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(C){let A=this.instructions.length-1,z=this.instructions[A];if(!z)return C.x=0,C.y=0,C;for(;z.action==="closePath";){if(A--,A<0)return C.x=0,C.y=0,C;z=this.instructions[A]}switch(z.action){case"moveTo":case"lineTo":C.x=z.data[0],C.y=z.data[1];break;case"quadraticCurveTo":C.x=z.data[2],C.y=z.data[3];break;case"bezierCurveTo":C.x=z.data[4],C.y=z.data[5];break;case"arc":case"arcToSvg":C.x=z.data[5],C.y=z.data[6];break;case"addPath":z.data[0].getLastPoint(C);break}return C}}function adjustTransform(O,C){return O?O.prepend(C):C.clone()}function SVGParser(O,C){if(typeof O=="string"){const z=document.createElement("div");z.innerHTML=O.trim(),O=z.querySelector("svg")}const A={context:C,path:new GraphicsPath};return renderChildren(O,A,null,null),C}function renderChildren(O,C,A,z){const I=O.children,{fillStyle:L,strokeStyle:K}=parseStyle(O);L&&A?A={...A,...L}:L&&(A=L),K&&z?z={...z,...K}:K&&(z=K),C.context.fillStyle=A,C.context.strokeStyle=z;let te,ne,ie,oe,ue,de,he,fe,be,xe,Se,Fe,Ce,Ge,Ve,pt,Ze;switch(O.nodeName.toLowerCase()){case"path":Ge=O.getAttribute("d"),Ve=new GraphicsPath(Ge),C.context.path(Ve),A&&C.context.fill(),z&&C.context.stroke();break;case"circle":he=parseFloatAttribute(O,"cx",0),fe=parseFloatAttribute(O,"cy",0),be=parseFloatAttribute(O,"r",0),C.context.ellipse(he,fe,be,be),A&&C.context.fill(),z&&C.context.stroke();break;case"rect":te=parseFloatAttribute(O,"x",0),ne=parseFloatAttribute(O,"y",0),pt=parseFloatAttribute(O,"width",0),Ze=parseFloatAttribute(O,"height",0),xe=parseFloatAttribute(O,"rx",0),Se=parseFloatAttribute(O,"ry",0),xe||Se?C.context.roundRect(te,ne,pt,Ze,xe||Se):C.context.rect(te,ne,pt,Ze),A&&C.context.fill(),z&&C.context.stroke();break;case"ellipse":he=parseFloatAttribute(O,"cx",0),fe=parseFloatAttribute(O,"cy",0),xe=parseFloatAttribute(O,"rx",0),Se=parseFloatAttribute(O,"ry",0),C.context.beginPath(),C.context.ellipse(he,fe,xe,Se),A&&C.context.fill(),z&&C.context.stroke();break;case"line":ie=parseFloatAttribute(O,"x1",0),oe=parseFloatAttribute(O,"y1",0),ue=parseFloatAttribute(O,"x2",0),de=parseFloatAttribute(O,"y2",0),C.context.beginPath(),C.context.moveTo(ie,oe),C.context.lineTo(ue,de),z&&C.context.stroke();break;case"polygon":Ce=O.getAttribute("points"),Fe=Ce.match(/\d+/g).map(ct=>parseInt(ct,10)),C.context.poly(Fe,!0),A&&C.context.fill(),z&&C.context.stroke();break;case"polyline":Ce=O.getAttribute("points"),Fe=Ce.match(/\d+/g).map(ct=>parseInt(ct,10)),C.context.poly(Fe,!1),z&&C.context.stroke();break;case"g":case"svg":break;default:{console.info(`[SVG parser] <${O.nodeName}> elements unsupported`);break}}for(let ct=0;ct<I.length;ct++)renderChildren(I[ct],C,A,z)}function parseFloatAttribute(O,C,A){const z=O.getAttribute(C);return z?Number(z):A}function parseStyle(O){const C=O.getAttribute("style"),A={},z={};let I=!1,L=!1;if(C){const K=C.split(";");for(let te=0;te<K.length;te++){const ne=K[te],[ie,oe]=ne.split(":");switch(ie){case"stroke":oe!=="none"&&(A.color=Color.shared.setValue(oe).toNumber(),L=!0);break;case"stroke-width":A.width=Number(oe);break;case"fill":oe!=="none"&&(I=!0,z.color=Color.shared.setValue(oe).toNumber());break;case"fill-opacity":z.alpha=Number(oe);break;case"stroke-opacity":A.alpha=Number(oe);break;case"opacity":z.alpha=Number(oe),A.alpha=Number(oe);break}}}else{const K=O.getAttribute("stroke");K&&K!=="none"&&(L=!0,A.color=Color.shared.setValue(K).toNumber(),A.width=parseFloatAttribute(O,"stroke-width",1));const te=O.getAttribute("fill");te&&te!=="none"&&(I=!0,z.color=Color.shared.setValue(te).toNumber())}return{strokeStyle:L?A:null,fillStyle:I?z:null}}function isColorLike(O){return Color.isColorLike(O)}function isFillPattern(O){return O instanceof FillPattern}function isFillGradient(O){return O instanceof FillGradient}function handleColorLike(O,C,A){const z=Color.shared.setValue(C!=null?C:0);return O.color=z.toNumber(),O.alpha=z.alpha===1?A.alpha:z.alpha,O.texture=Texture.WHITE,{...A,...O}}function handleFillPattern(O,C,A){return O.fill=C,O.color=16777215,O.texture=C.texture,O.matrix=C.transform,{...A,...O}}function handleFillGradient(O,C,A){return C.buildLinearGradient(),O.fill=C,O.color=16777215,O.texture=C.texture,O.matrix=C.transform,{...A,...O}}function handleFillObject(O,C){var I;const A={...C,...O};if(A.texture){if(A.texture!==Texture.WHITE){const K=((I=A.matrix)==null?void 0:I.invert())||new Matrix;K.translate(A.texture.frame.x,A.texture.frame.y),K.scale(1/A.texture.source.width,1/A.texture.source.height),A.matrix=K}const L=A.texture.source.style;L.addressMode==="clamp-to-edge"&&(L.addressMode="repeat",L.update())}const z=Color.shared.setValue(A.color);return A.alpha*=z.alpha,A.color=z.toNumber(),A.matrix=A.matrix?A.matrix.clone():null,A}function toFillStyle(O,C){if(O==null)return null;const A={},z=O;return isColorLike(O)?handleColorLike(A,O,C):isFillPattern(O)?handleFillPattern(A,O,C):isFillGradient(O)?handleFillGradient(A,O,C):z.fill&&isFillPattern(z.fill)?handleFillPattern(z,z.fill,C):z.fill&&isFillGradient(z.fill)?handleFillGradient(z,z.fill,C):handleFillObject(z,C)}function toStrokeStyle(O,C){const{width:A,alignment:z,miterLimit:I,cap:L,join:K,...te}=C,ne=toFillStyle(O,te);return ne?{width:A,alignment:z,miterLimit:I,cap:L,join:K,...ne}:null}const tmpPoint=new Point,tempMatrix$1=new Matrix,_GraphicsContext=class sr extends EventEmitter{constructor(){super(...arguments),this.uid=uid("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new GraphicsPath,this._transform=new Matrix,this._fillStyle={...sr.defaultFillStyle},this._strokeStyle={...sr.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Bounds,this._boundsDirty=!0}clone(){const C=new sr;return C.batchMode=this.batchMode,C.instructions=this.instructions.slice(),C._activePath=this._activePath.clone(),C._transform=this._transform.clone(),C._fillStyle={...this._fillStyle},C._strokeStyle={...this._strokeStyle},C._stateStack=this._stateStack.slice(),C._bounds=this._bounds.clone(),C._boundsDirty=!0,C}get fillStyle(){return this._fillStyle}set fillStyle(C){this._fillStyle=toFillStyle(C,sr.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(C){this._strokeStyle=toStrokeStyle(C,sr.defaultStrokeStyle)}setFillStyle(C){return this._fillStyle=toFillStyle(C,sr.defaultFillStyle),this}setStrokeStyle(C){return this._strokeStyle=toFillStyle(C,sr.defaultStrokeStyle),this}texture(C,A,z,I,L,K){return this.instructions.push({action:"texture",data:{image:C,dx:z||0,dy:I||0,dw:L||C.frame.width,dh:K||C.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:A?Color.shared.setValue(A).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new GraphicsPath,this}fill(C,A){let z;const I=this.instructions[this.instructions.length-1];return this._tick===0&&I&&I.action==="stroke"?z=I.data.path:z=this._activePath.clone(),z?(C!=null&&(A!==void 0&&typeof C=="number"&&(deprecation(v8_0_0,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),C={color:C,alpha:A}),this._fillStyle=toFillStyle(C,sr.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:z}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:C,y:A}=this._activePath.getLastPoint(Point.shared);this._activePath.clear(),this._activePath.moveTo(C,A)}stroke(C){let A;const z=this.instructions[this.instructions.length-1];return this._tick===0&&z&&z.action==="fill"?A=z.data.path:A=this._activePath.clone(),A?(C!=null&&(this._strokeStyle=toStrokeStyle(C,sr.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:A}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let C=0;C<2;C++){const A=this.instructions[this.instructions.length-1-C],z=this._activePath.clone();if(A&&(A.action==="stroke"||A.action==="fill"))if(A.data.hole)A.data.hole.addPath(z);else{A.data.hole=z;break}}return this._initNextPathLocation(),this}arc(C,A,z,I,L,K){this._tick++;const te=this._transform;return this._activePath.arc(te.a*C+te.c*A+te.tx,te.b*C+te.d*A+te.ty,z,I,L,K),this}arcTo(C,A,z,I,L){this._tick++;const K=this._transform;return this._activePath.arcTo(K.a*C+K.c*A+K.tx,K.b*C+K.d*A+K.ty,K.a*z+K.c*I+K.tx,K.b*z+K.d*I+K.ty,L),this}arcToSvg(C,A,z,I,L,K,te){this._tick++;const ne=this._transform;return this._activePath.arcToSvg(C,A,z,I,L,ne.a*K+ne.c*te+ne.tx,ne.b*K+ne.d*te+ne.ty),this}bezierCurveTo(C,A,z,I,L,K,te){this._tick++;const ne=this._transform;return this._activePath.bezierCurveTo(ne.a*C+ne.c*A+ne.tx,ne.b*C+ne.d*A+ne.ty,ne.a*z+ne.c*I+ne.tx,ne.b*z+ne.d*I+ne.ty,ne.a*L+ne.c*K+ne.tx,ne.b*L+ne.d*K+ne.ty,te),this}closePath(){var C;return this._tick++,(C=this._activePath)==null||C.closePath(),this}ellipse(C,A,z,I){return this._tick++,this._activePath.ellipse(C,A,z,I,this._transform.clone()),this}circle(C,A,z){return this._tick++,this._activePath.circle(C,A,z,this._transform.clone()),this}path(C){return this._tick++,this._activePath.addPath(C,this._transform.clone()),this}lineTo(C,A){this._tick++;const z=this._transform;return this._activePath.lineTo(z.a*C+z.c*A+z.tx,z.b*C+z.d*A+z.ty),this}moveTo(C,A){this._tick++;const z=this._transform,I=this._activePath.instructions,L=z.a*C+z.c*A+z.tx,K=z.b*C+z.d*A+z.ty;return I.length===1&&I[0].action==="moveTo"?(I[0].data[0]=L,I[0].data[1]=K,this):(this._activePath.moveTo(L,K),this)}quadraticCurveTo(C,A,z,I,L){this._tick++;const K=this._transform;return this._activePath.quadraticCurveTo(K.a*C+K.c*A+K.tx,K.b*C+K.d*A+K.ty,K.a*z+K.c*I+K.tx,K.b*z+K.d*I+K.ty,L),this}rect(C,A,z,I){return this._tick++,this._activePath.rect(C,A,z,I,this._transform.clone()),this}roundRect(C,A,z,I,L){return this._tick++,this._activePath.roundRect(C,A,z,I,L,this._transform.clone()),this}poly(C,A){return this._tick++,this._activePath.poly(C,A,this._transform.clone()),this}regularPoly(C,A,z,I,L=0,K){return this._tick++,this._activePath.regularPoly(C,A,z,I,L,K),this}roundPoly(C,A,z,I,L,K){return this._tick++,this._activePath.roundPoly(C,A,z,I,L,K),this}roundShape(C,A,z,I){return this._tick++,this._activePath.roundShape(C,A,z,I),this}filletRect(C,A,z,I,L){return this._tick++,this._activePath.filletRect(C,A,z,I,L),this}chamferRect(C,A,z,I,L,K){return this._tick++,this._activePath.chamferRect(C,A,z,I,L,K),this}star(C,A,z,I,L=0,K=0){return this._tick++,this._activePath.star(C,A,z,I,L,K,this._transform.clone()),this}svg(C){return this._tick++,SVGParser(C,this),this}restore(){const C=this._stateStack.pop();return C&&(this._transform=C.transform,this._fillStyle=C.fillStyle,this._strokeStyle=C.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(C){return this._transform.rotate(C),this}scale(C,A=C){return this._transform.scale(C,A),this}setTransform(C,A,z,I,L,K){return C instanceof Matrix?(this._transform.set(C.a,C.b,C.c,C.d,C.tx,C.ty),this):(this._transform.set(C,A,z,I,L,K),this)}transform(C,A,z,I,L,K){return C instanceof Matrix?(this._transform.append(C),this):(tempMatrix$1.set(C,A,z,I,L,K),this._transform.append(tempMatrix$1),this)}translate(C,A=C){return this._transform.translate(C,A),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const C=this._bounds;C.clear();for(let A=0;A<this.instructions.length;A++){const z=this.instructions[A],I=z.action;if(I==="fill"){const L=z.data;C.addBounds(L.path.bounds)}else if(I==="texture"){const L=z.data;C.addFrame(L.dx,L.dy,L.dx+L.dw,L.dy+L.dh,L.transform)}if(I==="stroke"){const L=z.data,K=L.style.width/2,te=L.path.bounds;C.addFrame(te.minX-K,te.minY-K,te.maxX+K,te.maxY+K)}}return C}containsPoint(C){var I;if(!this.bounds.containsPoint(C.x,C.y))return!1;const A=this.instructions;let z=!1;for(let L=0;L<A.length;L++){const K=A[L],te=K.data,ne=te.path;if(!K.action||!ne)continue;const ie=te.style,oe=ne.shapePath.shapePrimitives;for(let ue=0;ue<oe.length;ue++){const de=oe[ue].shape;if(!ie||!de)continue;const he=oe[ue].transform,fe=he?he.applyInverse(C,tmpPoint):C;K.action==="fill"?z=de.contains(fe.x,fe.y):z=de.strokeContains(fe.x,fe.y,ie.width);const be=te.hole;if(be){const xe=(I=be.shapePath)==null?void 0:I.shapePrimitives;if(xe)for(let Se=0;Se<xe.length;Se++)xe[Se].shape.contains(fe.x,fe.y)&&(z=!1)}if(z)return!0}}return z}destroy(C=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof C=="boolean"?C:C==null?void 0:C.texture){const z=typeof C=="boolean"?C:C==null?void 0:C.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(z),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(z)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};_GraphicsContext.defaultFillStyle={color:16777215,alpha:1,texture:Texture.WHITE,matrix:null,fill:null},_GraphicsContext.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:Texture.WHITE,matrix:null,fill:null};let GraphicsContext=_GraphicsContext;const valuesToIterateForKeys=["align","breakWords","cssOverrides","fontVariant","fontWeight","leading","letterSpacing","lineHeight","padding","textBaseline","trim","whiteSpace","wordWrap","wordWrapWidth","fontFamily","fontStyle","fontSize"];function generateTextStyleKey(O){const C=[];let A=0;for(let z=0;z<valuesToIterateForKeys.length;z++){const I=`_${valuesToIterateForKeys[z]}`;C[A++]=O[I]}return A=addFillStyleKey(O._fill,C,A),A=addStokeStyleKey(O._stroke,C,A),A=addDropShadowKey(O.dropShadow,C,A),C.join("-")}function addFillStyleKey(O,C,A){var z;return O&&(C[A++]=O.color,C[A++]=O.alpha,C[A++]=(z=O.fill)==null?void 0:z.styleKey),A}function addStokeStyleKey(O,C,A){return O&&(A=addFillStyleKey(O,C,A),C[A++]=O.width,C[A++]=O.alignment,C[A++]=O.cap,C[A++]=O.join,C[A++]=O.miterLimit),A}function addDropShadowKey(O,C,A){return O&&(C[A++]=O.alpha,C[A++]=O.angle,C[A++]=O.blur,C[A++]=O.distance,C[A++]=Color.shared.setValue(O.color).toNumber()),A}const _TextStyle=class Tr extends EventEmitter{constructor(C={}){super(),convertV7Tov8Style(C);const A={...Tr.defaultTextStyle,...C};for(const z in A){const I=z;this[I]=A[z]}this.update()}get align(){return this._align}set align(C){this._align=C,this.update()}get breakWords(){return this._breakWords}set breakWords(C){this._breakWords=C,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(C){C!==null&&typeof C=="object"?this._dropShadow=this._createProxy({...Tr.defaultDropShadow,...C}):this._dropShadow=C?this._createProxy({...Tr.defaultDropShadow}):null,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(C){this._fontFamily=C,this.update()}get fontSize(){return this._fontSize}set fontSize(C){typeof C=="string"?this._fontSize=parseInt(C,10):this._fontSize=C,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(C){this._fontStyle=C,this.update()}get fontVariant(){return this._fontVariant}set fontVariant(C){this._fontVariant=C,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(C){this._fontWeight=C,this.update()}get leading(){return this._leading}set leading(C){this._leading=C,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(C){this._letterSpacing=C,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(C){this._lineHeight=C,this.update()}get padding(){return this._padding}set padding(C){this._padding=C,this.update()}get trim(){return this._trim}set trim(C){this._trim=C,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(C){this._textBaseline=C,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(C){this._whiteSpace=C,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(C){this._wordWrap=C,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(C){this._wordWrapWidth=C,this.update()}get fill(){return this._originalFill}set fill(C){C!==this._originalFill&&(this._originalFill=C,this._isFillStyle(C)&&(this._originalFill=this._createProxy({...GraphicsContext.defaultFillStyle,...C},()=>{this._fill=toFillStyle({...this._originalFill},GraphicsContext.defaultFillStyle)})),this._fill=toFillStyle(C===0?"black":C,GraphicsContext.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(C){C!==this._originalStroke&&(this._originalStroke=C,this._isFillStyle(C)&&(this._originalStroke=this._createProxy({...GraphicsContext.defaultStrokeStyle,...C},()=>{this._stroke=toStrokeStyle({...this._originalStroke},GraphicsContext.defaultStrokeStyle)})),this._stroke=toStrokeStyle(C,GraphicsContext.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=generateTextStyleKey(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const C=Tr.defaultTextStyle;for(const A in C)this[A]=C[A]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new Tr({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(C=!1){var z,I,L,K;if(this.removeAllListeners(),typeof C=="boolean"?C:C==null?void 0:C.texture){const te=typeof C=="boolean"?C:C==null?void 0:C.textureSource;(z=this._fill)!=null&&z.texture&&this._fill.texture.destroy(te),(I=this._originalFill)!=null&&I.texture&&this._originalFill.texture.destroy(te),(L=this._stroke)!=null&&L.texture&&this._stroke.texture.destroy(te),(K=this._originalStroke)!=null&&K.texture&&this._originalStroke.texture.destroy(te)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(C,A){return new Proxy(C,{set:(z,I,L)=>(z[I]=L,A==null||A(I,L),this.update(),!0)})}_isFillStyle(C){return(C!=null?C:null)!==null&&!(Color.isColorLike(C)||C instanceof FillGradient||C instanceof FillPattern)}};_TextStyle.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},_TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let TextStyle=_TextStyle;function convertV7Tov8Style(O){var A,z,I,L,K;const C=O;if(typeof C.dropShadow=="boolean"&&C.dropShadow){const te=TextStyle.defaultDropShadow;O.dropShadow={alpha:(A=C.dropShadowAlpha)!=null?A:te.alpha,angle:(z=C.dropShadowAngle)!=null?z:te.angle,blur:(I=C.dropShadowBlur)!=null?I:te.blur,color:(L=C.dropShadowColor)!=null?L:te.color,distance:(K=C.dropShadowDistance)!=null?K:te.distance}}if(C.strokeThickness!==void 0){deprecation(v8_0_0,"strokeThickness is now a part of stroke");const te=C.stroke;let ne={};if(Color.isColorLike(te))ne.color=te;else if(te instanceof FillGradient||te instanceof FillPattern)ne.fill=te;else if(Object.hasOwnProperty.call(te,"color")||Object.hasOwnProperty.call(te,"fill"))ne=te;else throw new Error("Invalid stroke value.");O.stroke={...ne,width:C.strokeThickness}}if(Array.isArray(C.fillGradientStops)){deprecation(v8_0_0,"gradient fill is now a fill pattern: `new FillGradient(...)`");let te;O.fontSize==null?O.fontSize=TextStyle.defaultTextStyle.fontSize:typeof O.fontSize=="string"?te=parseInt(O.fontSize,10):te=O.fontSize;const ne=new FillGradient(0,0,0,te*1.7),ie=C.fillGradientStops.map(oe=>Color.shared.setValue(oe).toNumber());ie.forEach((oe,ue)=>{const de=ue/(ie.length-1);ne.addColorStop(de,oe)}),O.fill={fill:ne}}}class CanvasPoolClass{constructor(C){this._canvasPool=Object.create(null),this.canvasOptions=C||{},this.enableFullScreen=!1}_createCanvasAndContext(C,A){const z=DOMAdapter.get().createCanvas();z.width=C,z.height=A;const I=z.getContext("2d");return{canvas:z,context:I}}getOptimalCanvasAndContext(C,A,z=1){C=Math.ceil(C*z-1e-6),A=Math.ceil(A*z-1e-6),C=nextPow2(C),A=nextPow2(A);const I=(C<<17)+(A<<1);this._canvasPool[I]||(this._canvasPool[I]=[]);let L=this._canvasPool[I].pop();return L||(L=this._createCanvasAndContext(C,A)),L}returnCanvasAndContext(C){const A=C.canvas,{width:z,height:I}=A,L=(z<<17)+(I<<1);this._canvasPool[L].push(C)}clear(){this._canvasPool={}}}const CanvasPool=new CanvasPoolClass,genericFontFamilies=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(O){const C=typeof O.fontSize=="number"?`${O.fontSize}px`:O.fontSize;let A=O.fontFamily;Array.isArray(O.fontFamily)||(A=O.fontFamily.split(","));for(let z=A.length-1;z>=0;z--){let I=A[z].trim();!/([\"\'])[^\'\"]+\1/.test(I)&&!genericFontFamilies.includes(I)&&(I=`"${I}"`),A[z]=I}return`${O.fontStyle} ${O.fontVariant} ${O.fontWeight} ${C} ${A.join(",")}`}const contextSettings={willReadFrequently:!0},_CanvasTextMetrics=class bt{static get experimentalLetterSpacingSupported(){let C=bt._experimentalLetterSpacingSupported;if(C!==void 0){const A=DOMAdapter.get().getCanvasRenderingContext2D().prototype;C=bt._experimentalLetterSpacingSupported="letterSpacing"in A||"textLetterSpacing"in A}return C}constructor(C,A,z,I,L,K,te,ne,ie){this.text=C,this.style=A,this.width=z,this.height=I,this.lines=L,this.lineWidths=K,this.lineHeight=te,this.maxLineWidth=ne,this.fontProperties=ie}static measureText(C=" ",A,z=bt._canvas,I=A.wordWrap){var Fe;const L=`${C}:${A.styleKey}`;if(bt._measurementCache[L])return bt._measurementCache[L];const K=fontStringFromTextStyle(A),te=bt.measureFont(K);te.fontSize===0&&(te.fontSize=A.fontSize,te.ascent=A.fontSize);const ne=bt.__context;ne.font=K;const oe=(I?bt._wordWrap(C,A,z):C).split(/(?:\r\n|\r|\n)/),ue=new Array(oe.length);let de=0;for(let Ce=0;Ce<oe.length;Ce++){const Ge=bt._measureText(oe[Ce],A.letterSpacing,ne);ue[Ce]=Ge,de=Math.max(de,Ge)}const he=((Fe=A._stroke)==null?void 0:Fe.width)||0;let fe=de+he;A.dropShadow&&(fe+=A.dropShadow.distance);const be=A.lineHeight||te.fontSize;let xe=Math.max(be,te.fontSize+he)+(oe.length-1)*(be+A.leading);return A.dropShadow&&(xe+=A.dropShadow.distance),new bt(C,A,fe,xe,oe,ue,be+A.leading,de,te)}static _measureText(C,A,z){let I=!1;bt.experimentalLetterSpacingSupported&&(bt.experimentalLetterSpacing?(z.letterSpacing=`${A}px`,z.textLetterSpacing=`${A}px`,I=!0):(z.letterSpacing="0px",z.textLetterSpacing="0px"));let L=z.measureText(C).width;return L>0&&(I?L-=A:L+=(bt.graphemeSegmenter(C).length-1)*A),L}static _wordWrap(C,A,z=bt._canvas){const I=z.getContext("2d",contextSettings);let L=0,K="",te="";const ne=Object.create(null),{letterSpacing:ie,whiteSpace:oe}=A,ue=bt._collapseSpaces(oe),de=bt._collapseNewlines(oe);let he=!ue;const fe=A.wordWrapWidth+ie,be=bt._tokenize(C);for(let xe=0;xe<be.length;xe++){let Se=be[xe];if(bt._isNewline(Se)){if(!de){te+=bt._addLine(K),he=!ue,K="",L=0;continue}Se=" "}if(ue){const Ce=bt.isBreakingSpace(Se),Ge=bt.isBreakingSpace(K[K.length-1]);if(Ce&&Ge)continue}const Fe=bt._getFromCache(Se,ie,ne,I);if(Fe>fe)if(K!==""&&(te+=bt._addLine(K),K="",L=0),bt.canBreakWords(Se,A.breakWords)){const Ce=bt.wordWrapSplit(Se);for(let Ge=0;Ge<Ce.length;Ge++){let Ve=Ce[Ge],pt=Ve,Ze=1;for(;Ce[Ge+Ze];){const Xe=Ce[Ge+Ze];if(!bt.canBreakChars(pt,Xe,Se,Ge,A.breakWords))Ve+=Xe;else break;pt=Xe,Ze++}Ge+=Ze-1;const ct=bt._getFromCache(Ve,ie,ne,I);ct+L>fe&&(te+=bt._addLine(K),he=!1,K="",L=0),K+=Ve,L+=ct}}else{K.length>0&&(te+=bt._addLine(K),K="",L=0);const Ce=xe===be.length-1;te+=bt._addLine(Se,!Ce),he=!1,K="",L=0}else Fe+L>fe&&(he=!1,te+=bt._addLine(K),K="",L=0),(K.length>0||!bt.isBreakingSpace(Se)||he)&&(K+=Se,L+=Fe)}return te+=bt._addLine(K,!1),te}static _addLine(C,A=!0){return C=bt._trimRight(C),C=A?`${C}
`:C,C}static _getFromCache(C,A,z,I){let L=z[C];return typeof L!="number"&&(L=bt._measureText(C,A,I)+A,z[C]=L),L}static _collapseSpaces(C){return C==="normal"||C==="pre-line"}static _collapseNewlines(C){return C==="normal"}static _trimRight(C){if(typeof C!="string")return"";for(let A=C.length-1;A>=0;A--){const z=C[A];if(!bt.isBreakingSpace(z))break;C=C.slice(0,-1)}return C}static _isNewline(C){return typeof C!="string"?!1:bt._newlines.includes(C.charCodeAt(0))}static isBreakingSpace(C,A){return typeof C!="string"?!1:bt._breakingSpaces.includes(C.charCodeAt(0))}static _tokenize(C){const A=[];let z="";if(typeof C!="string")return A;for(let I=0;I<C.length;I++){const L=C[I],K=C[I+1];if(bt.isBreakingSpace(L,K)||bt._isNewline(L)){z!==""&&(A.push(z),z=""),A.push(L);continue}z+=L}return z!==""&&A.push(z),A}static canBreakWords(C,A){return A}static canBreakChars(C,A,z,I,L){return!0}static wordWrapSplit(C){return bt.graphemeSegmenter(C)}static measureFont(C){if(bt._fonts[C])return bt._fonts[C];const A=bt._context;A.font=C;const z=A.measureText(bt.METRICS_STRING+bt.BASELINE_SYMBOL),I={ascent:z.actualBoundingBoxAscent,descent:z.actualBoundingBoxDescent,fontSize:z.actualBoundingBoxAscent+z.actualBoundingBoxDescent};return bt._fonts[C]=I,I}static clearMetrics(C=""){C?delete bt._fonts[C]:bt._fonts={}}static get _canvas(){if(!bt.__canvas){let C;try{const A=new OffscreenCanvas(0,0),z=A.getContext("2d",contextSettings);if(z!=null&&z.measureText)return bt.__canvas=A,A;C=DOMAdapter.get().createCanvas()}catch{C=DOMAdapter.get().createCanvas()}C.width=C.height=10,bt.__canvas=C}return bt.__canvas}static get _context(){return bt.__context||(bt.__context=bt._canvas.getContext("2d",contextSettings)),bt.__context}};_CanvasTextMetrics.METRICS_STRING="|\xC9q\xC5",_CanvasTextMetrics.BASELINE_SYMBOL="M",_CanvasTextMetrics.BASELINE_MULTIPLIER=1.4,_CanvasTextMetrics.HEIGHT_MULTIPLIER=2,_CanvasTextMetrics.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const O=new Intl.Segmenter;return C=>[...O.segment(C)].map(A=>A.segment)}return O=>[...O]})(),_CanvasTextMetrics.experimentalLetterSpacing=!1,_CanvasTextMetrics._fonts={},_CanvasTextMetrics._newlines=[10,13],_CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],_CanvasTextMetrics._measurementCache={};let CanvasTextMetrics=_CanvasTextMetrics;function getCanvasFillStyle(O,C){var A;if(O.texture===Texture.WHITE&&!O.fill)return Color.shared.setValue(O.color).setAlpha((A=O.alpha)!=null?A:1).toHexa();if(O.fill){if(O.fill instanceof FillPattern){const z=O.fill,I=C.createPattern(z.texture.source.resource,"repeat"),L=z.transform.copyTo(Matrix.shared);return L.scale(z.texture.frame.width,z.texture.frame.height),I.setTransform(L),I}else if(O.fill instanceof FillGradient){const z=O.fill;if(z.type==="linear"){const I=C.createLinearGradient(z.x0,z.y0,z.x1,z.y1);return z.gradientStops.forEach(L=>{I.addColorStop(L.offset,Color.shared.setValue(L.color).toHex())}),I}}}else{const z=C.createPattern(O.texture.source.resource,"repeat"),I=O.matrix.copyTo(Matrix.shared);return I.scale(O.texture.frame.width,O.texture.frame.height),z.setTransform(I),z}return warn("FillStyle not recognised",O),"red"}function resolveCharacters(O){if(O==="")return[];typeof O=="string"&&(O=[O]);const C=[];for(let A=0,z=O.length;A<z;A++){const I=O[A];if(Array.isArray(I)){if(I.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${I.length}.`);if(I[0].length===0||I[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const L=I[0].charCodeAt(0),K=I[1].charCodeAt(0);if(K<L)throw new Error("[BitmapFont]: Invalid character range.");for(let te=L,ne=K;te<=ne;te++)C.push(String.fromCharCode(te))}else C.push(...Array.from(I))}if(C.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return C}const _DynamicBitmapFont=class Kr extends AbstractBitmapFont{constructor(C){var K,te,ne;super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const A={...Kr.defaultOptions,...C};this._textureSize=A.textureSize,this._mipmap=A.mipmap;const z=A.style.clone();A.overrideFill&&(z._fill.color=16777215,z._fill.alpha=1,z._fill.texture=Texture.WHITE,z._fill.fill=null),this.applyFillAsTint=A.overrideFill;const I=z.fontSize;z.fontSize=this.baseMeasurementFontSize;const L=fontStringFromTextStyle(z);A.overrideSize?z._stroke&&(z._stroke.width*=this.baseRenderedFontSize/I):z.fontSize=this.baseRenderedFontSize=I,this._style=z,this._skipKerning=(K=A.skipKerning)!=null?K:!1,this.resolution=(te=A.resolution)!=null?te:1,this._padding=(ne=A.padding)!=null?ne:4,this.fontMetrics=CanvasTextMetrics.measureFont(L),this.lineHeight=z.lineHeight||this.fontMetrics.fontSize||z.fontSize}ensureCharacters(C){var be,xe,Se,Fe;const A=resolveCharacters(C).filter(Ce=>!this._currentChars.includes(Ce)).filter((Ce,Ge,Ve)=>Ve.indexOf(Ce)===Ge);if(!A.length)return;this._currentChars=[...this._currentChars,...A];let z;this._currentPageIndex===-1?z=this._nextPage():z=this.pages[this._currentPageIndex];let{canvas:I,context:L}=z.canvasAndContext,K=z.texture.source;const te=this._style;let ne=this._currentX,ie=this._currentY;const oe=this.baseRenderedFontSize/this.baseMeasurementFontSize,ue=this._padding*oe,de=te.fontStyle==="italic"?2:1;let he=0,fe=!1;for(let Ce=0;Ce<A.length;Ce++){const Ge=A[Ce],Ve=CanvasTextMetrics.measureText(Ge,te,I,!1);Ve.lineHeight=Ve.height;const pt=de*Ve.width*oe,Ze=Ve.height*oe,ct=pt+ue*2,Xe=Ze+ue*2;if(fe=!1,Ge!==`
`&&Ge!=="\r"&&Ge!=="	"&&Ge!==" "&&(fe=!0,he=Math.ceil(Math.max(Xe,he))),ne+ct>this._textureSize&&(ie+=he,he=Xe,ne=0,ie+he>this._textureSize)){K.update();const Mt=this._nextPage();I=Mt.canvasAndContext.canvas,L=Mt.canvasAndContext.context,K=Mt.texture.source,ie=0}const We=pt/oe-((xe=(be=te.dropShadow)==null?void 0:be.distance)!=null?xe:0)-((Fe=(Se=te._stroke)==null?void 0:Se.width)!=null?Fe:0);if(this.chars[Ge]={id:Ge.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:We,kerning:{}},fe){this._drawGlyph(L,Ve,ne+ue,ie+ue,oe,te);const Mt=K.width*oe,jt=K.height*oe,At=new Rectangle(ne/Mt*K.width,ie/jt*K.height,ct/Mt*K.width,Xe/jt*K.height);this.chars[Ge].texture=new Texture({source:K,frame:At}),ne+=Math.ceil(ct)}}K.update(),this._currentX=ne,this._currentY=ie,this._skipKerning&&this._applyKerning(A,L)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(C,A){const z=this._measureCache;for(let I=0;I<C.length;I++){const L=C[I];for(let K=0;K<this._currentChars.length;K++){const te=this._currentChars[K];let ne=z[L];ne||(ne=z[L]=A.measureText(L).width);let ie=z[te];ie||(ie=z[te]=A.measureText(te).width);let oe=A.measureText(L+te).width,ue=oe-(ne+ie);ue&&(this.chars[L].kerning[te]=ue),oe=A.measureText(L+te).width,ue=oe-(ne+ie),ue&&(this.chars[te].kerning[L]=ue)}}}_nextPage(){this._currentPageIndex++;const C=this.resolution,A=CanvasPool.getOptimalCanvasAndContext(this._textureSize,this._textureSize,C);this._setupContext(A.context,this._style,C);const z=C*(this.baseRenderedFontSize/this.baseMeasurementFontSize),I=new Texture({source:new ImageSource({resource:A.canvas,resolution:z,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})}),L={canvasAndContext:A,texture:I};return this.pages[this._currentPageIndex]=L,L}_setupContext(C,A,z){var K;A.fontSize=this.baseRenderedFontSize,C.scale(z,z),C.font=fontStringFromTextStyle(A),A.fontSize=this.baseMeasurementFontSize,C.textBaseline=A.textBaseline;const I=A._stroke,L=(K=I==null?void 0:I.width)!=null?K:0;if(I&&(C.lineWidth=L,C.lineJoin=I.join,C.miterLimit=I.miterLimit,C.strokeStyle=getCanvasFillStyle(I,C)),A._fill&&(C.fillStyle=getCanvasFillStyle(A._fill,C)),A.dropShadow){const te=A.dropShadow,ne=Color.shared.setValue(te.color).toArray(),ie=te.blur*z,oe=te.distance*z;C.shadowColor=`rgba(${ne[0]*255},${ne[1]*255},${ne[2]*255},${te.alpha})`,C.shadowBlur=ie,C.shadowOffsetX=Math.cos(te.angle)*oe,C.shadowOffsetY=Math.sin(te.angle)*oe}else C.shadowColor="black",C.shadowBlur=0,C.shadowOffsetX=0,C.shadowOffsetY=0}_drawGlyph(C,A,z,I,L,K){var be;const te=A.text,ne=A.fontProperties,ie=K._stroke,oe=((be=ie==null?void 0:ie.width)!=null?be:0)*L,ue=z+oe/2,de=I-oe/2,he=ne.descent*L,fe=A.lineHeight*L;K.stroke&&oe&&C.strokeText(te,ue,de+fe-he),K._fill&&C.fillText(te,ue,de+fe-he)}destroy(){super.destroy();for(let C=0;C<this.pages.length;C++){const{canvasAndContext:A,texture:z}=this.pages[C];A.canvas.width=A.canvas.width,CanvasPool.returnCanvasAndContext(A),z.destroy(!0)}this.pages=null}};_DynamicBitmapFont.defaultOptions={textureSize:512,style:new TextStyle,mipmap:!0};let DynamicBitmapFont=_DynamicBitmapFont;function getBitmapTextLayout(O,C,A){const z={width:0,height:0,offsetY:0,scale:C.fontSize/A.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};z.offsetY=A.baseLineOffset;let I=z.lines[0],L=null,K=!0;const te={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},ne=he=>{const fe=I.width;for(let be=0;be<te.index;be++){const xe=he.positions[be];I.chars.push(he.chars[be]),I.charPositions.push(xe+fe)}I.width+=he.width,K=!1,te.width=0,te.index=0,te.chars.length=0},ie=()=>{let he=I.chars.length-1,fe=I.chars[he];for(;fe===" ";)I.width-=A.chars[fe].xAdvance,fe=I.chars[--he];z.width=Math.max(z.width,I.width),I={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},K=!0,z.lines.push(I),z.height+=A.lineHeight},oe=A.baseMeasurementFontSize/C.fontSize,ue=C.letterSpacing*oe,de=C.wordWrapWidth*oe;for(let he=0;he<O.length+1;he++){let fe;const be=he===O.length;be||(fe=O[he]);const xe=A.chars[fe]||A.chars[" "];if(/(?:\s)/.test(fe)||fe==="\r"||fe===`
`||be){if(!K&&C.wordWrap&&I.width+te.width-ue>de?(ie(),ne(te),be||I.charPositions.push(0)):(te.start=I.width,ne(te),be||I.charPositions.push(0)),fe==="\r"||fe===`
`)I.width!==0&&ie();else if(!be){const Ge=xe.xAdvance+(xe.kerning[L]||0)+ue;I.width+=Ge,I.spaceWidth=Ge,I.spacesIndex.push(I.charPositions.length),I.chars.push(fe)}}else{const Ce=xe.kerning[L]||0,Ge=xe.xAdvance+Ce+ue;te.positions[te.index++]=te.width+Ce,te.chars.push(fe),te.width+=Ge}L=fe}return ie(),C.align==="center"?alignCenter(z):C.align==="right"?alignRight(z):C.align==="justify"&&alignJustify(z),z}function alignCenter(O){for(let C=0;C<O.lines.length;C++){const A=O.lines[C],z=O.width/2-A.width/2;for(let I=0;I<A.charPositions.length;I++)A.charPositions[I]+=z}}function alignRight(O){for(let C=0;C<O.lines.length;C++){const A=O.lines[C],z=O.width-A.width;for(let I=0;I<A.charPositions.length;I++)A.charPositions[I]+=z}}function alignJustify(O){const C=O.width;for(let A=0;A<O.lines.length;A++){const z=O.lines[A];let I=0,L=z.spacesIndex[I++],K=0;const te=z.spacesIndex.length,ie=(C-z.width)/te;for(let oe=0;oe<z.charPositions.length;oe++)oe===L&&(L=z.spacesIndex[I++],K+=ie),z.charPositions[oe]+=K}}let fontCount=0;class BitmapFontManagerClass{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(C,A){var K;let z=`${A.fontFamily}-bitmap`,I=!0;if(A._fill.fill&&!A._stroke)z+=A._fill.fill.styleKey,I=!1;else if(A._stroke||A.dropShadow){let te=A.styleKey;te=te.substring(0,te.lastIndexOf("-")),z=`${te}-bitmap`,I=!1}if(!Cache.has(z)){const te=new DynamicBitmapFont({style:A,overrideFill:I,overrideSize:!0,...this.defaultOptions});fontCount++,fontCount>50&&warn("BitmapText",`You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),te.once("destroy",()=>{fontCount--,Cache.remove(z)}),Cache.set(z,te)}const L=Cache.get(z);return(K=L.ensureCharacters)==null||K.call(L,C),L}getLayout(C,A){const z=this.getFont(C,A);return getBitmapTextLayout([...C],A,z)}measureText(C,A){return this.getLayout(C,A)}install(...C){var ie,oe,ue,de;let A=C[0];typeof A=="string"&&(A={name:A,style:C[1],chars:(ie=C[2])==null?void 0:ie.chars,resolution:(oe=C[2])==null?void 0:oe.resolution,padding:(ue=C[2])==null?void 0:ue.padding,skipKerning:(de=C[2])==null?void 0:de.skipKerning},deprecation(v8_0_0,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const z=A==null?void 0:A.name;if(!z)throw new Error("[BitmapFontManager] Property `name` is required.");A={...this.defaultOptions,...A};const I=A.style,L=I instanceof TextStyle?I:new TextStyle(I),K=L._fill.fill!==null&&L._fill.fill!==void 0,te=new DynamicBitmapFont({style:L,overrideFill:K,skipKerning:A.skipKerning,padding:A.padding,resolution:A.resolution,overrideSize:!1}),ne=resolveCharacters(A.chars);return te.ensureCharacters(ne.join("")),Cache.set(`${z}-bitmap`,te),te.once("destroy",()=>Cache.remove(`${z}-bitmap`)),te}uninstall(C){const A=`${C}-bitmap`,z=Cache.get(A);z&&(Cache.remove(A),z.destroy())}}const BitmapFontManager=new BitmapFontManagerClass;class EventsTickerClass{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(C){this.removeTickerListener(),this.events=C,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(C){this._pauseUpdate=C}addTickerListener(){this._tickerAdded||!this.domElement||(Ticker.system.add(this._tickerUpdate,this,UPDATE_PRIORITY.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){!this._tickerAdded||(Ticker.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const C=this.events._rootPointerEvent;this.events.supportsTouchEvents&&C.pointerType==="touch"||globalThis.document.dispatchEvent(new PointerEvent("pointermove",{clientX:C.clientX,clientY:C.clientY,pointerType:C.pointerType,pointerId:C.pointerId}))}_tickerUpdate(C){this._deltaTime+=C.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}}const EventsTicker=new EventsTickerClass;class FederatedMouseEvent extends FederatedEvent{constructor(){super(...arguments),this.client=new Point,this.movement=new Point,this.offset=new Point,this.global=new Point,this.screen=new Point}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(C,A,z){return C.worldTransform.applyInverse(z||this.global,A)}getModifierState(C){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(C)}initMouseEvent(C,A,z,I,L,K,te,ne,ie,oe,ue,de,he,fe,be){throw new Error("Method not implemented.")}}class FederatedPointerEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class FederatedWheelEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}FederatedWheelEvent.DOM_DELTA_PIXEL=0,FederatedWheelEvent.DOM_DELTA_LINE=1,FederatedWheelEvent.DOM_DELTA_PAGE=2;const PROPAGATION_LIMIT=2048,tempHitLocation=new Point,tempLocalMapping=new Point;class EventBoundary{constructor(C){this.dispatch=new EventEmitter,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=C,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(C,A){this.mappingTable[C]||(this.mappingTable[C]=[]),this.mappingTable[C].push({fn:A,priority:0}),this.mappingTable[C].sort((z,I)=>z.priority-I.priority)}dispatchEvent(C,A){C.propagationStopped=!1,C.propagationImmediatelyStopped=!1,this.propagate(C,A),this.dispatch.emit(A||C.type,C)}mapEvent(C){if(!this.rootTarget)return;const A=this.mappingTable[C.type];if(A)for(let z=0,I=A.length;z<I;z++)A[z].fn(C);else warn(`[EventBoundary]: Event mapping not defined for ${C.type}`)}hitTest(C,A){EventsTicker.pauseUpdate=!0;const I=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",L=this[I](this.rootTarget,this.rootTarget.eventMode,tempHitLocation.set(C,A),this.hitTestFn,this.hitPruneFn);return L&&L[0]}propagate(C,A){if(!C.target)return;const z=C.composedPath();C.eventPhase=C.CAPTURING_PHASE;for(let I=0,L=z.length-1;I<L;I++)if(C.currentTarget=z[I],this.notifyTarget(C,A),C.propagationStopped||C.propagationImmediatelyStopped)return;if(C.eventPhase=C.AT_TARGET,C.currentTarget=C.target,this.notifyTarget(C,A),!(C.propagationStopped||C.propagationImmediatelyStopped)){C.eventPhase=C.BUBBLING_PHASE;for(let I=z.length-2;I>=0;I--)if(C.currentTarget=z[I],this.notifyTarget(C,A),C.propagationStopped||C.propagationImmediatelyStopped)return}}all(C,A,z=this._allInteractiveElements){if(z.length===0)return;C.eventPhase=C.BUBBLING_PHASE;const I=Array.isArray(A)?A:[A];for(let L=z.length-1;L>=0;L--)I.forEach(K=>{C.currentTarget=z[L],this.notifyTarget(C,K)})}propagationPath(C){const A=[C];for(let z=0;z<PROPAGATION_LIMIT&&C!==this.rootTarget&&C.parent;z++){if(!C.parent)throw new Error("Cannot find propagation path to disconnected target");A.push(C.parent),C=C.parent}return A.reverse(),A}hitTestMoveRecursive(C,A,z,I,L,K=!1){let te=!1;if(this._interactivePrune(C))return null;if((C.eventMode==="dynamic"||A==="dynamic")&&(EventsTicker.pauseUpdate=!1),C.interactiveChildren&&C.children){const oe=C.children;for(let ue=oe.length-1;ue>=0;ue--){const de=oe[ue],he=this.hitTestMoveRecursive(de,this._isInteractive(A)?A:de.eventMode,z,I,L,K||L(C,z));if(he){if(he.length>0&&!he[he.length-1].parent)continue;const fe=C.isInteractive();(he.length>0||fe)&&(fe&&this._allInteractiveElements.push(C),he.push(C)),this._hitElements.length===0&&(this._hitElements=he),te=!0}}}const ne=this._isInteractive(A),ie=C.isInteractive();return ie&&ie&&this._allInteractiveElements.push(C),K||this._hitElements.length>0?null:te?this._hitElements:ne&&!L(C,z)&&I(C,z)?ie?[C]:[]:null}hitTestRecursive(C,A,z,I,L){if(this._interactivePrune(C)||L(C,z))return null;if((C.eventMode==="dynamic"||A==="dynamic")&&(EventsTicker.pauseUpdate=!1),C.interactiveChildren&&C.children){const ne=C.children,ie=z;for(let oe=ne.length-1;oe>=0;oe--){const ue=ne[oe],de=this.hitTestRecursive(ue,this._isInteractive(A)?A:ue.eventMode,ie,I,L);if(de){if(de.length>0&&!de[de.length-1].parent)continue;const he=C.isInteractive();return(de.length>0||he)&&de.push(C),de}}}const K=this._isInteractive(A),te=C.isInteractive();return K&&I(C,z)?te?[C]:[]:null}_isInteractive(C){return C==="static"||C==="dynamic"}_interactivePrune(C){return!C||!C.visible||!C.renderable||!C.includeInBuild||!C.measurable||C.eventMode==="none"||C.eventMode==="passive"&&!C.interactiveChildren}hitPruneFn(C,A){if(C.hitArea&&(C.worldTransform.applyInverse(A,tempLocalMapping),!C.hitArea.contains(tempLocalMapping.x,tempLocalMapping.y)))return!0;if(C.effects&&C.effects.length)for(let z=0;z<C.effects.length;z++){const I=C.effects[z];if(I.containsPoint&&!I.containsPoint(A,this.hitTestFn))return!0}return!1}hitTestFn(C,A){return C.hitArea?!0:C!=null&&C.containsPoint?(C.worldTransform.applyInverse(A,tempLocalMapping),C.containsPoint(tempLocalMapping)):!1}notifyTarget(C,A){var L,K;if(!C.currentTarget.isInteractive())return;A=A!=null?A:C.type;const z=`on${A}`;(K=(L=C.currentTarget)[z])==null||K.call(L,C);const I=C.eventPhase===C.CAPTURING_PHASE||C.eventPhase===C.AT_TARGET?`${A}capture`:A;this._notifyListeners(C,I),C.eventPhase===C.AT_TARGET&&this._notifyListeners(C,A)}mapPointerDown(C){if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const A=this.createPointerEvent(C);if(this.dispatchEvent(A,"pointerdown"),A.pointerType==="touch")this.dispatchEvent(A,"touchstart");else if(A.pointerType==="mouse"||A.pointerType==="pen"){const I=A.button===2;this.dispatchEvent(A,I?"rightdown":"mousedown")}const z=this.trackingData(C.pointerId);z.pressTargetsByButton[C.button]=A.composedPath(),this.freeEvent(A)}mapPointerMove(C){var ne,ie,oe;if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const A=this.createPointerEvent(C);this._isPointerMoveEvent=!1;const z=A.pointerType==="mouse"||A.pointerType==="pen",I=this.trackingData(C.pointerId),L=this.findMountedTarget(I.overTargets);if(((ne=I.overTargets)==null?void 0:ne.length)>0&&L!==A.target){const ue=C.type==="mousemove"?"mouseout":"pointerout",de=this.createPointerEvent(C,ue,L);if(this.dispatchEvent(de,"pointerout"),z&&this.dispatchEvent(de,"mouseout"),!A.composedPath().includes(L)){const he=this.createPointerEvent(C,"pointerleave",L);for(he.eventPhase=he.AT_TARGET;he.target&&!A.composedPath().includes(he.target);)he.currentTarget=he.target,this.notifyTarget(he),z&&this.notifyTarget(he,"mouseleave"),he.target=he.target.parent;this.freeEvent(he)}this.freeEvent(de)}if(L!==A.target){const ue=C.type==="mousemove"?"mouseover":"pointerover",de=this.clonePointerEvent(A,ue);this.dispatchEvent(de,"pointerover"),z&&this.dispatchEvent(de,"mouseover");let he=L==null?void 0:L.parent;for(;he&&he!==this.rootTarget.parent&&he!==A.target;)he=he.parent;if(!he||he===this.rootTarget.parent){const be=this.clonePointerEvent(A,"pointerenter");for(be.eventPhase=be.AT_TARGET;be.target&&be.target!==L&&be.target!==this.rootTarget.parent;)be.currentTarget=be.target,this.notifyTarget(be),z&&this.notifyTarget(be,"mouseenter"),be.target=be.target.parent;this.freeEvent(be)}this.freeEvent(de)}const K=[],te=(ie=this.enableGlobalMoveEvents)!=null?ie:!0;this.moveOnAll?K.push("pointermove"):this.dispatchEvent(A,"pointermove"),te&&K.push("globalpointermove"),A.pointerType==="touch"&&(this.moveOnAll?K.splice(1,0,"touchmove"):this.dispatchEvent(A,"touchmove"),te&&K.push("globaltouchmove")),z&&(this.moveOnAll?K.splice(1,0,"mousemove"):this.dispatchEvent(A,"mousemove"),te&&K.push("globalmousemove"),this.cursor=(oe=A.target)==null?void 0:oe.cursor),K.length>0&&this.all(A,K),this._allInteractiveElements.length=0,this._hitElements.length=0,I.overTargets=A.composedPath(),this.freeEvent(A)}mapPointerOver(C){var K;if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const A=this.trackingData(C.pointerId),z=this.createPointerEvent(C),I=z.pointerType==="mouse"||z.pointerType==="pen";this.dispatchEvent(z,"pointerover"),I&&this.dispatchEvent(z,"mouseover"),z.pointerType==="mouse"&&(this.cursor=(K=z.target)==null?void 0:K.cursor);const L=this.clonePointerEvent(z,"pointerenter");for(L.eventPhase=L.AT_TARGET;L.target&&L.target!==this.rootTarget.parent;)L.currentTarget=L.target,this.notifyTarget(L),I&&this.notifyTarget(L,"mouseenter"),L.target=L.target.parent;A.overTargets=z.composedPath(),this.freeEvent(z),this.freeEvent(L)}mapPointerOut(C){if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const A=this.trackingData(C.pointerId);if(A.overTargets){const z=C.pointerType==="mouse"||C.pointerType==="pen",I=this.findMountedTarget(A.overTargets),L=this.createPointerEvent(C,"pointerout",I);this.dispatchEvent(L),z&&this.dispatchEvent(L,"mouseout");const K=this.createPointerEvent(C,"pointerleave",I);for(K.eventPhase=K.AT_TARGET;K.target&&K.target!==this.rootTarget.parent;)K.currentTarget=K.target,this.notifyTarget(K),z&&this.notifyTarget(K,"mouseleave"),K.target=K.target.parent;A.overTargets=null,this.freeEvent(L),this.freeEvent(K)}this.cursor=null}mapPointerUp(C){if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const A=performance.now(),z=this.createPointerEvent(C);if(this.dispatchEvent(z,"pointerup"),z.pointerType==="touch")this.dispatchEvent(z,"touchend");else if(z.pointerType==="mouse"||z.pointerType==="pen"){const te=z.button===2;this.dispatchEvent(z,te?"rightup":"mouseup")}const I=this.trackingData(C.pointerId),L=this.findMountedTarget(I.pressTargetsByButton[C.button]);let K=L;if(L&&!z.composedPath().includes(L)){let te=L;for(;te&&!z.composedPath().includes(te);){if(z.currentTarget=te,this.notifyTarget(z,"pointerupoutside"),z.pointerType==="touch")this.notifyTarget(z,"touchendoutside");else if(z.pointerType==="mouse"||z.pointerType==="pen"){const ne=z.button===2;this.notifyTarget(z,ne?"rightupoutside":"mouseupoutside")}te=te.parent}delete I.pressTargetsByButton[C.button],K=te}if(K){const te=this.clonePointerEvent(z,"click");te.target=K,te.path=null,I.clicksByButton[C.button]||(I.clicksByButton[C.button]={clickCount:0,target:te.target,timeStamp:A});const ne=I.clicksByButton[C.button];if(ne.target===te.target&&A-ne.timeStamp<200?++ne.clickCount:ne.clickCount=1,ne.target=te.target,ne.timeStamp=A,te.detail=ne.clickCount,te.pointerType==="mouse"){const ie=te.button===2;this.dispatchEvent(te,ie?"rightclick":"click")}else te.pointerType==="touch"&&this.dispatchEvent(te,"tap");this.dispatchEvent(te,"pointertap"),this.freeEvent(te)}this.freeEvent(z)}mapPointerUpOutside(C){if(!(C instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const A=this.trackingData(C.pointerId),z=this.findMountedTarget(A.pressTargetsByButton[C.button]),I=this.createPointerEvent(C);if(z){let L=z;for(;L;)I.currentTarget=L,this.notifyTarget(I,"pointerupoutside"),I.pointerType==="touch"?this.notifyTarget(I,"touchendoutside"):(I.pointerType==="mouse"||I.pointerType==="pen")&&this.notifyTarget(I,I.button===2?"rightupoutside":"mouseupoutside"),L=L.parent;delete A.pressTargetsByButton[C.button]}this.freeEvent(I)}mapWheel(C){if(!(C instanceof FederatedWheelEvent)){warn("EventBoundary cannot map a non-wheel event as a wheel event");return}const A=this.createWheelEvent(C);this.dispatchEvent(A),this.freeEvent(A)}findMountedTarget(C){if(!C)return null;let A=C[0];for(let z=1;z<C.length&&C[z].parent===A;z++)A=C[z];return A}createPointerEvent(C,A,z){var L;const I=this.allocateEvent(FederatedPointerEvent);return this.copyPointerData(C,I),this.copyMouseData(C,I),this.copyData(C,I),I.nativeEvent=C.nativeEvent,I.originalEvent=C,I.target=(L=z!=null?z:this.hitTest(I.global.x,I.global.y))!=null?L:this._hitElements[0],typeof A=="string"&&(I.type=A),I}createWheelEvent(C){const A=this.allocateEvent(FederatedWheelEvent);return this.copyWheelData(C,A),this.copyMouseData(C,A),this.copyData(C,A),A.nativeEvent=C.nativeEvent,A.originalEvent=C,A.target=this.hitTest(A.global.x,A.global.y),A}clonePointerEvent(C,A){const z=this.allocateEvent(FederatedPointerEvent);return z.nativeEvent=C.nativeEvent,z.originalEvent=C.originalEvent,this.copyPointerData(C,z),this.copyMouseData(C,z),this.copyData(C,z),z.target=C.target,z.path=C.composedPath().slice(),z.type=A!=null?A:z.type,z}copyWheelData(C,A){A.deltaMode=C.deltaMode,A.deltaX=C.deltaX,A.deltaY=C.deltaY,A.deltaZ=C.deltaZ}copyPointerData(C,A){C instanceof FederatedPointerEvent&&A instanceof FederatedPointerEvent&&(A.pointerId=C.pointerId,A.width=C.width,A.height=C.height,A.isPrimary=C.isPrimary,A.pointerType=C.pointerType,A.pressure=C.pressure,A.tangentialPressure=C.tangentialPressure,A.tiltX=C.tiltX,A.tiltY=C.tiltY,A.twist=C.twist)}copyMouseData(C,A){C instanceof FederatedMouseEvent&&A instanceof FederatedMouseEvent&&(A.altKey=C.altKey,A.button=C.button,A.buttons=C.buttons,A.client.copyFrom(C.client),A.ctrlKey=C.ctrlKey,A.metaKey=C.metaKey,A.movement.copyFrom(C.movement),A.screen.copyFrom(C.screen),A.shiftKey=C.shiftKey,A.global.copyFrom(C.global))}copyData(C,A){A.isTrusted=C.isTrusted,A.srcElement=C.srcElement,A.timeStamp=performance.now(),A.type=C.type,A.detail=C.detail,A.view=C.view,A.which=C.which,A.layer.copyFrom(C.layer),A.page.copyFrom(C.page)}trackingData(C){return this.mappingState.trackingData[C]||(this.mappingState.trackingData[C]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[C]}allocateEvent(C){this.eventPool.has(C)||this.eventPool.set(C,[]);const A=this.eventPool.get(C).pop()||new C(this);return A.eventPhase=A.NONE,A.currentTarget=null,A.path=null,A.target=null,A}freeEvent(C){if(C.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const A=C.constructor;this.eventPool.has(A)||this.eventPool.set(A,[]),this.eventPool.get(A).push(C)}_notifyListeners(C,A){const z=C.currentTarget._events[A];if(!!z)if("fn"in z)z.once&&C.currentTarget.removeListener(A,z.fn,void 0,!0),z.fn.call(z.context,C);else for(let I=0,L=z.length;I<L&&!C.propagationImmediatelyStopped;I++)z[I].once&&C.currentTarget.removeListener(A,z[I].fn,void 0,!0),z[I].fn.call(z[I].context,C)}}const MOUSE_POINTER_ID=1,TOUCH_TO_POINTER={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},_EventSystem=class Lr{constructor(C){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=C,this.rootBoundary=new EventBoundary(null),EventsTicker.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new FederatedPointerEvent(null),this._rootWheelEvent=new FederatedWheelEvent(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy({...Lr.defaultEventFeatures},{set:(A,z,I)=>(z==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=I),A[z]=I,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(C){var I,L;const{canvas:A,resolution:z}=this.renderer;this.setTargetElement(A),this.resolution=z,Lr._defaultEventMode=(I=C.eventMode)!=null?I:"passive",Object.assign(this.features,(L=C.eventFeatures)!=null?L:{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(C){this.resolution=C}destroy(){this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(C){C=C||"default";let A=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(A=!1),this._currentCursor===C)return;this._currentCursor=C;const z=this.cursorStyles[C];if(z)switch(typeof z){case"string":A&&(this.domElement.style.cursor=z);break;case"function":z(C);break;case"object":A&&Object.assign(this.domElement.style,z);break}else A&&typeof C=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,C)&&(this.domElement.style.cursor=C)}get pointer(){return this._rootPointerEvent}_onPointerDown(C){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const A=this._normalizeToPointerData(C);this.autoPreventDefault&&A[0].isNormalized&&(C.cancelable||!("cancelable"in C))&&C.preventDefault();for(let z=0,I=A.length;z<I;z++){const L=A[z],K=this._bootstrapEvent(this._rootPointerEvent,L);this.rootBoundary.mapEvent(K)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(C){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,EventsTicker.pointerMoved();const A=this._normalizeToPointerData(C);for(let z=0,I=A.length;z<I;z++){const L=this._bootstrapEvent(this._rootPointerEvent,A[z]);this.rootBoundary.mapEvent(L)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(C){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let A=C.target;C.composedPath&&C.composedPath().length>0&&(A=C.composedPath()[0]);const z=A!==this.domElement?"outside":"",I=this._normalizeToPointerData(C);for(let L=0,K=I.length;L<K;L++){const te=this._bootstrapEvent(this._rootPointerEvent,I[L]);te.type+=z,this.rootBoundary.mapEvent(te)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(C){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const A=this._normalizeToPointerData(C);for(let z=0,I=A.length;z<I;z++){const L=this._bootstrapEvent(this._rootPointerEvent,A[z]);this.rootBoundary.mapEvent(L)}this.setCursor(this.rootBoundary.cursor)}onWheel(C){if(!this.features.wheel)return;const A=this.normalizeWheelEvent(C);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(A)}setTargetElement(C){this._removeEvents(),this.domElement=C,EventsTicker.domElement=C,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;EventsTicker.addTickerListener();const C=this.domElement.style;C&&(globalThis.navigator.msPointerEnabled?(C.msContentZooming="none",C.msTouchAction="none"):this.supportsPointerEvents&&(C.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;EventsTicker.removeTickerListener();const C=this.domElement.style;C&&(globalThis.navigator.msPointerEnabled?(C.msContentZooming="",C.msTouchAction=""):this.supportsPointerEvents&&(C.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(C,A,z){const I=this.domElement.isConnected?this.domElement.getBoundingClientRect():{x:0,y:0,width:this.domElement.width,height:this.domElement.height,left:0,top:0},L=1/this.resolution;C.x=(A-I.left)*(this.domElement.width/I.width)*L,C.y=(z-I.top)*(this.domElement.height/I.height)*L}_normalizeToPointerData(C){const A=[];if(this.supportsTouchEvents&&C instanceof TouchEvent)for(let z=0,I=C.changedTouches.length;z<I;z++){const L=C.changedTouches[z];typeof L.button=="undefined"&&(L.button=0),typeof L.buttons=="undefined"&&(L.buttons=1),typeof L.isPrimary=="undefined"&&(L.isPrimary=C.touches.length===1&&C.type==="touchstart"),typeof L.width=="undefined"&&(L.width=L.radiusX||1),typeof L.height=="undefined"&&(L.height=L.radiusY||1),typeof L.tiltX=="undefined"&&(L.tiltX=0),typeof L.tiltY=="undefined"&&(L.tiltY=0),typeof L.pointerType=="undefined"&&(L.pointerType="touch"),typeof L.pointerId=="undefined"&&(L.pointerId=L.identifier||0),typeof L.pressure=="undefined"&&(L.pressure=L.force||.5),typeof L.twist=="undefined"&&(L.twist=0),typeof L.tangentialPressure=="undefined"&&(L.tangentialPressure=0),typeof L.layerX=="undefined"&&(L.layerX=L.offsetX=L.clientX),typeof L.layerY=="undefined"&&(L.layerY=L.offsetY=L.clientY),L.isNormalized=!0,L.type=C.type,A.push(L)}else if(!globalThis.MouseEvent||C instanceof MouseEvent&&(!this.supportsPointerEvents||!(C instanceof globalThis.PointerEvent))){const z=C;typeof z.isPrimary=="undefined"&&(z.isPrimary=!0),typeof z.width=="undefined"&&(z.width=1),typeof z.height=="undefined"&&(z.height=1),typeof z.tiltX=="undefined"&&(z.tiltX=0),typeof z.tiltY=="undefined"&&(z.tiltY=0),typeof z.pointerType=="undefined"&&(z.pointerType="mouse"),typeof z.pointerId=="undefined"&&(z.pointerId=MOUSE_POINTER_ID),typeof z.pressure=="undefined"&&(z.pressure=.5),typeof z.twist=="undefined"&&(z.twist=0),typeof z.tangentialPressure=="undefined"&&(z.tangentialPressure=0),z.isNormalized=!0,A.push(z)}else A.push(C);return A}normalizeWheelEvent(C){const A=this._rootWheelEvent;return this._transferMouseData(A,C),A.deltaX=C.deltaX,A.deltaY=C.deltaY,A.deltaZ=C.deltaZ,A.deltaMode=C.deltaMode,this.mapPositionToPoint(A.screen,C.clientX,C.clientY),A.global.copyFrom(A.screen),A.offset.copyFrom(A.screen),A.nativeEvent=C,A.type=C.type,A}_bootstrapEvent(C,A){return C.originalEvent=null,C.nativeEvent=A,C.pointerId=A.pointerId,C.width=A.width,C.height=A.height,C.isPrimary=A.isPrimary,C.pointerType=A.pointerType,C.pressure=A.pressure,C.tangentialPressure=A.tangentialPressure,C.tiltX=A.tiltX,C.tiltY=A.tiltY,C.twist=A.twist,this._transferMouseData(C,A),this.mapPositionToPoint(C.screen,A.clientX,A.clientY),C.global.copyFrom(C.screen),C.offset.copyFrom(C.screen),C.isTrusted=A.isTrusted,C.type==="pointerleave"&&(C.type="pointerout"),C.type.startsWith("mouse")&&(C.type=C.type.replace("mouse","pointer")),C.type.startsWith("touch")&&(C.type=TOUCH_TO_POINTER[C.type]||C.type),C}_transferMouseData(C,A){C.isTrusted=A.isTrusted,C.srcElement=A.srcElement,C.timeStamp=performance.now(),C.type=A.type,C.altKey=A.altKey,C.button=A.button,C.buttons=A.buttons,C.client.x=A.clientX,C.client.y=A.clientY,C.ctrlKey=A.ctrlKey,C.metaKey=A.metaKey,C.movement.x=A.movementX,C.movement.y=A.movementY,C.page.x=A.pageX,C.page.y=A.pageY,C.relatedTarget=null,C.shiftKey=A.shiftKey}};_EventSystem.extension={name:"events",type:[ExtensionType.WebGLSystem,ExtensionType.CanvasSystem,ExtensionType.WebGPUSystem],priority:-1},_EventSystem.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};let EventSystem=_EventSystem;const FederatedContainer={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(O){this.eventMode=O?"static":"passive"},_internalEventMode:void 0,get eventMode(){var O;return(O=this._internalEventMode)!=null?O:EventSystem.defaultEventMode},set eventMode(O){this._internalEventMode=O},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(O,C,A){const z=typeof A=="boolean"&&A||typeof A=="object"&&A.capture,I=typeof A=="object"?A.signal:void 0,L=typeof A=="object"?A.once===!0:!1,K=typeof C=="function"?void 0:C;O=z?`${O}capture`:O;const te=typeof C=="function"?C:C.handleEvent,ne=this;I&&I.addEventListener("abort",()=>{ne.off(O,te,K)}),L?ne.once(O,te,K):ne.on(O,te,K)},removeEventListener(O,C,A){const z=typeof A=="boolean"&&A||typeof A=="object"&&A.capture,I=typeof C=="function"?void 0:C;O=z?`${O}capture`:O,C=typeof C=="function"?C:C.handleEvent,this.off(O,C,I)},dispatchEvent(O){if(!(O instanceof FederatedEvent))throw new Error("Container cannot propagate events outside of the Federated Events API");return O.defaultPrevented=!1,O.path=null,O.target=this,O.manager.dispatchEvent(O),!O.defaultPrevented}};var vertex$2=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,fragment$A=`
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`,source$A=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`;const _AlphaFilter=class $r extends Filter{constructor(C){C={...$r.defaultOptions,...C};const A=GpuProgram.from({vertex:{source:source$A,entryPoint:"mainVertex"},fragment:{source:source$A,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$2,fragment:fragment$A,name:"alpha-filter"}),{alpha:I,...L}=C,K=new UniformGroup({uAlpha:{value:I,type:"f32"}});super({...L,gpuProgram:A,glProgram:z,resources:{alphaUniforms:K}})}get alpha(){return this.resources.alphaUniforms.uniforms.uAlpha}set alpha(C){this.resources.alphaUniforms.uniforms.uAlpha=C}};_AlphaFilter.defaultOptions={alpha:1};let AlphaFilter=_AlphaFilter,count=0;class TexturePoolClass{constructor(C){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=C||{},this.enableFullScreen=!1}createTexture(C,A,z){const I=new TextureSource({...this.textureOptions,width:C,height:A,resolution:1,antialias:z,autoGarbageCollect:!0});return new Texture({source:I,label:`texturePool_${count++}`})}getOptimalTexture(C,A,z=1,I){let L=Math.ceil(C*z-1e-6),K=Math.ceil(A*z-1e-6);L=nextPow2(L),K=nextPow2(K);const te=(L<<17)+(K<<1)+(I?1:0);this._texturePool[te]||(this._texturePool[te]=[]);let ne=this._texturePool[te].pop();return ne||(ne=this.createTexture(L,K,I)),ne.source._resolution=z,ne.source.width=L/z,ne.source.height=K/z,ne.source.pixelWidth=L,ne.source.pixelHeight=K,ne.frame.x=0,ne.frame.y=0,ne.frame.width=C,ne.frame.height=A,ne.updateUvs(),this._poolKeyHash[ne.uid]=te,ne}getSameSizeTexture(C,A=!1){const z=C.source;return this.getOptimalTexture(C.width,C.height,z._resolution,A)}returnTexture(C){const A=this._poolKeyHash[C.uid];this._texturePool[A].push(C)}clear(C){if(C=C!==!1,C)for(const A in this._texturePool){const z=this._texturePool[A];if(z)for(let I=0;I<z.length;I++)z[I].destroy(!0)}this._texturePool={}}}const TexturePool=new TexturePoolClass,GAUSSIAN_VALUES={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]},fragTemplate=["in vec2 vBlurTexCoords[%size%];","uniform sampler2D uTexture;","out vec4 finalColor;","void main(void)","{","    finalColor = vec4(0.0);","    %blur%","}"].join(`
`);function generateBlurFragSource(O){const C=GAUSSIAN_VALUES[O],A=C.length;let z=fragTemplate,I="";const L="finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";let K;for(let te=0;te<O;te++){let ne=L.replace("%index%",te.toString());K=te,te>=A&&(K=O-te-1),ne=ne.replace("%value%",C[K].toString()),I+=ne,I+=`
`}return z=z.replace("%blur%",I),z=z.replace("%size%",O.toString()),z}const vertTemplate=`
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;function generateBlurVertSource(O,C){const A=Math.ceil(O/2);let z=vertTemplate,I="",L;C?L="vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);":L="vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";for(let K=0;K<O;K++){let te=L.replace("%index%",K.toString());te=te.replace("%sampleIndex%",`${K-(A-1)}.0`),I+=te,I+=`
`}return z=z.replace("%blur%",I),z=z.replace("%size%",O.toString()),z=z.replace("%dimension%",C?"z":"w"),z}function generateBlurGlProgram(O,C){const A=generateBlurVertSource(C,O),z=generateBlurFragSource(C);return GlProgram.from({vertex:A,fragment:z,name:`blur-${O?"horizontal":"vertical"}-pass-filter`})}var source$z=`

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;function generateBlurProgram(O,C){const A=GAUSSIAN_VALUES[C],z=A.length,I=[],L=[],K=[];for(let ue=0;ue<C;ue++){I[ue]=`@location(${ue}) offset${ue}: vec2<f32>,`,O?L[ue]=`filteredCord + vec2(${ue-z+1} * pixelStrength, 0.0),`:L[ue]=`filteredCord + vec2(0.0, ${ue-z+1} * pixelStrength),`;const de=ue<z?ue:C-ue-1,he=A[de].toString();K[ue]=`finalColor += textureSample(uTexture, uSampler, offset${ue}) * ${he};`}const te=I.join(`
`),ne=L.join(`
`),ie=K.join(`
`),oe=source$z.replace("%blur-struct%",te).replace("%blur-vertex-out%",ne).replace("%blur-fragment-in%",te).replace("%blur-sampling%",ie).replace("%dimension%",O?"z":"w");return GpuProgram.from({vertex:{source:oe,entryPoint:"mainVertex"},fragment:{source:oe,entryPoint:"mainFragment"}})}const _BlurFilterPass=class qr extends Filter{constructor(C){C={...qr.defaultOptions,...C};const A=generateBlurGlProgram(C.horizontal,C.kernelSize),z=generateBlurProgram(C.horizontal,C.kernelSize);super({glProgram:A,gpuProgram:z,resources:{blurUniforms:{uStrength:{value:0,type:"f32"}}},...C}),this.horizontal=C.horizontal,this._quality=0,this.quality=C.quality,this.blur=C.strength,this._uniforms=this.resources.blurUniforms.uniforms}apply(C,A,z,I){if(this._uniforms.uStrength=this.strength/this.passes,this.passes===1)C.applyFilter(this,A,z,I);else{const L=TexturePool.getSameSizeTexture(A);let K=A,te=L;this._state.blend=!1;const ne=C.renderer.type===RendererType.WEBGPU;for(let ie=0;ie<this.passes-1;ie++){C.applyFilter(this,K,te,ie===0?!0:ne);const oe=te;te=K,K=oe}this._state.blend=!0,C.applyFilter(this,K,z,I),TexturePool.returnTexture(L)}}get blur(){return this.strength}set blur(C){this.padding=1+Math.abs(C)*2,this.strength=C}get quality(){return this._quality}set quality(C){this._quality=C,this.passes=C}};_BlurFilterPass.defaultOptions={strength:8,quality:4,kernelSize:5};let BlurFilterPass=_BlurFilterPass;class BlurFilter extends Filter{constructor(...C){var ne;let A=(ne=C[0])!=null?ne:{};typeof A=="number"&&(deprecation(v8_0_0,"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"),A={strength:A},C[1]!==void 0&&(A.quality=C[1]),C[2]!==void 0&&(A.resolution=C[2]||"inherit"),C[3]!==void 0&&(A.kernelSize=C[3])),A={...BlurFilterPass.defaultOptions,...A};const{strength:z,strengthX:I,strengthY:L,quality:K,...te}=A;super({...te,compatibleRenderers:RendererType.BOTH,resources:{}}),this._repeatEdgePixels=!1,this.blurXFilter=new BlurFilterPass({horizontal:!0,...A}),this.blurYFilter=new BlurFilterPass({horizontal:!1,...A}),this.quality=K,this.strengthX=I!=null?I:z,this.strengthY=L!=null?L:z,this.repeatEdgePixels=!1}apply(C,A,z,I){const L=Math.abs(this.blurXFilter.strength),K=Math.abs(this.blurYFilter.strength);if(L&&K){const te=TexturePool.getSameSizeTexture(A);this.blurXFilter.blendMode="normal",this.blurXFilter.apply(C,A,te,!0),this.blurYFilter.blendMode=this.blendMode,this.blurYFilter.apply(C,te,z,I),TexturePool.returnTexture(te)}else K?(this.blurYFilter.blendMode=this.blendMode,this.blurYFilter.apply(C,A,z,I)):(this.blurXFilter.blendMode=this.blendMode,this.blurXFilter.apply(C,A,z,I))}updatePadding(){this._repeatEdgePixels?this.padding=0:this.padding=Math.max(Math.abs(this.blurXFilter.blur),Math.abs(this.blurYFilter.blur))*2}get strength(){if(this.strengthX!==this.strengthY)throw new Error("BlurFilter's strengthX and strengthY are different");return this.strengthX}set strength(C){this.blurXFilter.blur=this.blurYFilter.blur=C,this.updatePadding()}get quality(){return this.blurXFilter.quality}set quality(C){this.blurXFilter.quality=this.blurYFilter.quality=C}get strengthX(){return this.blurXFilter.blur}set strengthX(C){this.blurXFilter.blur=C,this.updatePadding()}get strengthY(){return this.blurYFilter.blur}set strengthY(C){this.blurYFilter.blur=C,this.updatePadding()}get blur(){return deprecation("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead."),this.strength}set blur(C){deprecation("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead."),this.strength=C}get blurX(){return deprecation("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."),this.strengthX}set blurX(C){deprecation("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."),this.strengthX=C}get blurY(){return deprecation("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."),this.strengthY}set blurY(C){deprecation("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."),this.strengthY=C}get repeatEdgePixels(){return this._repeatEdgePixels}set repeatEdgePixels(C){this._repeatEdgePixels=C,this.updatePadding()}}BlurFilter.defaultOptions={strength:8,quality:4,kernelSize:5};class FilterPipe{constructor(C){this._renderer=C}push(C,A,z){this._renderer.renderPipes.batch.break(z),z.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:A,filterEffect:C})}pop(C,A,z){this._renderer.renderPipes.batch.break(z),z.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(C){C.action==="pushFilter"?this._renderer.filter.push(C):C.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"filter"};const tempMatrix=new Matrix;function getFastGlobalBounds(O,C){return C.clear(),_getGlobalBoundsRecursive(O,C),C.isValid||C.set(0,0,0,0),O.renderGroup?C.applyMatrix(O.renderGroup.localTransform):C.applyMatrix(O.parentRenderGroup.worldTransform),C}function _getGlobalBoundsRecursive(O,C){if(O.localDisplayStatus!==7||!O.measurable)return;const A=!!O.effects.length;let z=C;if((O.renderGroup||A)&&(z=boundsPool.get().clear()),O.boundsArea)C.addRect(O.boundsArea,O.worldTransform);else{if(O.renderPipeId){const L=O.bounds;z.addFrame(L.minX,L.minY,L.maxX,L.maxY,O.groupTransform)}const I=O.children;for(let L=0;L<I.length;L++)_getGlobalBoundsRecursive(I[L],z)}if(A){let I=!1;for(let L=0;L<O.effects.length;L++)O.effects[L].addBounds&&(I||(I=!0,z.applyMatrix(O.parentRenderGroup.worldTransform)),O.effects[L].addBounds(z,!0));I&&(z.applyMatrix(O.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert()),C.addBounds(z,O.relativeGroupTransform)),C.addBounds(z),boundsPool.return(z)}else O.renderGroup&&(C.addBounds(z,O.relativeGroupTransform),boundsPool.return(z))}function getGlobalRenderableBounds(O,C){C.clear();const A=C.matrix;for(let z=0;z<O.length;z++){const I=O[z];I.globalDisplayStatus<7||(C.matrix=I.worldTransform,I.addBounds(C))}return C.matrix=A,C}const quadGeometry=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(C){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=C}get activeBackTexture(){var C;return(C=this._activeFilterData)==null?void 0:C.backTexture}push(C){var he,fe;const A=this.renderer,z=C.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const I=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,z.length===0){I.skip=!0;return}const L=I.bounds;C.renderables?getGlobalRenderableBounds(C.renderables,L):C.filterEffect.filterArea?(L.clear(),L.addRect(C.filterEffect.filterArea),L.applyMatrix(C.container.worldTransform)):getFastGlobalBounds(C.container,L);const K=A.renderTarget.renderTarget.colorTexture.source;let te=1/0,ne=0,ie=!0,oe=!1,ue=!1;for(let be=0;be<z.length;be++){const xe=z[be];if(te=Math.min(te,xe.resolution==="inherit"?K._resolution:xe.resolution),ne+=xe.padding,xe.antialias==="off"?ie=!1:xe.antialias==="inherit"&&ie&&(ie=K.antialias),!!!(xe.compatibleRenderers&A.type)){ue=!1;break}if(xe.blendRequired&&!((fe=(he=A.backBuffer)==null?void 0:he.useBackBuffer)==null||fe)){warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),ue=!1;break}ue=xe.enabled||ue,oe=oe||xe.blendRequired}if(!ue){I.skip=!0;return}const de=A.renderTarget.rootViewPort;if(L.scale(te).fitBounds(0,de.width,0,de.height).ceil().scale(1/te).pad(ne|0),!L.isPositive){I.skip=!0;return}I.skip=!1,I.bounds=L,I.blendRequired=oe,I.container=C.container,I.filterEffect=C.filterEffect,I.previousRenderSurface=A.renderTarget.renderSurface,I.inputTexture=TexturePool.getOptimalTexture(L.width,L.height,te,ie),A.renderTarget.bind(I.inputTexture,!0),A.globalUniforms.push({offset:L})}pop(){const C=this.renderer;this._filterStackIndex--;const A=this._filterStack[this._filterStackIndex];if(A.skip)return;this._activeFilterData=A;const z=A.inputTexture,I=A.bounds;let L=Texture.EMPTY;if(C.renderTarget.finishRenderPass(),A.blendRequired){const te=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,ne=C.renderTarget.getRenderTarget(A.previousRenderSurface);L=this.getBackTexture(ne,I,te)}A.backTexture=L;const K=A.filterEffect.filters;if(this._globalFilterBindGroup.setResource(z.source.style,2),this._globalFilterBindGroup.setResource(L.source,3),C.globalUniforms.pop(),K.length===1)K[0].apply(this,z,A.previousRenderSurface,!1),TexturePool.returnTexture(z);else{let te=A.inputTexture,ne=TexturePool.getOptimalTexture(I.width,I.height,te.source._resolution,!1),ie=0;for(ie=0;ie<K.length-1;++ie){K[ie].apply(this,te,ne,!0);const ue=te;te=ne,ne=ue}K[ie].apply(this,te,A.previousRenderSurface,!1),TexturePool.returnTexture(te),TexturePool.returnTexture(ne)}A.blendRequired&&TexturePool.returnTexture(L)}getBackTexture(C,A,z){const I=C.colorTexture.source._resolution,L=TexturePool.getOptimalTexture(A.width,A.height,I,!1);let K=A.minX,te=A.minY;z&&(K-=z.minX,te-=z.minY),K=Math.floor(K*I),te=Math.floor(te*I);const ne=Math.ceil(A.width*I),ie=Math.ceil(A.height*I);return this.renderer.renderTarget.copyToTexture(C,L,{x:K,y:te},{width:ne,height:ie},{x:0,y:0}),L}applyFilter(C,A,z,I){const L=this.renderer,K=this._filterStack[this._filterStackIndex],te=K.bounds,ne=Point.shared,oe=K.previousRenderSurface===z;let ue=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,de=this._filterStackIndex-1;for(;de>0&&this._filterStack[de].skip;)--de;de>0&&(ue=this._filterStack[de].inputTexture.source._resolution);const he=this._filterGlobalUniforms,fe=he.uniforms,be=fe.uOutputFrame,xe=fe.uInputSize,Se=fe.uInputPixel,Fe=fe.uInputClamp,Ce=fe.uGlobalFrame,Ge=fe.uOutputTexture;if(oe){let Ze=this._filterStackIndex;for(;Ze>0;){Ze--;const ct=this._filterStack[this._filterStackIndex-1];if(!ct.skip){ne.x=ct.bounds.minX,ne.y=ct.bounds.minY;break}}be[0]=te.minX-ne.x,be[1]=te.minY-ne.y}else be[0]=0,be[1]=0;be[2]=A.frame.width,be[3]=A.frame.height,xe[0]=A.source.width,xe[1]=A.source.height,xe[2]=1/xe[0],xe[3]=1/xe[1],Se[0]=A.source.pixelWidth,Se[1]=A.source.pixelHeight,Se[2]=1/Se[0],Se[3]=1/Se[1],Fe[0]=.5*Se[2],Fe[1]=.5*Se[3],Fe[2]=A.frame.width*xe[2]-.5*Se[2],Fe[3]=A.frame.height*xe[3]-.5*Se[3];const Ve=this.renderer.renderTarget.rootRenderTarget.colorTexture;Ce[0]=ne.x*ue,Ce[1]=ne.y*ue,Ce[2]=Ve.source.width*ue,Ce[3]=Ve.source.height*ue;const pt=this.renderer.renderTarget.getRenderTarget(z);if(L.renderTarget.bind(z,!!I),z instanceof Texture?(Ge[0]=z.frame.width,Ge[1]=z.frame.height):(Ge[0]=pt.width,Ge[1]=pt.height),Ge[2]=pt.isRoot?-1:1,he.update(),L.renderPipes.uniformBatch){const Ze=L.renderPipes.uniformBatch.getUboResource(he);this._globalFilterBindGroup.setResource(Ze,0)}else this._globalFilterBindGroup.setResource(he,0);this._globalFilterBindGroup.setResource(A.source,1),this._globalFilterBindGroup.setResource(A.source.style,2),C.groups[0]=this._globalFilterBindGroup,L.encoder.draw({geometry:quadGeometry,shader:C,state:C._state,topology:"triangle-list"}),L.type===RendererType.WEBGL&&L.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(C,A){const z=this._activeFilterData,I=C.set(z.inputTexture._source.width,0,0,z.inputTexture._source.height,z.bounds.minX,z.bounds.minY),L=A.worldTransform.copyTo(Matrix.shared);return L.invert(),I.prepend(L),I.scale(1/A.texture.frame.width,1/A.texture.frame.height),I.translate(A.anchor.x,A.anchor.y),I}}FilterSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"filter"};class Graphics extends ViewContainer{constructor(C){C instanceof GraphicsContext&&(C={context:C});const{context:A,roundPixels:z,...I}=C||{};super({label:"Graphics",...I}),this.renderPipeId="graphics",A?this._context=A:this._context=this._ownedContext=new GraphicsContext,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=z!=null?z:!1}set context(C){C!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=C,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}addBounds(C){C.addBounds(this._context.bounds)}containsPoint(C){return this._context.containsPoint(C)}onViewUpdate(){if(this._didViewChangeTick++,this._didGraphicsUpdate=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const C=this.renderGroup||this.parentRenderGroup;C&&C.onChildViewUpdate(this)}destroy(C){this._ownedContext&&!C?this._ownedContext.destroy(C):(C===!0||(C==null?void 0:C.context)===!0)&&this._context.destroy(C),this._ownedContext=null,this._context=null,super.destroy(C)}_callContextMethod(C,A){return this.context[C](...A),this}setFillStyle(...C){return this._callContextMethod("setFillStyle",C)}setStrokeStyle(...C){return this._callContextMethod("setStrokeStyle",C)}fill(...C){return this._callContextMethod("fill",C)}stroke(...C){return this._callContextMethod("stroke",C)}texture(...C){return this._callContextMethod("texture",C)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...C){return this._callContextMethod("arc",C)}arcTo(...C){return this._callContextMethod("arcTo",C)}arcToSvg(...C){return this._callContextMethod("arcToSvg",C)}bezierCurveTo(...C){return this._callContextMethod("bezierCurveTo",C)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...C){return this._callContextMethod("ellipse",C)}circle(...C){return this._callContextMethod("circle",C)}path(...C){return this._callContextMethod("path",C)}lineTo(...C){return this._callContextMethod("lineTo",C)}moveTo(...C){return this._callContextMethod("moveTo",C)}quadraticCurveTo(...C){return this._callContextMethod("quadraticCurveTo",C)}rect(...C){return this._callContextMethod("rect",C)}roundRect(...C){return this._callContextMethod("roundRect",C)}poly(...C){return this._callContextMethod("poly",C)}regularPoly(...C){return this._callContextMethod("regularPoly",C)}roundPoly(...C){return this._callContextMethod("roundPoly",C)}roundShape(...C){return this._callContextMethod("roundShape",C)}filletRect(...C){return this._callContextMethod("filletRect",C)}chamferRect(...C){return this._callContextMethod("chamferRect",C)}star(...C){return this._callContextMethod("star",C)}svg(...C){return this._callContextMethod("svg",C)}restore(...C){return this._callContextMethod("restore",C)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...C){return this._callContextMethod("rotate",C)}scaleTransform(...C){return this._callContextMethod("scale",C)}setTransform(...C){return this._callContextMethod("setTransform",C)}transform(...C){return this._callContextMethod("transform",C)}translateTransform(...C){return this._callContextMethod("translate",C)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(C){this._context.fillStyle=C}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(C){this._context.strokeStyle=C}clone(C=!1){return C?new Graphics(this._context.clone()):(this._ownedContext=null,new Graphics(this._context))}lineStyle(C,A,z){deprecation(v8_0_0,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const I={};return C&&(I.width=C),A&&(I.color=A),z&&(I.alpha=z),this.context.strokeStyle=I,this}beginFill(C,A){deprecation(v8_0_0,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const z={};return C&&(z.color=C),A&&(z.alpha=A),this.context.fillStyle=z,this}endFill(){deprecation(v8_0_0,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const C=this.context.strokeStyle;return(C.width!==GraphicsContext.defaultStrokeStyle.width||C.color!==GraphicsContext.defaultStrokeStyle.color||C.alpha!==GraphicsContext.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...C){return deprecation(v8_0_0,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",C)}drawEllipse(...C){return deprecation(v8_0_0,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",C)}drawPolygon(...C){return deprecation(v8_0_0,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",C)}drawRect(...C){return deprecation(v8_0_0,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",C)}drawRoundedRect(...C){return deprecation(v8_0_0,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",C)}drawStar(...C){return deprecation(v8_0_0,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",C)}}const _MeshGeometry=class Jr extends Geometry{constructor(...C){var oe;let A=(oe=C[0])!=null?oe:{};A instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),A={positions:A,uvs:C[1],indices:C[2]}),A={...Jr.defaultOptions,...A};const z=A.positions||new Float32Array([0,0,1,0,1,1,0,1]),I=A.uvs||new Float32Array([0,0,1,0,1,1,0,1]),L=A.indices||new Uint32Array([0,1,2,0,2,3]),K=A.shrinkBuffersToFit,te=new Buffer({data:z,label:"attribute-mesh-positions",shrinkToFit:K,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ne=new Buffer({data:I,label:"attribute-mesh-uvs",shrinkToFit:K,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ie=new Buffer({data:L,label:"index-mesh-buffer",shrinkToFit:K,usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:te,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:ne,format:"float32x2",stride:2*4,offset:0}},indexBuffer:ie,topology:A.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(C){this.attributes.aPosition.buffer.data=C}get uvs(){return this.attributes.aUV.buffer.data}set uvs(C){this.attributes.aUV.buffer.data=C}get indices(){return this.indexBuffer.data}set indices(C){this.indexBuffer.data=C}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry;class AbstractText extends ViewContainer{constructor(C,A){const{text:z,resolution:I,style:L,anchor:K,width:te,height:ne,roundPixels:ie,...oe}=C;super({...oe}),this.batched=!0,this._resolution=null,this._autoResolution=!0,this._didTextUpdate=!0,this._styleClass=A,this.text=z!=null?z:"",this.style=L,this.resolution=I!=null?I:null,this.allowChildren=!1,this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),K&&(this.anchor=K),this.roundPixels=ie!=null?ie:!1,te!==void 0&&(this.width=te),ne!==void 0&&(this.height=ne)}get anchor(){return this._anchor}set anchor(C){typeof C=="number"?this._anchor.set(C):this._anchor.copyFrom(C)}set text(C){C=C.toString(),this._text!==C&&(this._text=C,this.onViewUpdate())}get text(){return this._text}set resolution(C){this._autoResolution=C===null,this._resolution=C,this.onViewUpdate()}get resolution(){return this._resolution}get style(){return this._style}set style(C){var A;C=C||{},(A=this._style)==null||A.off("update",this.onViewUpdate,this),C instanceof this._styleClass?this._style=C:this._style=new this._styleClass(C),this._style.on("update",this.onViewUpdate,this),this.onViewUpdate()}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}get width(){return Math.abs(this.scale.x)*this.bounds.width}set width(C){this._setWidth(C,this.bounds.width)}get height(){return Math.abs(this.scale.y)*this.bounds.height}set height(C){this._setHeight(C,this.bounds.height)}getSize(C){return C||(C={}),C.width=Math.abs(this.scale.x)*this.bounds.width,C.height=Math.abs(this.scale.y)*this.bounds.height,C}setSize(C,A){var z;typeof C=="object"?(A=(z=C.height)!=null?z:C.width,C=C.width):A!=null||(A=C),C!==void 0&&this._setWidth(C,this.bounds.width),A!==void 0&&this._setHeight(A,this.bounds.height)}addBounds(C){const A=this.bounds;C.addFrame(A.minX,A.minY,A.maxX,A.maxY)}containsPoint(C){const A=this.bounds.width,z=this.bounds.height,I=-A*this.anchor.x;let L=0;return C.x>=I&&C.x<=I+A&&(L=-z*this.anchor.y,C.y>=L&&C.y<=L+z)}onViewUpdate(){if(this._didViewChangeTick++,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0,this._didTextUpdate=!0;const C=this.renderGroup||this.parentRenderGroup;C&&C.onChildViewUpdate(this)}_getKey(){return`${this.text}:${this._style.styleKey}:${this._resolution}`}destroy(C=!1){super.destroy(C),this.owner=null,this._bounds=null,this._anchor=null,(typeof C=="boolean"?C:C==null?void 0:C.style)&&this._style.destroy(C),this._style=null,this._text=null}}function ensureOptions(O,C){var z;let A=(z=O[0])!=null?z:{};return(typeof A=="string"||O[1])&&(deprecation(v8_0_0,`use new ${C}({ text: "hi!", style }) instead`),A={text:A,style:O[1]}),A}class Text extends AbstractText{constructor(...C){const A=ensureOptions(C,"Text");super(A,TextStyle),this.renderPipeId="text"}_updateBounds(){const C=this._bounds,A=this._anchor,z=CanvasTextMetrics.measureText(this._text,this._style),{width:I,height:L}=z;C.minX=-A._x*I,C.maxX=C.minX+I,C.minY=-A._y*L,C.maxY=C.minY+L}}function textStyleToCSS(O){const C=O._stroke,A=O._fill,I=[`div { ${[`color: ${Color.shared.setValue(A.color).toHex()}`,`font-size: ${O.fontSize}px`,`font-family: ${O.fontFamily}`,`font-weight: ${O.fontWeight}`,`font-style: ${O.fontStyle}`,`font-variant: ${O.fontVariant}`,`letter-spacing: ${O.letterSpacing}px`,`text-align: ${O.align}`,`padding: ${O.padding}px`,`white-space: ${O.whiteSpace==="pre"&&O.wordWrap?"pre-wrap":O.whiteSpace}`,...O.lineHeight?[`line-height: ${O.lineHeight}px`]:[],...O.wordWrap?[`word-wrap: ${O.breakWords?"break-all":"break-word"}`,`max-width: ${O.wordWrapWidth}px`]:[],...C?[strokeToCSS(C)]:[],...O.dropShadow?[dropShadowToCSS(O.dropShadow)]:[],...O.cssOverrides].join(";")} }`];return tagStyleToCSS(O.tagStyles,I),I.join(" ")}function dropShadowToCSS(O){const C=Color.shared.setValue(O.color).setAlpha(O.alpha).toHexa(),A=Math.round(Math.cos(O.angle)*O.distance),z=Math.round(Math.sin(O.angle)*O.distance),I=`${A}px ${z}px`;return O.blur>0?`text-shadow: ${I} ${O.blur}px ${C}`:`text-shadow: ${I} ${C}`}function strokeToCSS(O){return[`-webkit-text-stroke-width: ${O.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(O.color).toHex()}`,`text-stroke-width: ${O.width}px`,`text-stroke-color: ${Color.shared.setValue(O.color).toHex()}`,"paint-order: stroke"].join(";")}const templates={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},transform={fill:O=>`color: ${Color.shared.setValue(O).toHex()}`,breakWords:O=>`word-wrap: ${O?"break-all":"break-word"}`,stroke:strokeToCSS,dropShadow:dropShadowToCSS};function tagStyleToCSS(O,C){for(const A in O){const z=O[A],I=[];for(const L in z)transform[L]?I.push(transform[L](z[L])):templates[L]&&I.push(templates[L].replace("{{VALUE}}",z[L]));C.push(`${A} { ${I.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(C={}){var A,z;super(C),this._cssOverrides=[],(A=this.cssOverrides)!=null||(this.cssOverrides=C.cssOverrides),this.tagStyles=(z=C.tagStyles)!=null?z:{}}set cssOverrides(C){this._cssOverrides=C instanceof Array?C:[C],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=generateTextStyleKey(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow?{...this.dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...C){const A=C.filter(z=>!this.cssOverrides.includes(z));A.length>0&&(this.cssOverrides.push(...A),this.update())}removeOverride(...C){const A=C.filter(z=>this.cssOverrides.includes(z));A.length>0&&(this.cssOverrides=this.cssOverrides.filter(z=>!A.includes(z)),this.update())}set fill(C){typeof C!="string"&&typeof C!="number"&&warn("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=C}set stroke(C){C&&typeof C!="string"&&typeof C!="number"&&warn("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=C}}const nssvg="http://www.w3.org/2000/svg",nsxhtml="http://www.w3.org/1999/xhtml";class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(nssvg,"svg"),this.foreignObject=document.createElementNS(nssvg,"foreignObject"),this.domElement=document.createElementNS(nsxhtml,"div"),this.styleElement=document.createElementNS(nsxhtml,"style"),this.image=new Image;const{foreignObject:C,svgRoot:A,styleElement:z,domElement:I}=this;C.setAttribute("width","10000"),C.setAttribute("height","10000"),C.style.overflow="hidden",A.appendChild(C),C.appendChild(z),C.appendChild(I)}}let tempHTMLTextRenderData;function measureHtmlText(O,C,A,z){z=z||tempHTMLTextRenderData||(tempHTMLTextRenderData=new HTMLTextRenderData);const{domElement:I,styleElement:L,svgRoot:K}=z;I.innerHTML=`<style>${C.cssStyle};</style><div style='padding:0'>${O}</div>`,I.setAttribute("style","transform-origin: top left; display: inline-block"),A&&(L.textContent=A),document.body.appendChild(K);const te=I.getBoundingClientRect();K.remove();const ne=CanvasTextMetrics.measureFont(C.fontStyle).descent,ie=C.padding*2;return{width:te.width-ie,height:te.height+ne-ie}}function addBits(O,C,A){if(O)for(const z in O){const I=z.toLocaleLowerCase(),L=C[I];if(L){let K=O[z];z==="header"&&(K=K.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),A&&L.push(`//----${A}----//`),L.push(K)}else warn(`${z} placement hook does not exist in shader`)}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(O){var z,I;const C={};return((I=(z=O.match(findHooksRx))==null?void 0:z.map(L=>L.replace(/[{()}]/g,"")))!=null?I:[]).forEach(L=>{C[L]=[]}),C}function extractInputs(O,C){let A;const z=/@in\s+([^;]+);/g;for(;(A=z.exec(O))!==null;)C.push(A[1])}function compileInputs(O,C,A=!1){const z=[];extractInputs(C,z),O.forEach(te=>{te.header&&extractInputs(te.header,z)});const I=z;A&&I.sort();const L=I.map((te,ne)=>`       @location(${ne}) ${te},`).join(`
`);let K=C.replace(/@in\s+[^;]+;\s*/g,"");return K=K.replace("{{in}}",`
${L}
`),K}function extractOutputs(O,C){let A;const z=/@out\s+([^;]+);/g;for(;(A=z.exec(O))!==null;)C.push(A[1])}function extractVariableName(O){const A=/\b(\w+)\s*:/g.exec(O);return A?A[1]:""}function stripVariable(O){const C=/@.*?\s+/g;return O.replace(C,"")}function compileOutputs(O,C){const A=[];extractOutputs(C,A),O.forEach(ne=>{ne.header&&extractOutputs(ne.header,A)});let z=0;const I=A.sort().map(ne=>ne.indexOf("builtin")>-1?ne:`@location(${z++}) ${ne}`).join(`,
`),L=A.sort().map(ne=>`       var ${stripVariable(ne)};`).join(`
`),K=`return VSOutput(
                ${A.sort().map(ne=>` ${extractVariableName(ne)}`).join(`,
`)});`;let te=C.replace(/@out\s+[^;]+;\s*/g,"");return te=te.replace("{{struct}}",`
${I}
`),te=te.replace("{{start}}",`
${L}
`),te=te.replace("{{return}}",`
${K}
`),te}function injectBits(O,C){let A=O;for(const z in C){const I=C[z];I.join(`
`).length?A=A.replace(`{{${z}}}`,`//-----${z} START-----//
${I.join(`
`)}
//----${z} FINISH----//`):A=A.replace(`{{${z}}}`,"")}return A}const cacheMap=Object.create(null),bitCacheMap=new Map;let CACHE_UID=0;function compileHighShader({template:O,bits:C}){const A=generateCacheId(O,C);if(cacheMap[A])return cacheMap[A];const{vertex:z,fragment:I}=compileInputsAndOutputs(O,C);return cacheMap[A]=compileBits(z,I,C),cacheMap[A]}function compileHighShaderGl({template:O,bits:C}){const A=generateCacheId(O,C);return cacheMap[A]||(cacheMap[A]=compileBits(O.vertex,O.fragment,C)),cacheMap[A]}function compileInputsAndOutputs(O,C){const A=C.map(K=>K.vertex).filter(K=>!!K),z=C.map(K=>K.fragment).filter(K=>!!K);let I=compileInputs(A,O.vertex,!0);I=compileOutputs(A,I);const L=compileInputs(z,O.fragment,!0);return{vertex:I,fragment:L}}function generateCacheId(O,C){return C.map(A=>(bitCacheMap.has(A)||bitCacheMap.set(A,CACHE_UID++),bitCacheMap.get(A))).sort((A,z)=>A-z).join("-")+O.vertex+O.fragment}function compileBits(O,C,A){const z=compileHooks(O),I=compileHooks(C);return A.forEach(L=>{addBits(L.vertex,z,L.name),addBits(L.fragment,I,L.name)}),{vertex:injectBits(O,z),fragment:injectBits(C,I)}}const vertexGPUTemplate=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,fragmentGPUTemplate=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`,vertexGlTemplate=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,fragmentGlTemplate=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`,globalUniformsBit={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function compileHighShaderGpuProgram({bits:O,name:C}){const A=compileHighShader({template:{fragment:fragmentGPUTemplate,vertex:vertexGPUTemplate},bits:[globalUniformsBit,...O]});return GpuProgram.from({name:C,vertex:{source:A.vertex,entryPoint:"main"},fragment:{source:A.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits:O,name:C}){return new GlProgram({name:C,...compileHighShaderGl({template:{vertex:vertexGlTemplate,fragment:fragmentGlTemplate},bits:[globalUniformsBitGl,...O]})})}const colorBit={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},colorBitGl={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},textureBatchBitGpuCache={};function generateBindingSrc(O){const C=[];if(O===1)C.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),C.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let A=0;for(let z=0;z<O;z++)C.push(`@group(1) @binding(${A++}) var textureSource${z+1}: texture_2d<f32>;`),C.push(`@group(1) @binding(${A++}) var textureSampler${z+1}: sampler;`)}return C.join(`
`)}function generateSampleSrc(O){const C=[];if(O===1)C.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{C.push("switch vTextureId {");for(let A=0;A<O;A++)A===O-1?C.push("  default:{"):C.push(`  case ${A}:{`),C.push(`      outColor = textureSampleGrad(textureSource${A+1}, textureSampler${A+1}, vUV, uvDx, uvDy);`),C.push("      break;}");C.push("}")}return C.join(`
`)}function generateTextureBatchBit(O){return textureBatchBitGpuCache[O]||(textureBatchBitGpuCache[O]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(O)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(O)}
            `}}),textureBatchBitGpuCache[O]}const textureBatchBitGlCache={};function generateSampleGlSrc(O){const C=[];for(let A=0;A<O;A++)A>0&&C.push("else"),A<O-1&&C.push(`if(vTextureId < ${A}.5)`),C.push("{"),C.push(`	outColor = texture(uTextures[${A}], vUV);`),C.push("}");return C.join(`
`)}function generateTextureBatchBitGl(O){return textureBatchBitGlCache[O]||(textureBatchBitGlCache[O]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${O}];

            `,main:`

                ${generateSampleGlSrc(O)}
            `}}),textureBatchBitGlCache[O]}const roundPixelsBit={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},batchSamplersUniformGroupHash={};function getBatchSamplersUniformGroup(O){let C=batchSamplersUniformGroupHash[O];if(C)return C;const A=new Int32Array(O);for(let z=0;z<O;z++)A[z]=z;return C=batchSamplersUniformGroupHash[O]=new UniformGroup({uTextures:{value:A,type:"i32",size:O}},{isStatic:!0}),C}const localUniformBit={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}};({...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}});const localUniformBitGl={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},canvasCache=new Map;function getCanvasTexture(O,C){if(!canvasCache.has(O)){const A=new Texture({source:new CanvasSource({resource:O,...C})}),z=()=>{canvasCache.get(O)===A&&canvasCache.delete(O)};A.once("destroy",z),A.source.once("destroy",z),canvasCache.set(O,A)}return canvasCache.get(O)}const _RenderTarget=class Qr{constructor(C={}){if(this.uid=uid("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,C={...Qr.defaultOptions,...C},this.stencil=C.stencil,this.depth=C.depth,this.isRoot=C.isRoot,typeof C.colorTextures=="number"){this._managedColorTextures=!0;for(let A=0;A<C.colorTextures;A++)this.colorTextures.push(new TextureSource({width:C.width,height:C.height,resolution:C.resolution,antialias:C.antialias}))}else{this.colorTextures=[...C.colorTextures.map(z=>z.source)];const A=this.colorTexture.source;this.resize(A.width,A.height,A._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(C.depthStencilTexture||this.stencil)&&(C.depthStencilTexture instanceof Texture||C.depthStencilTexture instanceof TextureSource?this.depthStencilTexture=C.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const C=this._size;return C[0]=this.pixelWidth,C[1]=this.pixelHeight,C}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(C){this.resize(C.width,C.height,C._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(C,A,z=this.resolution,I=!1){this.dirtyId++,this.colorTextures.forEach((L,K)=>{I&&K===0||L.source.resize(C,A,z)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(C,A,z)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(C=>{C.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};_RenderTarget.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let RenderTarget=_RenderTarget;class BatchableSprite{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(C,A,z,I){const L=this.renderable,K=this.texture,te=L.groupTransform,ne=te.a,ie=te.b,oe=te.c,ue=te.d,de=te.tx,he=te.ty,fe=this.bounds,be=fe.maxX,xe=fe.minX,Se=fe.maxY,Fe=fe.minY,Ce=K.uvs,Ge=L.groupColorAlpha,Ve=I<<16|this.roundPixels&65535;C[z+0]=ne*xe+oe*Fe+de,C[z+1]=ue*Fe+ie*xe+he,C[z+2]=Ce.x0,C[z+3]=Ce.y0,A[z+4]=Ge,A[z+5]=Ve,C[z+6]=ne*be+oe*Fe+de,C[z+7]=ue*Fe+ie*be+he,C[z+8]=Ce.x1,C[z+9]=Ce.y1,A[z+10]=Ge,A[z+11]=Ve,C[z+12]=ne*be+oe*Se+de,C[z+13]=ue*Se+ie*be+he,C[z+14]=Ce.x2,C[z+15]=Ce.y2,A[z+16]=Ge,A[z+17]=Ve,C[z+18]=ne*xe+oe*Se+de,C[z+19]=ue*Se+ie*xe+he,C[z+20]=Ce.x3,C[z+21]=Ce.y3,A[z+22]=Ge,A[z+23]=Ve}packIndex(C,A,z){C[A]=z+0,C[A+1]=z+1,C[A+2]=z+2,C[A+3]=z+0,C[A+4]=z+2,C[A+5]=z+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}function color32BitToUniform(O,C,A){const z=(O>>24&255)/255;C[A++]=(O&255)/255*z,C[A++]=(O>>8&255)/255*z,C[A++]=(O>>16&255)/255*z,C[A++]=z}const _ViewSystem=class en{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(C){this.texture.source.autoDensity=C}get resolution(){return this.texture.source._resolution}set resolution(C){this.texture.source.resize(this.texture.source.width,this.texture.source.height,C)}init(C){C={...en.defaultOptions,...C},C.view&&(deprecation(v8_0_0,"ViewSystem.view has been renamed to ViewSystem.canvas"),C.canvas=C.view),this.screen=new Rectangle(0,0,C.width,C.height),this.canvas=C.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!C.antialias,this.texture=getCanvasTexture(this.canvas,C),this.renderTarget=new RenderTarget({colorTextures:[this.texture],depth:!!C.depth,isRoot:!0}),this.texture.source.transparent=C.backgroundAlpha<1,this.multiView=!!C.multiView,this.resolution=C.resolution}resize(C,A,z){this.texture.source.resize(C,A,z),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(C=!1){(typeof C=="boolean"?C:!!(C!=null&&C.removeView))&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};_ViewSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"view",priority:0},_ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};let ViewSystem=_ViewSystem;class GraphicsPipe{constructor(C,A){this.state=State.for2d(),this._graphicsBatchesHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=C,this._adaptor=A,this._adaptor.init()}validateRenderable(C){const A=C.context,z=!!this._graphicsBatchesHash[C.uid],I=this.renderer.graphicsContext.updateGpuContext(A);return!!(I.isBatchable||z!==I.isBatchable)}addRenderable(C,A){const z=this.renderer.graphicsContext.updateGpuContext(C.context);C._didGraphicsUpdate&&(C._didGraphicsUpdate=!1,this._rebuild(C)),z.isBatchable?this._addToBatcher(C):(this.renderer.renderPipes.batch.break(A),A.add(C))}updateRenderable(C){const A=this._graphicsBatchesHash[C.uid];if(A)for(let z=0;z<A.length;z++){const I=A[z];I.batcher.updateElement(I)}}destroyRenderable(C){this._graphicsBatchesHash[C.uid]&&this._removeBatchForRenderable(C.uid),C.off("destroyed",this._destroyRenderableBound)}execute(C){if(!C.isRenderable)return;const A=this.renderer,z=C.context;if(!A.graphicsContext.getGpuContext(z).batches.length)return;const L=z.customShader||this._adaptor.shader;this.state.blendMode=C.groupBlendMode;const K=L.resources.localUniforms.uniforms;K.uTransformMatrix=C.groupTransform,K.uRound=A._roundPixels|C._roundPixels,color32BitToUniform(C.groupColorAlpha,K.uColor,0),this._adaptor.execute(this,C)}_rebuild(C){const A=!!this._graphicsBatchesHash[C.uid],z=this.renderer.graphicsContext.updateGpuContext(C.context);A&&this._removeBatchForRenderable(C.uid),z.isBatchable&&this._initBatchesForRenderable(C),C.batched=z.isBatchable}_addToBatcher(C){const A=this.renderer.renderPipes.batch,z=this._getBatchesForRenderable(C);for(let I=0;I<z.length;I++){const L=z[I];A.addToBatch(L)}}_getBatchesForRenderable(C){return this._graphicsBatchesHash[C.uid]||this._initBatchesForRenderable(C)}_initBatchesForRenderable(C){const A=C.context,z=this.renderer.graphicsContext.getGpuContext(A),I=this.renderer._roundPixels|C._roundPixels,L=z.batches.map(K=>{const te=BigPool.get(BatchableGraphics);return K.copyTo(te),te.renderable=C,te.roundPixels=I,te});return this._graphicsBatchesHash[C.uid]===void 0&&C.on("destroyed",this._destroyRenderableBound),this._graphicsBatchesHash[C.uid]=L,L}_removeBatchForRenderable(C){this._graphicsBatchesHash[C].forEach(A=>{BigPool.return(A)}),this._graphicsBatchesHash[C]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const C in this._graphicsBatchesHash)this._removeBatchForRenderable(C);this._graphicsBatchesHash=null}}GraphicsPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"graphics"};const _PlaneGeometry=class tn extends MeshGeometry{constructor(...C){var z;super({});let A=(z=C[0])!=null?z:{};typeof A=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),A={width:A,height:C[1],verticesX:C[2],verticesY:C[3]}),this.build(A)}build(C){var ue,de,he,fe;C={...tn.defaultOptions,...C},this.verticesX=(ue=this.verticesX)!=null?ue:C.verticesX,this.verticesY=(de=this.verticesY)!=null?de:C.verticesY,this.width=(he=this.width)!=null?he:C.width,this.height=(fe=this.height)!=null?fe:C.height;const A=this.verticesX*this.verticesY,z=[],I=[],L=[],K=this.verticesX-1,te=this.verticesY-1,ne=this.width/K,ie=this.height/te;for(let be=0;be<A;be++){const xe=be%this.verticesX,Se=be/this.verticesX|0;z.push(xe*ne,Se*ie),I.push(xe/K,Se/te)}const oe=K*te;for(let be=0;be<oe;be++){const xe=be%K,Se=be/K|0,Fe=Se*this.verticesX+xe,Ce=Se*this.verticesX+xe+1,Ge=(Se+1)*this.verticesX+xe,Ve=(Se+1)*this.verticesX+xe+1;L.push(Fe,Ce,Ge,Ce,Ve,Ge)}this.buffers[0].data=new Float32Array(z),this.buffers[1].data=new Float32Array(I),this.indexBuffer.data=new Uint32Array(L),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;class BatchableMesh{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}get blendMode(){return this.mesh.groupBlendMode}reset(){this.mesh=null,this.texture=null,this.batcher=null,this.batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}packIndex(C,A,z){const I=this.geometry.indices;for(let L=0;L<I.length;L++)C[A++]=I[L]+z}packAttributes(C,A,z,I){const L=this.mesh,K=this.geometry,te=L.groupTransform,ne=I<<16|this.roundPixels&65535,ie=te.a,oe=te.b,ue=te.c,de=te.d,he=te.tx,fe=te.ty,be=K.positions,xe=K.getBuffer("aUV"),Se=xe.data;let Fe=Se;const Ce=this.texture.textureMatrix;Ce.isSimple||(Fe=this._transformedUvs,(this._textureMatrixUpdateId!==Ce._updateID||this._uvUpdateId!==xe._updateID)&&((!Fe||Fe.length<Se.length)&&(Fe=this._transformedUvs=new Float32Array(Se.length)),this._textureMatrixUpdateId=Ce._updateID,this._uvUpdateId=xe._updateID,Ce.multiplyUvs(Se,Fe)));const Ge=L.groupColorAlpha;for(let Ve=0;Ve<be.length;Ve+=2){const pt=be[Ve],Ze=be[Ve+1];C[z]=ie*pt+ue*Ze+he,C[z+1]=oe*pt+de*Ze+fe,C[z+2]=Fe[Ve],C[z+3]=Fe[Ve+1],A[z+4]=Ge,A[z+5]=ne,z+=6}}get vertexSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class MeshPipe{constructor(C,A){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=C,this._adaptor=A,this._adaptor.init()}validateRenderable(C){const A=this._getMeshData(C),z=A.batched,I=C.batched;if(A.batched=I,z!==I)return!0;if(I){const L=C._geometry;if(L.indices.length!==A.indexSize||L.positions.length!==A.vertexSize)return A.indexSize=L.indices.length,A.vertexSize=L.positions.length,!0;const K=this._getBatchableMesh(C),te=C.texture;if(K.texture._source!==te._source&&K.texture._source!==te._source)return!K.batcher.checkAndUpdateTexture(K,te)}return!1}addRenderable(C,A){const z=this.renderer.renderPipes.batch,{batched:I}=this._getMeshData(C);if(I){const L=this._getBatchableMesh(C);L.texture=C._texture,L.geometry=C._geometry,z.addToBatch(L)}else z.break(A),A.add(C)}updateRenderable(C){if(C.batched){const A=this._gpuBatchableMeshHash[C.uid];A.texture=C._texture,A.geometry=C._geometry,A.batcher.updateElement(A)}}destroyRenderable(C){this._meshDataHash[C.uid]=null;const A=this._gpuBatchableMeshHash[C.uid];A&&(BigPool.return(A),this._gpuBatchableMeshHash[C.uid]=null),C.off("destroyed",this._destroyRenderableBound)}execute(C){if(!C.isRenderable)return;C.state.blendMode=getAdjustedBlendModeBlend(C.groupBlendMode,C.texture._source);const A=this.localUniforms;A.uniforms.uTransformMatrix=C.groupTransform,A.uniforms.uRound=this.renderer._roundPixels|C._roundPixels,A.update(),color32BitToUniform(C.groupColorAlpha,A.uniforms.uColor,0),this._adaptor.execute(this,C)}_getMeshData(C){return this._meshDataHash[C.uid]||this._initMeshData(C)}_initMeshData(C){var A,z;return this._meshDataHash[C.uid]={batched:C.batched,indexSize:(A=C._geometry.indices)==null?void 0:A.length,vertexSize:(z=C._geometry.positions)==null?void 0:z.length},C.on("destroyed",this._destroyRenderableBound),this._meshDataHash[C.uid]}_getBatchableMesh(C){return this._gpuBatchableMeshHash[C.uid]||this._initBatchableMesh(C)}_initBatchableMesh(C){const A=BigPool.get(BatchableMesh);return A.mesh=C,A.texture=C._texture,A.roundPixels=this.renderer._roundPixels|C._roundPixels,this._gpuBatchableMeshHash[C.uid]=A,A.mesh=C,A}destroy(){for(const C in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[C]&&BigPool.return(this._gpuBatchableMeshHash[C]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"mesh"};const _NineSliceGeometry=class rn extends PlaneGeometry{constructor(C={}){C={...rn.defaultOptions,...C},super({width:C.width,height:C.height,verticesX:4,verticesY:4}),this.update(C)}update(C){var A,z,I,L,K,te,ne,ie;this.width=(A=C.width)!=null?A:this.width,this.height=(z=C.height)!=null?z:this.height,this._originalWidth=(I=C.originalWidth)!=null?I:this._originalWidth,this._originalHeight=(L=C.originalHeight)!=null?L:this._originalHeight,this._leftWidth=(K=C.leftWidth)!=null?K:this._leftWidth,this._rightWidth=(te=C.rightWidth)!=null?te:this._rightWidth,this._topHeight=(ne=C.topHeight)!=null?ne:this._topHeight,this._bottomHeight=(ie=C.bottomHeight)!=null?ie:this._bottomHeight,this.updateUvs(),this.updatePositions()}updatePositions(){const C=this.positions,A=this._leftWidth+this._rightWidth,z=this.width>A?1:this.width/A,I=this._topHeight+this._bottomHeight,L=this.height>I?1:this.height/I,K=Math.min(z,L);C[9]=C[11]=C[13]=C[15]=this._topHeight*K,C[17]=C[19]=C[21]=C[23]=this.height-this._bottomHeight*K,C[25]=C[27]=C[29]=C[31]=this.height,C[2]=C[10]=C[18]=C[26]=this._leftWidth*K,C[4]=C[12]=C[20]=C[28]=this.width-this._rightWidth*K,C[6]=C[14]=C[22]=C[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(){const C=this.uvs;C[0]=C[8]=C[16]=C[24]=0,C[1]=C[3]=C[5]=C[7]=0,C[6]=C[14]=C[22]=C[30]=1,C[25]=C[27]=C[29]=C[31]=1;const A=1/this._originalWidth,z=1/this._originalHeight;C[2]=C[10]=C[18]=C[26]=A*this._leftWidth,C[9]=C[11]=C[13]=C[15]=z*this._topHeight,C[4]=C[12]=C[20]=C[28]=1-A*this._rightWidth,C[17]=C[19]=C[21]=C[23]=1-z*this._bottomHeight,this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpritePipe{constructor(C){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=C}addRenderable(C,A){const z=this._getGpuSprite(C);C._didSpriteUpdate&&this._updateBatchableSprite(C,z),this._renderer.renderPipes.batch.addToBatch(z)}updateRenderable(C){const A=this._gpuSpriteHash[C.uid];C._didSpriteUpdate&&this._updateBatchableSprite(C,A),A.batcher.updateElement(A)}validateRenderable(C){const A=C._texture,z=this._getGpuSprite(C);return z.texture._source!==A._source?!z.batcher.checkAndUpdateTexture(z,A):!1}destroyRenderable(C){const A=this._gpuSpriteHash[C.uid];BigPool.return(A.geometry),BigPool.return(A),this._gpuSpriteHash[C.uid]=null,C.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(C,A){C._didSpriteUpdate=!1,A.geometry.update(C),A.texture=C._texture}_getGpuSprite(C){return this._gpuSpriteHash[C.uid]||this._initGPUSprite(C)}_initGPUSprite(C){const A=BigPool.get(BatchableMesh);return A.geometry=BigPool.get(NineSliceGeometry),A.mesh=C,A.texture=C._texture,A.roundPixels=this._renderer._roundPixels|C._roundPixels,C._didSpriteUpdate=!0,this._gpuSpriteHash[C.uid]=A,C.on("destroyed",this._destroyRenderableBound),A}destroy(){for(const C in this._gpuSpriteHash)this._gpuSpriteHash[C].geometry.destroy();this._gpuSpriteHash=null,this._renderer=null}}NineSliceSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"nineSliceSprite"};const tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}};let gpuProgram$1,glProgram$1;class TilingSpriteShader extends Shader{constructor(){gpuProgram$1!=null||(gpuProgram$1=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]})),glProgram$1!=null||(glProgram$1=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}));const C=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:glProgram$1,gpuProgram:gpuProgram$1,resources:{localUniforms:new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:C,uTexture:Texture.EMPTY.source,uSampler:Texture.EMPTY.source.style}})}updateUniforms(C,A,z,I,L,K){const te=this.resources.tilingUniforms,ne=K.width,ie=K.height,oe=K.textureMatrix,ue=te.uniforms.uTextureTransform;ue.set(z.a*ne/C,z.b*ne/A,z.c*ie/C,z.d*ie/A,z.tx/C,z.ty/A),ue.invert(),te.uniforms.uMapCoord=oe.mapCoord,te.uniforms.uClampFrame=oe.uClampFrame,te.uniforms.uClampOffset=oe.uClampOffset,te.uniforms.uTextureTransform=ue,te.uniforms.uSizeAnchor[0]=C,te.uniforms.uSizeAnchor[1]=A,te.uniforms.uSizeAnchor[2]=I,te.uniforms.uSizeAnchor[3]=L,K&&(this.resources.uTexture=K.source,this.resources.uSampler=K.source.style)}}class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function setPositions(O,C){const A=O.anchor.x,z=O.anchor.y;C[0]=-A*O.width,C[1]=-z*O.height,C[2]=(1-A)*O.width,C[3]=-z*O.height,C[4]=(1-A)*O.width,C[5]=(1-z)*O.height,C[6]=-A*O.width,C[7]=(1-z)*O.height}function applyMatrix(O,C,A,z){let I=0;const L=O.length/(C||2),K=z.a,te=z.b,ne=z.c,ie=z.d,oe=z.tx,ue=z.ty;for(A*=C;I<L;){const de=O[A],he=O[A+1];O[A]=K*de+ne*he+oe,O[A+1]=te*de+ie*he+ue,A+=C,I++}}function setUvs(O,C){const A=O.texture,z=A.frame.width,I=A.frame.height;let L=0,K=0;O._applyAnchorToTexture&&(L=O.anchor.x,K=O.anchor.y),C[0]=C[6]=-L,C[2]=C[4]=1-L,C[1]=C[3]=-K,C[5]=C[7]=1-K;const te=Matrix.shared;te.copyFrom(O._tileTransform.matrix),te.tx/=O.width,te.ty/=O.height,te.invert(),te.scale(O.width/z,O.height/I),applyMatrix(C,2,0,te)}const sharedQuad=new QuadGeometry;class TilingSpritePipe{constructor(C){this._state=State.default2d,this._tilingSpriteDataHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=C}validateRenderable(C){const A=this._getTilingSpriteData(C),z=A.canBatch;this._updateCanBatch(C);const I=A.canBatch;if(I&&I===z){const{batchableMesh:L}=A;if(L&&L.texture._source!==C.texture._source)return!L.batcher.checkAndUpdateTexture(L,C.texture)}return z!==I}addRenderable(C,A){const z=this._renderer.renderPipes.batch;this._updateCanBatch(C);const I=this._getTilingSpriteData(C),{geometry:L,canBatch:K}=I;if(K){I.batchableMesh||(I.batchableMesh=new BatchableMesh);const te=I.batchableMesh;C._didTilingSpriteUpdate&&(C._didTilingSpriteUpdate=!1,this._updateBatchableMesh(C),te.geometry=L,te.mesh=C,te.texture=C._texture),te.roundPixels=this._renderer._roundPixels|C._roundPixels,z.addToBatch(te)}else z.break(A),I.shader||(I.shader=new TilingSpriteShader),this.updateRenderable(C),A.add(C)}execute(C){const{shader:A}=this._tilingSpriteDataHash[C.uid];A.groups[0]=this._renderer.globalUniforms.bindGroup;const z=A.resources.localUniforms.uniforms;z.uTransformMatrix=C.groupTransform,z.uRound=this._renderer._roundPixels|C._roundPixels,color32BitToUniform(C.groupColorAlpha,z.uColor,0),this._state.blendMode=getAdjustedBlendModeBlend(C.groupBlendMode,C.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader:A,state:this._state})}updateRenderable(C){const A=this._getTilingSpriteData(C),{canBatch:z}=A;if(z){const{batchableMesh:I}=A;C._didTilingSpriteUpdate&&this._updateBatchableMesh(C),I.batcher.updateElement(I)}else if(C._didTilingSpriteUpdate){const{shader:I}=A;I.updateUniforms(C.width,C.height,C._tileTransform.matrix,C.anchor.x,C.anchor.y,C.texture)}C._didTilingSpriteUpdate=!1}destroyRenderable(C){var z;const A=this._getTilingSpriteData(C);A.batchableMesh=null,(z=A.shader)==null||z.destroy(),this._tilingSpriteDataHash[C.uid]=null,C.off("destroyed",this._destroyRenderableBound)}_getTilingSpriteData(C){return this._tilingSpriteDataHash[C.uid]||this._initTilingSpriteData(C)}_initTilingSpriteData(C){const A=new MeshGeometry({indices:sharedQuad.indices,positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()});return this._tilingSpriteDataHash[C.uid]={canBatch:!0,renderable:C,geometry:A},C.on("destroyed",this._destroyRenderableBound),this._tilingSpriteDataHash[C.uid]}_updateBatchableMesh(C){const A=this._getTilingSpriteData(C),{geometry:z}=A,I=C.texture.source.style;I.addressMode!=="repeat"&&(I.addressMode="repeat",I.update()),setUvs(C,z.uvs),setPositions(C,z.positions)}destroy(){for(const C in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[C].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(C){const A=this._getTilingSpriteData(C),z=C.texture;let I=!0;return this._renderer.type===RendererType.WEBGL&&(I=this._renderer.context.supports.nonPowOf2wrapping),A.canBatch=z.textureMatrix.isSimple&&(I||z.source.isPowerOfTwo),A.canBatch}}TilingSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"tilingSprite"};const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `}};let gpuProgram,glProgram;class SdfShader extends Shader{constructor(){const C=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),A=getMaxTexturesPerBatch();gpuProgram!=null||(gpuProgram=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(A),localUniformMSDFBit,mSDFBit,roundPixelsBit]})),glProgram!=null||(glProgram=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(A),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]})),super({glProgram,gpuProgram,resources:{localUniforms:C,batchSamplers:getBatchSamplersUniformGroup(A)}})}}class BitmapTextPipe{constructor(C){this._gpuBitmapText={},this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=C}validateRenderable(C){const A=this._getGpuBitmapText(C);return C._didTextUpdate&&(C._didTextUpdate=!1,this._updateContext(C,A)),this._renderer.renderPipes.graphics.validateRenderable(A)}addRenderable(C,A){const z=this._getGpuBitmapText(C);syncWithProxy(C,z),C._didTextUpdate&&(C._didTextUpdate=!1,this._updateContext(C,z)),this._renderer.renderPipes.graphics.addRenderable(z,A),z.context.customShader&&this._updateDistanceField(C)}destroyRenderable(C){C.off("destroyed",this._destroyRenderableBound),this._destroyRenderableByUid(C.uid)}_destroyRenderableByUid(C){const A=this._gpuBitmapText[C].context;A.customShader&&(BigPool.return(A.customShader),A.customShader=null),BigPool.return(this._gpuBitmapText[C]),this._gpuBitmapText[C]=null}updateRenderable(C){const A=this._getGpuBitmapText(C);syncWithProxy(C,A),this._renderer.renderPipes.graphics.updateRenderable(A),A.context.customShader&&this._updateDistanceField(C)}_updateContext(C,A){const{context:z}=A,I=BitmapFontManager.getFont(C.text,C._style);z.clear(),I.distanceField.type!=="none"&&(z.customShader||(z.customShader=BigPool.get(SdfShader)));const L=Array.from(C.text),K=C._style;let te=I.baseLineOffset;const ne=getBitmapTextLayout(L,K,I);let ie=0;const oe=K.padding,ue=ne.scale;let de=ne.width,he=ne.height+ne.offsetY;K._stroke&&(de+=K._stroke.width/ue,he+=K._stroke.width/ue),z.translate(-C._anchor._x*de-oe,-C._anchor._y*he-oe).scale(ue,ue);const fe=I.applyFillAsTint?K._fill.color:16777215;for(let be=0;be<ne.lines.length;be++){const xe=ne.lines[be];for(let Se=0;Se<xe.charPositions.length;Se++){const Fe=L[ie++],Ce=I.chars[Fe];Ce!=null&&Ce.texture&&z.texture(Ce.texture,fe||"black",Math.round(xe.charPositions[Se]+Ce.xOffset),Math.round(te+Ce.yOffset))}te+=I.lineHeight}}_getGpuBitmapText(C){return this._gpuBitmapText[C.uid]||this.initGpuText(C)}initGpuText(C){const A=BigPool.get(Graphics);return this._gpuBitmapText[C.uid]=A,this._updateContext(C,A),C.on("destroyed",this._destroyRenderableBound),this._gpuBitmapText[C.uid]}_updateDistanceField(C){const A=this._getGpuBitmapText(C).context,z=C._style.fontFamily,I=Cache.get(`${z}-bitmap`),{a:L,b:K,c:te,d:ne}=C.groupTransform,ie=Math.sqrt(L*L+K*K),oe=Math.sqrt(te*te+ne*ne),ue=(Math.abs(ie)+Math.abs(oe))/2,de=I.baseRenderedFontSize/C._style.fontSize,he=ue*I.distanceField.range*(1/de);A.customShader.resources.localUniforms.uniforms.uDistance=he}destroy(){for(const C in this._gpuBitmapText)this._destroyRenderableByUid(C);this._gpuBitmapText=null,this._renderer=null}}BitmapTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"bitmapText"};function syncWithProxy(O,C){C.groupTransform=O.groupTransform,C.groupColorAlpha=O.groupColorAlpha,C.groupColor=O.groupColor,C.groupBlendMode=O.groupBlendMode,C.globalDisplayStatus=O.globalDisplayStatus,C.groupTransform=O.groupTransform,C.localDisplayStatus=O.localDisplayStatus,C.groupAlpha=O.groupAlpha,C._roundPixels=O._roundPixels}class HTMLTextPipe{constructor(C){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=C,this._renderer.runners.resolutionChange.add(this)}resolutionChange(){for(const C in this._gpuText){const z=this._gpuText[C].batchableSprite.renderable;z._autoResolution&&(z._resolution=this._renderer.resolution,z.onViewUpdate())}}validateRenderable(C){const A=this._getGpuText(C),z=C._getKey();return A.textureNeedsUploading?(A.textureNeedsUploading=!1,!0):A.currentKey!==z}addRenderable(C,A){const I=this._getGpuText(C).batchableSprite;C._didTextUpdate&&this._updateText(C),this._renderer.renderPipes.batch.addToBatch(I)}updateRenderable(C){const z=this._getGpuText(C).batchableSprite;C._didTextUpdate&&this._updateText(C),z.batcher.updateElement(z)}destroyRenderable(C){C.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(C.uid)}_destroyRenderableById(C){const A=this._gpuText[C];this._renderer.htmlText.decreaseReferenceCount(A.currentKey),BigPool.return(A.batchableSprite),this._gpuText[C]=null}_updateText(C){const A=C._getKey(),z=this._getGpuText(C),I=z.batchableSprite;z.currentKey!==A&&this._updateGpuText(C).catch(K=>{console.error(K)}),C._didTextUpdate=!1;const L=C._style.padding;updateQuadBounds(I.bounds,C._anchor,I.texture,L)}async _updateGpuText(C){var ne;C._didTextUpdate=!1;const A=this._getGpuText(C);if(A.generatingTexture)return;const z=C._getKey();this._renderer.htmlText.decreaseReferenceCount(A.currentKey),A.generatingTexture=!0,A.currentKey=z;const I=(ne=C.resolution)!=null?ne:this._renderer.resolution,L=await this._renderer.htmlText.getManagedTexture(C.text,I,C._style,C._getKey()),K=A.batchableSprite;K.texture=A.texture=L,A.generatingTexture=!1,A.textureNeedsUploading=!0,C.onViewUpdate();const te=C._style.padding;updateQuadBounds(K.bounds,C._anchor,K.texture,te)}_getGpuText(C){return this._gpuText[C.uid]||this.initGpuText(C)}initGpuText(C){const A={texture:Texture.EMPTY,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite),textureNeedsUploading:!1,generatingTexture:!1},z=A.batchableSprite;return z.renderable=C,z.texture=Texture.EMPTY,z.bounds={minX:0,maxX:1,minY:0,maxY:0},z.roundPixels=this._renderer._roundPixels|C._roundPixels,C._resolution=C._autoResolution?this._renderer.resolution:C.resolution,this._gpuText[C.uid]=A,C.on("destroyed",this._destroyRenderableBound),A}destroy(){for(const C in this._gpuText)this._destroyRenderableById(C);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent:O}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(O)}const tempBounds=new Bounds;function getPo2TextureFromSource(O,C,A,z){const I=tempBounds;I.minX=0,I.minY=0,I.maxX=O.width/z|0,I.maxY=O.height/z|0;const L=TexturePool.getOptimalTexture(I.width,I.height,z,!1);return L.source.uploadMethodId="image",L.source.resource=O,L.source.alphaMode="premultiply-alpha-on-upload",L.frame.width=C/z,L.frame.height=A/z,L.source.emit("update",L.source),L.updateUvs(),L}function extractFontFamilies(O,C){const A=C.fontFamily,z=[],I={},L=/font-family:([^;"\s]+)/g,K=O.match(L);function te(ne){I[ne]||(z.push(ne),I[ne]=!0)}if(Array.isArray(A))for(let ne=0;ne<A.length;ne++)te(A[ne]);else te(A);K&&K.forEach(ne=>{const ie=ne.split(":")[1].trim();te(ie)});for(const ne in C.tagStyles){const ie=C.tagStyles[ne].fontFamily;te(ie)}return z}async function loadFontAsBase64(O){const A=await(await DOMAdapter.get().fetch(O)).blob(),z=new FileReader;return await new Promise((L,K)=>{z.onloadend=()=>L(z.result),z.onerror=K,z.readAsDataURL(A)})}async function loadFontCSS(O,C){const A=await loadFontAsBase64(C);return`@font-face {
        font-family: "${O.fontFamily}";
        src: url('${A}');
        font-weight: ${O.fontWeight};
        font-style: ${O.fontStyle};
    }`}const FontStylePromiseCache=new Map;async function getFontCss(O,C,A){const z=O.filter(I=>Cache.has(`${I}-and-url`)).map((I,L)=>{if(!FontStylePromiseCache.has(I)){const{url:K}=Cache.get(`${I}-and-url`);L===0?FontStylePromiseCache.set(I,loadFontCSS({fontWeight:C.fontWeight,fontStyle:C.fontStyle,fontFamily:I},K)):FontStylePromiseCache.set(I,loadFontCSS({fontWeight:A.fontWeight,fontStyle:A.fontStyle,fontFamily:I},K))}return FontStylePromiseCache.get(I)});return(await Promise.all(z)).join(`
`)}function getSVGUrl(O,C,A,z,I){const{domElement:L,styleElement:K,svgRoot:te}=I;L.innerHTML=`<style>${C.cssStyle}</style><div style='padding:0;'>${O}</div>`,L.setAttribute("style",`transform: scale(${A});transform-origin: top left; display: inline-block`),K.textContent=z;const{width:ne,height:ie}=I.image;return te.setAttribute("width",ne.toString()),te.setAttribute("height",ie.toString()),new XMLSerializer().serializeToString(te)}function getTemporaryCanvasFromImage(O,C){const A=CanvasPool.getOptimalCanvasAndContext(O.width,O.height,C),{context:z}=A;return z.clearRect(0,0,O.width,O.height),z.drawImage(O,0,0),CanvasPool.returnCanvasAndContext(A),A.canvas}function loadSVGImage(O,C,A){return new Promise(async z=>{A&&await new Promise(I=>setTimeout(I,100)),O.onload=()=>{z()},O.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(C)}`,O.crossOrigin="anonymous"})}class HTMLTextSystem{constructor(C){this._activeTextures={},this._renderer=C,this._createCanvas=C.type===RendererType.WEBGPU}getTexture(C){return this._buildTexturePromise(C.text,C.resolution,C.style)}getManagedTexture(C,A,z,I){if(this._activeTextures[I])return this._increaseReferenceCount(I),this._activeTextures[I].promise;const L=this._buildTexturePromise(C,A,z).then(K=>(this._activeTextures[I].texture=K,K));return this._activeTextures[I]={texture:null,promise:L,usageCount:1},L}async _buildTexturePromise(C,A,z){const I=BigPool.get(HTMLTextRenderData),L=extractFontFamilies(C,z),K=await getFontCss(L,z,HTMLTextStyle.defaultTextStyle),te=measureHtmlText(C,z,K,I),ne=Math.ceil(Math.ceil(Math.max(1,te.width)+z.padding*2)*A),ie=Math.ceil(Math.ceil(Math.max(1,te.height)+z.padding*2)*A),oe=I.image,ue=2;oe.width=(ne|0)+ue,oe.height=(ie|0)+ue;const de=getSVGUrl(C,z,A,K,I);await loadSVGImage(oe,de,isSafari()&&L.length>0);let he=oe;this._createCanvas&&(he=getTemporaryCanvasFromImage(oe,A));const fe=getPo2TextureFromSource(he,oe.width-ue,oe.height-ue,A);return this._createCanvas&&this._renderer.texture.initSource(fe.source),BigPool.return(I),fe}_increaseReferenceCount(C){this._activeTextures[C].usageCount++}decreaseReferenceCount(C){const A=this._activeTextures[C];!A||(A.usageCount--,A.usageCount===0&&(A.texture?this._cleanUp(A):A.promise.then(z=>{A.texture=z,this._cleanUp(A)}).catch(()=>{warn("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[C]=null))}_cleanUp(C){TexturePool.returnTexture(C.texture),C.texture.source.resource=null,C.texture.source.uploadMethodId="unknown"}getReferenceCount(C){return this._activeTextures[C].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"htmlText"},HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class CanvasTextPipe{constructor(C){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=C,this._renderer.runners.resolutionChange.add(this)}resolutionChange(){for(const C in this._gpuText){const z=this._gpuText[C].batchableSprite.renderable;z._autoResolution&&(z._resolution=this._renderer.resolution,z.onViewUpdate())}}validateRenderable(C){const A=this._getGpuText(C),z=C._getKey();if(A.currentKey!==z){const{width:I,height:L}=this._renderer.canvasText.getTextureSize(C.text,C.resolution,C._style);return!(this._renderer.canvasText.getReferenceCount(A.currentKey)===1&&I===A.texture._source.width&&L===A.texture._source.height)}return!1}addRenderable(C,A){const I=this._getGpuText(C).batchableSprite;C._didTextUpdate&&this._updateText(C),this._renderer.renderPipes.batch.addToBatch(I)}updateRenderable(C){const z=this._getGpuText(C).batchableSprite;C._didTextUpdate&&this._updateText(C),z.batcher.updateElement(z)}destroyRenderable(C){C.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(C.uid)}_destroyRenderableById(C){const A=this._gpuText[C];this._renderer.canvasText.decreaseReferenceCount(A.currentKey),BigPool.return(A.batchableSprite),this._gpuText[C]=null}_updateText(C){const A=C._getKey(),z=this._getGpuText(C),I=z.batchableSprite;z.currentKey!==A&&this._updateGpuText(C),C._didTextUpdate=!1;const L=C._style.padding;updateQuadBounds(I.bounds,C._anchor,I.texture,L)}_updateGpuText(C){const A=this._getGpuText(C),z=A.batchableSprite;A.texture&&this._renderer.canvasText.decreaseReferenceCount(A.currentKey),A.texture=z.texture=this._renderer.canvasText.getManagedTexture(C),A.currentKey=C._getKey(),z.texture=A.texture}_getGpuText(C){return this._gpuText[C.uid]||this.initGpuText(C)}initGpuText(C){const A={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return A.batchableSprite.renderable=C,A.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},A.batchableSprite.roundPixels=this._renderer._roundPixels|C._roundPixels,this._gpuText[C.uid]=A,C._resolution=C._autoResolution?this._renderer.resolution:C.resolution,this._updateText(C),C.on("destroyed",this._destroyRenderableBound),A}destroy(){for(const C in this._gpuText)this._destroyRenderableById(C);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"text"};function checkRow(O,C,A){for(let z=0,I=4*A*C;z<C;++z,I+=4)if(O[I+3]!==0)return!1;return!0}function checkColumn(O,C,A,z,I){const L=4*C;for(let K=z,te=z*L+4*A;K<=I;++K,te+=L)if(O[te+3]!==0)return!1;return!0}function getCanvasBoundingBox(O,C=1){const{width:A,height:z}=O,I=O.getContext("2d",{willReadFrequently:!0});if(I===null)throw new TypeError("Failed to get canvas 2D context");const K=I.getImageData(0,0,A,z).data;let te=0,ne=0,ie=A-1,oe=z-1;for(;ne<z&&checkRow(K,A,ne);)++ne;if(ne===z)return Rectangle.EMPTY;for(;checkRow(K,A,oe);)--oe;for(;checkColumn(K,A,te,ne,oe);)++te;for(;checkColumn(K,A,ie,ne,oe);)--ie;return++ie,++oe,new Rectangle(te/C,ne/C,(ie-te)/C,(oe-ne)/C)}class CanvasTextSystem{constructor(C){this._activeTextures={},this._renderer=C}getTextureSize(C,A,z){const I=CanvasTextMetrics.measureText(C||" ",z);let L=Math.ceil(Math.ceil(Math.max(1,I.width)+z.padding*2)*A),K=Math.ceil(Math.ceil(Math.max(1,I.height)+z.padding*2)*A);return L=Math.ceil(L-1e-6),K=Math.ceil(K-1e-6),L=nextPow2(L),K=nextPow2(K),{width:L,height:K}}getTexture(C,A,z,I){typeof C=="string"&&(deprecation("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),C={text:C,style:z,resolution:A}),C.style instanceof TextStyle||(C.style=new TextStyle(C.style));const{texture:L,canvasAndContext:K}=this.createTextureAndCanvas(C);return this._renderer.texture.initSource(L._source),CanvasPool.returnCanvasAndContext(K),L}createTextureAndCanvas(C){var ue;const{text:A,style:z}=C,I=(ue=C.resolution)!=null?ue:this._renderer.resolution,L=CanvasTextMetrics.measureText(A||" ",z),K=Math.ceil(Math.ceil(Math.max(1,L.width)+z.padding*2)*I),te=Math.ceil(Math.ceil(Math.max(1,L.height)+z.padding*2)*I),ne=CanvasPool.getOptimalCanvasAndContext(K,te),{canvas:ie}=ne;this.renderTextToCanvas(A,z,I,ne);const oe=getPo2TextureFromSource(ie,K,te,I);if(z.trim){const de=getCanvasBoundingBox(ie,I);oe.frame.copyFrom(de),oe.updateUvs()}return{texture:oe,canvasAndContext:ne}}getManagedTexture(C){C._resolution=C._autoResolution?this._renderer.resolution:C.resolution;const A=C._getKey();if(this._activeTextures[A])return this._increaseReferenceCount(A),this._activeTextures[A].texture;const{texture:z,canvasAndContext:I}=this.createTextureAndCanvas(C);return this._activeTextures[A]={canvasAndContext:I,texture:z,usageCount:1},z}_increaseReferenceCount(C){this._activeTextures[C].usageCount++}decreaseReferenceCount(C){const A=this._activeTextures[C];if(A.usageCount--,A.usageCount===0){CanvasPool.returnCanvasAndContext(A.canvasAndContext),TexturePool.returnTexture(A.texture);const z=A.texture.source;z.resource=null,z.uploadMethodId="unknown",z.alphaMode="no-premultiply-alpha",this._activeTextures[C]=null}}getReferenceCount(C){return this._activeTextures[C].usageCount}renderTextToCanvas(C,A,z,I){var Ce,Ge,Ve,pt,Ze,ct,Xe;const{canvas:L,context:K}=I,te=fontStringFromTextStyle(A),ne=CanvasTextMetrics.measureText(C||" ",A),ie=ne.lines,oe=ne.lineHeight,ue=ne.lineWidths,de=ne.maxLineWidth,he=ne.fontProperties,fe=L.height;K.resetTransform(),K.scale(z,z);const be=A.padding*2;if(K.clearRect(0,0,ne.width+4+be,ne.height+4+be),(Ce=A._stroke)!=null&&Ce.width){const We=A._stroke;K.lineWidth=We.width,K.miterLimit=We.miterLimit,K.lineJoin=We.join,K.lineCap=We.cap}K.font=te;let xe,Se;const Fe=A.dropShadow?2:1;for(let We=0;We<Fe;++We){const Mt=A.dropShadow&&We===0,jt=Mt?Math.ceil(Math.max(1,fe)+A.padding*2):0,At=jt*z;if(Mt){K.fillStyle="black",K.strokeStyle="black";const zt=A.dropShadow,xt=zt.color,Lt=zt.alpha;K.shadowColor=Color.shared.setValue(xt).setAlpha(Lt).toRgbaString();const dt=zt.blur*z,Pt=zt.distance*z;K.shadowBlur=dt,K.shadowOffsetX=Math.cos(zt.angle)*Pt,K.shadowOffsetY=Math.sin(zt.angle)*Pt+At}else K.globalAlpha=(Ve=(Ge=A._fill)==null?void 0:Ge.alpha)!=null?Ve:1,K.fillStyle=A._fill?getCanvasFillStyle(A._fill,K):null,(pt=A._stroke)!=null&&pt.width&&(K.strokeStyle=getCanvasFillStyle(A._stroke,K)),K.shadowColor="black";let _t=(oe-he.fontSize)/2;oe-he.fontSize<0&&(_t=0);const It=(ct=(Ze=A._stroke)==null?void 0:Ze.width)!=null?ct:0;for(let zt=0;zt<ie.length;zt++)xe=It/2,Se=It/2+zt*oe+he.ascent+_t,A.align==="right"?xe+=de-ue[zt]:A.align==="center"&&(xe+=(de-ue[zt])/2),(Xe=A._stroke)!=null&&Xe.width&&this._drawLetterSpacing(ie[zt],A,I,xe+A.padding,Se+A.padding-jt,!0),A._fill!==void 0&&this._drawLetterSpacing(ie[zt],A,I,xe+A.padding,Se+A.padding-jt)}}_drawLetterSpacing(C,A,z,I,L,K=!1){const{context:te}=z,ne=A.letterSpacing;let ie=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(te.letterSpacing=`${ne}px`,te.textLetterSpacing=`${ne}px`,ie=!0):(te.letterSpacing="0px",te.textLetterSpacing="0px")),ne===0||ie){K?te.strokeText(C,I,L):te.fillText(C,I,L);return}let oe=I;const ue=CanvasTextMetrics.graphemeSegmenter(C);let de=te.measureText(C).width,he=0;for(let fe=0;fe<ue.length;++fe){const be=ue[fe];K?te.strokeText(be,oe,L):te.fillText(be,oe,L);let xe="";for(let Se=fe+1;Se<ue.length;++Se)xe+=ue[Se];he=te.measureText(xe).width,oe+=de-he+ne,de=he}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"canvasText"},extensions.add(browserExt,webworkerExt);var vertex$1=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,wgslVertex=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}`,fragment$z=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uGamma;
uniform float uContrast;
uniform float uSaturation;
uniform float uBrightness;
uniform vec4 uColor;

void main()
{
    vec4 c = texture(uTexture, vTextureCoord);

    if (c.a > 0.0) {
        c.rgb /= c.a;

        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));
        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);
        rgb.r *= uColor.r;
        rgb.g *= uColor.g;
        rgb.b *= uColor.b;
        c.rgb = rgb * uBrightness;

        c.rgb *= c.a;
    }

    finalColor = c * uColor.a;
}
`,source$y=`struct AdjustmentUniforms {
  uGamma: f32,
  uContrast: f32,
  uSaturation: f32,
  uBrightness: f32,
  uColor: vec4<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  var sample = textureSample(uTexture, uSampler, uv);
  let color = adjustmentUniforms.uColor;

  if (sample.a > 0.0) 
  {
    sample = vec4<f32>(sample.rgb / sample.a, sample.a);
    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));
    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);
    rgb.r *= color.r;
    rgb.g *= color.g;
    rgb.b *= color.b;
    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);
    sample = vec4<f32>(sample.rgb * sample.a, sample.a);
  }

  return sample * color.a;
}`,__defProp$x=Object.defineProperty,__defNormalProp$x=(O,C,A)=>C in O?__defProp$x(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$x=(O,C,A)=>(__defNormalProp$x(O,typeof C!="symbol"?C+"":C,A),A);const _AdjustmentFilter=class nn extends Filter{constructor(C){C={...nn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$y,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$z,name:"adjustment-filter"});super({gpuProgram:A,glProgram:z,resources:{adjustmentUniforms:{uGamma:{value:C.gamma,type:"f32"},uContrast:{value:C.contrast,type:"f32"},uSaturation:{value:C.saturation,type:"f32"},uBrightness:{value:C.brightness,type:"f32"},uColor:{value:[C.red,C.green,C.blue,C.alpha],type:"vec4<f32>"}}}}),__publicField$x(this,"uniforms"),this.uniforms=this.resources.adjustmentUniforms.uniforms}get gamma(){return this.uniforms.uGamma}set gamma(C){this.uniforms.uGamma=C}get contrast(){return this.uniforms.uContrast}set contrast(C){this.uniforms.uContrast=C}get saturation(){return this.uniforms.uSaturation}set saturation(C){this.uniforms.uSaturation=C}get brightness(){return this.uniforms.uBrightness}set brightness(C){this.uniforms.uBrightness=C}get red(){return this.uniforms.uColor[0]}set red(C){this.uniforms.uColor[0]=C}get green(){return this.uniforms.uColor[1]}set green(C){this.uniforms.uColor[1]=C}get blue(){return this.uniforms.uColor[2]}set blue(C){this.uniforms.uColor[2]=C}get alpha(){return this.uniforms.uColor[3]}set alpha(C){this.uniforms.uColor[3]=C}};__publicField$x(_AdjustmentFilter,"DEFAULT_OPTIONS",{gamma:1,contrast:1,saturation:1,brightness:1,red:1,green:1,blue:1,alpha:1});var fragment$y=`
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uOffset;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample top right pixel
    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample bottom right pixel
    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));

    // Sample bottom left pixel
    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));

    // Average
    color *= 0.25;

    finalColor = color;
}`,source$x=`struct KawaseBlurUniforms {
  uOffset:vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOffset = kawaseBlurUniforms.uOffset;
  var color: vec4<f32> = vec4<f32>(0.0);

  // Sample top left pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));
  // Sample top right pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));
  // Sample bottom right pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));
  // Sample bottom left pixel
  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));
  // Average
  color *= 0.25;

  return color;
}`,fragmentClamp=`
precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uOffset;

uniform vec4 uInputClamp;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample top right pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample bottom right pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Sample bottom left pixel
    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));

    // Average
    color *= 0.25;

    finalColor = color;
}
`,sourceClamp=`struct KawaseBlurUniforms {
  uOffset:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOffset = kawaseBlurUniforms.uOffset;
  var color: vec4<f32> = vec4(0.0);

  // Sample top left pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample top right pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample bottom right pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Sample bottom left pixel
  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
  // Average
  color *= 0.25;
    
  return color;
}`,__defProp$w=Object.defineProperty,__defNormalProp$w=(O,C,A)=>C in O?__defProp$w(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$w=(O,C,A)=>(__defNormalProp$w(O,typeof C!="symbol"?C+"":C,A),A);const _KawaseBlurFilter=class sn extends Filter{constructor(...C){var L,K,te;let A=(L=C[0])!=null?L:{};(typeof A=="number"||Array.isArray(A))&&(deprecation("6.0.0","KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }"),A={strength:A},C[1]!==void 0&&(A.quality=C[1]),C[2]!==void 0&&(A.clamp=C[2])),A={...sn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:A!=null&&A.clamp?sourceClamp:source$x,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:A!=null&&A.clamp?fragmentClamp:fragment$y,name:"kawase-blur-filter"});super({gpuProgram:z,glProgram:I,resources:{kawaseBlurUniforms:{uOffset:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField$w(this,"uniforms"),__publicField$w(this,"_pixelSize",{x:0,y:0}),__publicField$w(this,"_clamp"),__publicField$w(this,"_kernels",[]),__publicField$w(this,"_blur"),__publicField$w(this,"_quality"),this.uniforms=this.resources.kawaseBlurUniforms.uniforms,this.pixelSize=(K=A.pixelSize)!=null?K:{x:1,y:1},Array.isArray(A.strength)?this.kernels=A.strength:typeof A.strength=="number"&&(this._blur=A.strength,this.quality=(te=A.quality)!=null?te:3),this._clamp=!!A.clamp}apply(C,A,z,I){const L=this.pixelSizeX/A.source.width,K=this.pixelSizeY/A.source.height;let te;if(this._quality===1||this._blur===0)te=this._kernels[0]+.5,this.uniforms.uOffset[0]=te*L,this.uniforms.uOffset[1]=te*K,C.applyFilter(this,A,z,I);else{const ne=TexturePool.getSameSizeTexture(A);let ie=A,oe=ne,ue;const de=this._quality-1;for(let he=0;he<de;he++)te=this._kernels[he]+.5,this.uniforms.uOffset[0]=te*L,this.uniforms.uOffset[1]=te*K,C.applyFilter(this,ie,oe,!0),ue=ie,ie=oe,oe=ue;te=this._kernels[de]+.5,this.uniforms.uOffset[0]=te*L,this.uniforms.uOffset[1]=te*K,C.applyFilter(this,ie,z,I),TexturePool.returnTexture(ne)}}get strength(){return this._blur}set strength(C){this._blur=C,this._generateKernels()}get quality(){return this._quality}set quality(C){this._quality=Math.max(1,Math.round(C)),this._generateKernels()}get kernels(){return this._kernels}set kernels(C){Array.isArray(C)&&C.length>0?(this._kernels=C,this._quality=C.length,this._blur=Math.max(...C)):(this._kernels=[0],this._quality=1)}get pixelSize(){return this._pixelSize}set pixelSize(C){if(typeof C=="number"){this.pixelSizeX=this.pixelSizeY=C;return}if(Array.isArray(C)){this.pixelSizeX=C[0],this.pixelSizeY=C[1];return}this._pixelSize=C}get pixelSizeX(){return this.pixelSize.x}set pixelSizeX(C){this.pixelSize.x=C}get pixelSizeY(){return this.pixelSize.y}set pixelSizeY(C){this.pixelSize.y=C}get clamp(){return this._clamp}_updatePadding(){this.padding=Math.ceil(this._kernels.reduce((C,A)=>C+A+.5,0))}_generateKernels(){const C=this._blur,A=this._quality,z=[C];if(C>0){let I=C;const L=C/A;for(let K=1;K<A;K++)I-=L,z.push(I)}this._kernels=z,this._updatePadding()}};__publicField$w(_KawaseBlurFilter,"DEFAULT_OPTIONS",{strength:4,quality:3,clamp:!1,pixelSize:{x:1,y:1}});let KawaseBlurFilter=_KawaseBlurFilter;var fragment$x=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform float uBloomScale;
uniform float uBrightness;

void main() {
    vec4 color = texture(uTexture, vTextureCoord);
    color.rgb *= uBrightness;
    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);
    bloomColor.rgb *= uBloomScale;
    finalColor = color + bloomColor;
}
`,source$w=`struct AdvancedBloomUniforms {
  uBloomScale: f32,
  uBrightness: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color = textureSample(uTexture, uSampler, uv);
  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);

  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);
  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);
  
  return color + bloomColor;
}
`,fragment$w=`
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uThreshold;

void main() {
    vec4 color = texture(uTexture, vTextureCoord);

    // A simple & fast algorithm for getting brightness.
    // It's inaccuracy , but good enought for this feature.
    float _max = max(max(color.r, color.g), color.b);
    float _min = min(min(color.r, color.g), color.b);
    float brightness = (_max + _min) * 0.5;

    if(brightness > uThreshold) {
        finalColor = color;
    } else {
        finalColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
}
`,source$v=`struct ExtractBrightnessUniforms {
  uThreshold: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  // A simple & fast algorithm for getting brightness.
  // It's inaccurate, but good enough for this feature.
  let max: f32 = max(max(color.r, color.g), color.b);
  let min: f32 = min(min(color.r, color.g), color.b);
  let brightness: f32 = (max + min) * 0.5;

  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);
}
`,__defProp$v=Object.defineProperty,__defNormalProp$v=(O,C,A)=>C in O?__defProp$v(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$v=(O,C,A)=>(__defNormalProp$v(O,typeof C!="symbol"?C+"":C,A),A);const _ExtractBrightnessFilter=class on extends Filter{constructor(C){C={...on.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$v,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$w,name:"extract-brightness-filter"});super({gpuProgram:A,glProgram:z,resources:{extractBrightnessUniforms:{uThreshold:{value:C.threshold,type:"f32"}}}}),__publicField$v(this,"uniforms"),this.uniforms=this.resources.extractBrightnessUniforms.uniforms}get threshold(){return this.uniforms.uThreshold}set threshold(C){this.uniforms.uThreshold=C}};__publicField$v(_ExtractBrightnessFilter,"DEFAULT_OPTIONS",{threshold:.5});let ExtractBrightnessFilter=_ExtractBrightnessFilter;var __defProp$u=Object.defineProperty,__defNormalProp$u=(O,C,A)=>C in O?__defProp$u(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$u=(O,C,A)=>(__defNormalProp$u(O,typeof C!="symbol"?C+"":C,A),A);const _AdvancedBloomFilter=class an extends Filter{constructor(C){var I;C={...an.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$w,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$x,name:"advanced-bloom-filter"});super({gpuProgram:A,glProgram:z,resources:{advancedBloomUniforms:{uBloomScale:{value:C.bloomScale,type:"f32"},uBrightness:{value:C.brightness,type:"f32"}},uMapTexture:Texture.WHITE}}),__publicField$u(this,"uniforms"),__publicField$u(this,"bloomScale",1),__publicField$u(this,"brightness",1),__publicField$u(this,"_extractFilter"),__publicField$u(this,"_blurFilter"),this.uniforms=this.resources.advancedBloomUniforms.uniforms,this._extractFilter=new ExtractBrightnessFilter({threshold:C.threshold}),this._blurFilter=new KawaseBlurFilter({strength:(I=C.kernels)!=null?I:C.blur,quality:C.kernels?void 0:C.quality}),Object.assign(this,C)}apply(C,A,z,I){const L=TexturePool.getSameSizeTexture(A);this._extractFilter.apply(C,A,L,!0);const K=TexturePool.getSameSizeTexture(A);this._blurFilter.apply(C,L,K,!0),this.uniforms.uBloomScale=this.bloomScale,this.uniforms.uBrightness=this.brightness,this.resources.uMapTexture=K.source,C.applyFilter(this,A,z,I),TexturePool.returnTexture(K),TexturePool.returnTexture(L)}get threshold(){return this._extractFilter.threshold}set threshold(C){this._extractFilter.threshold=C}get kernels(){return this._blurFilter.kernels}set kernels(C){this._blurFilter.kernels=C}get blur(){return this._blurFilter.strength}set blur(C){this._blurFilter.strength=C}get quality(){return this._blurFilter.quality}set quality(C){this._blurFilter.quality=C}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(C){typeof C=="number"&&(C={x:C,y:C}),Array.isArray(C)&&(C={x:C[0],y:C[1]}),this._blurFilter.pixelSize=C}get pixelSizeX(){return this._blurFilter.pixelSizeX}set pixelSizeX(C){this._blurFilter.pixelSizeX=C}get pixelSizeY(){return this._blurFilter.pixelSizeY}set pixelSizeY(C){this._blurFilter.pixelSizeY=C}};__publicField$u(_AdvancedBloomFilter,"DEFAULT_OPTIONS",{threshold:.5,bloomScale:1,brightness:1,blur:8,quality:4,pixelSize:{x:1,y:1}});var fragment$v=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uSize;
uniform vec3 uColor;
uniform float uReplaceColor;

uniform vec4 uInputSize;

vec2 mapCoord( vec2 coord )
{
    coord *= uInputSize.xy;
    coord += uInputSize.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= uInputSize.zw;
    coord /= uInputSize.xy;

    return coord;
}

vec2 pixelate(vec2 coord, vec2 size)
{
    return floor(coord / size) * size;
}

vec2 getMod(vec2 coord, vec2 size)
{
    return mod(coord, size) / size;
}

float character(float n, vec2 p)
{
    p = floor(p*vec2(4.0, 4.0) + 2.5);

    if (clamp(p.x, 0.0, 4.0) == p.x)
    {
        if (clamp(p.y, 0.0, 4.0) == p.y)
        {
            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;
        }
    }
    return 0.0;
}

void main()
{
    vec2 coord = mapCoord(vTextureCoord);

    // get the grid position
    vec2 pixCoord = pixelate(coord, vec2(uSize));
    pixCoord = unmapCoord(pixCoord);

    // sample the color at grid position
    vec4 color = texture(uTexture, pixCoord);

    // brightness of the color as it's perceived by the human eye
    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;

    // determine the character to use
    float n =  65536.0;             // .
    if (gray > 0.2) n = 65600.0;    // :
    if (gray > 0.3) n = 332772.0;   // *
    if (gray > 0.4) n = 15255086.0; // o
    if (gray > 0.5) n = 23385164.0; // &
    if (gray > 0.6) n = 15252014.0; // 8
    if (gray > 0.7) n = 13199452.0; // @
    if (gray > 0.8) n = 11512810.0; // #

    // get the mod..
    vec2 modd = getMod(coord, vec2(uSize));

    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);
}
`,source$u=`struct AsciiUniforms {
    uSize: f32,
    uColor: vec3<f32>,
    uReplaceColor: f32,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let pixelSize: f32 = asciiUniforms.uSize;
    let coord: vec2<f32> = mapCoord(uv);

    // get the rounded color..
    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));
    pixCoord = unmapCoord(pixCoord);

    var color = textureSample(uTexture, uSampler, pixCoord);

    // determine the character to use
    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;
    
    var n: f32 = 65536.0; // .
    if (gray > 0.2) {
        n = 65600.0;    // :
    }
    if (gray > 0.3) {
        n = 332772.0;   // *
    }
    if (gray > 0.4) {
        n = 15255086.0; // o
    }
    if (gray > 0.5) {
        n = 23385164.0; // &
    }
    if (gray > 0.6) {
        n = 15252014.0; // 8
    }
    if (gray > 0.7) {
        n = 13199452.0; // @
    }
    if (gray > 0.8) {
        n = 11512810.0; // #
    }

    // get the mod..
    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));
    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);
}

fn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>
{
    return floor( coord / size ) * size;
}

fn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>
{
    return moduloVec2( coord , size) / size;
}

fn character(n: f32, p: vec2<f32>) -> f32
{
    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);

    if (clamp(q.x, 0.0, 4.0) == q.x)
    {
        if (clamp(q.y, 0.0, 4.0) == q.y)
        {
        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)
        {
            return 1.0;
        }
        }
    }

    return 0.0;
}

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>
{
  return x - y * floor(x/y);
}

fn mapCoord(coord: vec2<f32> ) -> vec2<f32>
{
    var mappedCoord: vec2<f32> = coord;
    mappedCoord *= gfu.uInputSize.xy;
    mappedCoord += gfu.uOutputFrame.xy;
    return mappedCoord;
}

fn unmapCoord(coord: vec2<f32> ) -> vec2<f32>
{
    var mappedCoord: vec2<f32> = coord;
    mappedCoord -= gfu.uOutputFrame.xy;
    mappedCoord /= gfu.uInputSize.xy;
    return mappedCoord;
}`,__defProp$t=Object.defineProperty,__defNormalProp$t=(O,C,A)=>C in O?__defProp$t(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$t=(O,C,A)=>(__defNormalProp$t(O,typeof C!="symbol"?C+"":C,A),A);const _AsciiFilter=class ln extends Filter{constructor(...C){var K,te;let A=(K=C[0])!=null?K:{};typeof A=="number"&&(deprecation("6.0.0","AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }"),A={size:A});const z=(A==null?void 0:A.color)&&A.replaceColor!==!1;A={...ln.DEFAULT_OPTIONS,...A};const I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$u,entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$v,name:"ascii-filter"});super({gpuProgram:I,glProgram:L,resources:{asciiUniforms:{uSize:{value:A.size,type:"f32"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uReplaceColor:{value:Number(z),type:"f32"}}}}),__publicField$t(this,"uniforms"),__publicField$t(this,"_color"),this.uniforms=this.resources.asciiUniforms.uniforms,this._color=new Color,this.color=(te=A.color)!=null?te:16777215}get size(){return this.uniforms.uSize}set size(C){this.uniforms.uSize=C}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get replaceColor(){return this.uniforms.uReplaceColor>.5}set replaceColor(C){this.uniforms.uReplaceColor=C?1:0}};__publicField$t(_AsciiFilter,"DEFAULT_OPTIONS",{size:8,color:16777215,replaceColor:!1});var fragment$u=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uBackground;

void main(void){
    vec4 front = texture(uTexture, vTextureCoord);
    vec4 back = texture(uBackground, vTextureCoord);

    if (front.a == 0.0) {
        discard;
    }
    
    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);

    finalColor = vec4(color, 1.0);
}`,wgslFragment=`@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var uBackground: texture_2d<f32>; 

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);
    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);
    
    if (front.a == 0.0) {
        discard;
    }

    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);

    return vec4<f32>(color, 1.0);
}`,__defProp$s=Object.defineProperty,__defNormalProp$s=(O,C,A)=>C in O?__defProp$s(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$s=(O,C,A)=>(__defNormalProp$s(O,typeof C!="symbol"?C+"":C,A),A);class BackdropBlurFilter extends BlurFilter{constructor(C){super(C),__publicField$s(this,"_blendPass"),this.blendRequired=!0,this.padding=0,this._blendPass=new Filter({gpuProgram:GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:wgslFragment,entryPoint:"mainFragment"}}),glProgram:GlProgram.from({vertex:vertex$1,fragment:fragment$u,name:"drop-shadow-filter"}),resources:{uBackground:Texture.EMPTY}})}apply(C,A,z,I){const L=C._activeFilterData.backTexture,K=TexturePool.getSameSizeTexture(A);super.apply(C,L,K,!0),this._blendPass.resources.uBackground=K.source,this._blendPass.apply(C,A,z,I),TexturePool.returnTexture(K)}updatePadding(){this.padding=0}}var fragment$t=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTransform;
uniform vec3 uLightColor;
uniform float uLightAlpha;
uniform vec3 uShadowColor;
uniform float uShadowAlpha;

uniform vec4 uInputSize;

void main(void) {
    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);
    vec4 color = texture(uTexture, vTextureCoord);
    float light = texture(uTexture, vTextureCoord - transform).a;
    float shadow = texture(uTexture, vTextureCoord + transform).a;

    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));
    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));
    finalColor = vec4(color.rgb * color.a, color.a);
}
`,source$t=`struct BevelUniforms {
  uLightColor: vec3<f32>,
  uLightAlpha: f32,
  uShadowColor: vec3<f32>,
  uShadowAlpha: f32,
  uTransform: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;
  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;

  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);
  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);

  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);
  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);
  
  return vec4<f32>(color.rgb * color.a, color.a);
}`,__defProp$r=Object.defineProperty,__defNormalProp$r=(O,C,A)=>C in O?__defProp$r(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$r=(O,C,A)=>(__defNormalProp$r(O,typeof C!="symbol"?C+"":C,A),A);const _BevelFilter=class un extends Filter{constructor(C){var I,L;C={...un.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$t,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$t,name:"bevel-filter"});super({gpuProgram:A,glProgram:z,resources:{bevelUniforms:{uLightColor:{value:new Float32Array(3),type:"vec3<f32>"},uLightAlpha:{value:C.lightAlpha,type:"f32"},uShadowColor:{value:new Float32Array(3),type:"vec3<f32>"},uShadowAlpha:{value:C.shadowAlpha,type:"f32"},uTransform:{value:new Float32Array(2),type:"vec2<f32>"}}},padding:1}),__publicField$r(this,"uniforms"),__publicField$r(this,"_thickness"),__publicField$r(this,"_rotation"),__publicField$r(this,"_lightColor"),__publicField$r(this,"_shadowColor"),this.uniforms=this.resources.bevelUniforms.uniforms,this._lightColor=new Color,this._shadowColor=new Color,this.lightColor=(I=C.lightColor)!=null?I:16777215,this.shadowColor=(L=C.shadowColor)!=null?L:0,Object.assign(this,C)}get rotation(){return this._rotation/DEG_TO_RAD}set rotation(C){this._rotation=C*DEG_TO_RAD,this._updateTransform()}get thickness(){return this._thickness}set thickness(C){this._thickness=C,this._updateTransform()}get lightColor(){return this._lightColor.value}set lightColor(C){this._lightColor.setValue(C);const[A,z,I]=this._lightColor.toArray();this.uniforms.uLightColor[0]=A,this.uniforms.uLightColor[1]=z,this.uniforms.uLightColor[2]=I}get lightAlpha(){return this.uniforms.uLightAlpha}set lightAlpha(C){this.uniforms.uLightAlpha=C}get shadowColor(){return this._shadowColor.value}set shadowColor(C){this._shadowColor.setValue(C);const[A,z,I]=this._shadowColor.toArray();this.uniforms.uShadowColor[0]=A,this.uniforms.uShadowColor[1]=z,this.uniforms.uShadowColor[2]=I}get shadowAlpha(){return this.uniforms.uShadowAlpha}set shadowAlpha(C){this.uniforms.uShadowAlpha=C}_updateTransform(){this.uniforms.uTransform[0]=this.thickness*Math.cos(this._rotation),this.uniforms.uTransform[1]=this.thickness*Math.sin(this._rotation)}};__publicField$r(_BevelFilter,"DEFAULT_OPTIONS",{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7});var __defProp$q=Object.defineProperty,__defNormalProp$q=(O,C,A)=>C in O?__defProp$q(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$q=(O,C,A)=>(__defNormalProp$q(O,typeof C!="symbol"?C+"":C,A),A);const _BloomFilter=class cn extends AlphaFilter{constructor(...C){var z;let A=(z=C[0])!=null?z:{};if(typeof A=="number"||Array.isArray(A)||"x"in A&&"y"in A){deprecation("6.0.0","BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");let I=A;Array.isArray(I)&&(I={x:I[0],y:I[1]}),A={strength:I},C[1]!==void 0&&(A.quality=C[1]),C[2]!==void 0&&(A.resolution=C[2]),C[3]!==void 0&&(A.kernelSize=C[3])}A={...cn.DEFAULT_OPTIONS,...A},super(),__publicField$q(this,"_blurXFilter"),__publicField$q(this,"_blurYFilter"),__publicField$q(this,"_strength"),this._strength={x:2,y:2},A.strength&&(typeof A.strength=="number"?(this._strength.x=A.strength,this._strength.y=A.strength):(this._strength.x=A.strength.x,this._strength.y=A.strength.y)),this._blurXFilter=new BlurFilterPass({...A,horizontal:!0,strength:this.strengthX}),this._blurYFilter=new BlurFilterPass({...A,horizontal:!1,strength:this.strengthY}),this._blurYFilter.blendMode="screen",Object.assign(this,A)}apply(C,A,z,I){const L=TexturePool.getSameSizeTexture(A);C.applyFilter(this,A,z,I),this._blurXFilter.apply(C,A,L,!0),this._blurYFilter.apply(C,L,z,!1),TexturePool.returnTexture(L)}get strength(){return this._strength}set strength(C){this._strength=typeof C=="number"?{x:C,y:C}:C,this._updateStrength()}get strengthX(){return this.strength.x}set strengthX(C){this.strength.x=C,this._updateStrength()}get strengthY(){return this.strength.y}set strengthY(C){this.strength.y=C,this._updateStrength()}_updateStrength(){this._blurXFilter.blur=this.strengthX,this._blurYFilter.blur=this.strengthY}get blur(){return deprecation("6.0.0","BloomFilter.blur is deprecated, please use BloomFilter.strength instead"),this.strengthX}set blur(C){deprecation("6.0.0","BloomFilter.blur is deprecated, please use BloomFilter.strength instead"),this.strength=C}get blurX(){return deprecation("6.0.0","BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"),this.strengthX}set blurX(C){deprecation("6.0.0","BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"),this.strengthX=C}get blurY(){return deprecation("6.0.0","BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"),this.strengthY}set blurY(C){deprecation("6.0.0","BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"),this.strengthY=C}};__publicField$q(_BloomFilter,"DEFAULT_OPTIONS",{strength:{x:2,y:2},quality:4,resolution:1,kernelSize:5});var fragment$s=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uDimensions;
uniform vec2 uCenter;
uniform float uRadius;
uniform float uStrength;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

void main()
{
    vec2 coord = vTextureCoord * uInputSize.xy;
    coord -= uCenter * uDimensions.xy;
    float distance = length(coord);

    if (distance < uRadius) {
        float percent = distance / uRadius;
        if (uStrength > 0.0) {
            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);
        } else {
            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);
        }
    }

    coord += uCenter * uDimensions.xy;
    coord /= uInputSize.xy;
    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    vec4 color = texture(uTexture, clampedCoord);

    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    finalColor = color;
}
`,source$s=`struct BulgePinchUniforms {
  uDimensions: vec2<f32>,
  uCenter: vec2<f32>,
  uRadius: f32,
  uStrength: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;
  let center: vec2<f32> = bulgePinchUniforms.uCenter;
  let radius: f32 = bulgePinchUniforms.uRadius;
  let strength: f32 = bulgePinchUniforms.uStrength;
  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;

  let distance: f32 = length(coord);

  if (distance < radius) {
      let percent: f32 = distance / radius;
      if (strength > 0.0) {
          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);
      } else {
          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);
      }
  }
    coord += (center * dimensions.xy);
    coord /= gfu.uInputSize.xy;

    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);
    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);
    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    return color;
}

fn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
  if (x.x == y.x && x.y == y.y)
  {
    return true;
  }

  return false;
}`,__defProp$p=Object.defineProperty,__defNormalProp$p=(O,C,A)=>C in O?__defProp$p(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$p=(O,C,A)=>(__defNormalProp$p(O,typeof C!="symbol"?C+"":C,A),A);const _BulgePinchFilter=class hn extends Filter{constructor(C){C={...hn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$s,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$s,name:"bulge-pinch-filter"});super({gpuProgram:A,glProgram:z,resources:{bulgePinchUniforms:{uDimensions:{value:[0,0],type:"vec2<f32>"},uCenter:{value:C.center,type:"vec2<f32>"},uRadius:{value:C.radius,type:"f32"},uStrength:{value:C.strength,type:"f32"}}}}),__publicField$p(this,"uniforms"),this.uniforms=this.resources.bulgePinchUniforms.uniforms,Object.assign(this,C)}apply(C,A,z,I){this.uniforms.uDimensions[0]=A.frame.width,this.uniforms.uDimensions[1]=A.frame.height,C.applyFilter(this,A,z,I)}get center(){return this.uniforms.uCenter}set center(C){typeof C=="number"&&(C={x:C,y:C}),Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uCenter=C}get centerX(){return this.uniforms.uCenter.x}set centerX(C){this.uniforms.uCenter.x=C}get centerY(){return this.uniforms.uCenter.y}set centerY(C){this.uniforms.uCenter.y=C}get radius(){return this.uniforms.uRadius}set radius(C){this.uniforms.uRadius=C}get strength(){return this.uniforms.uStrength}set strength(C){this.uniforms.uStrength=C}};__publicField$p(_BulgePinchFilter,"DEFAULT_OPTIONS",{center:{x:.5,y:.5},radius:100,strength:1});var fragment$r=`precision highp float;
in vec2 vTextureCoord;
in vec2 vFilterCoord;
out vec4 finalColor;

const int TYPE_LINEAR = 0;
const int TYPE_RADIAL = 1;
const int TYPE_CONIC = 2;
const int MAX_STOPS = 32;

uniform sampler2D uTexture;
uniform vec4 uOptions;
uniform vec2 uCounts;
uniform vec3 uColors[MAX_STOPS];
uniform vec4 uStops[MAX_STOPS];

const float PI = 3.1415926538;
const float PI_2 = PI*2.;

struct ColorStop {
    float offset;
    vec3 color;
    float alpha;
};

mat2 rotate2d(float angle){
    return mat2(cos(angle), -sin(angle),
    sin(angle), cos(angle));
}

float projectLinearPosition(vec2 pos, float angle){
    vec2 center = vec2(0.5);
    vec2 result = pos - center;
    result = rotate2d(angle) * result;
    result = result + center;
    return clamp(result.x, 0., 1.);
}

float projectRadialPosition(vec2 pos) {
    float r = distance(pos, vec2(0.5));
    return clamp(2.*r, 0., 1.);
}

float projectAnglePosition(vec2 pos, float angle) {
    vec2 center = pos - vec2(0.5);
    float polarAngle=atan(-center.y, center.x);
    return mod(polarAngle + angle, PI_2) / PI_2;
}

float projectPosition(vec2 pos, int type, float angle) {
    if (type == TYPE_LINEAR) {
        return projectLinearPosition(pos, angle);
    } else if (type == TYPE_RADIAL) {
        return projectRadialPosition(pos);
    } else if (type == TYPE_CONIC) {
        return projectAnglePosition(pos, angle);
    }

    return pos.y;
}

void main(void) {
    int uType = int(uOptions[0]);
    float uAngle = uOptions[1];
    float uAlpha = uOptions[2];
    float uReplace = uOptions[3];

    int uNumStops = int(uCounts[0]);
    float uMaxColors = uCounts[1];

    // current/original color
    vec4 currentColor = texture(uTexture, vTextureCoord);

    // skip calculations if gradient alpha is 0
    if (0.0 == uAlpha) {
        finalColor = currentColor;
        return;
    }

    // project position
    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));

    // check gradient bounds
    float offsetMin = uStops[0][0];
    float offsetMax = 0.0;

    int numStops = int(uNumStops);

    for (int i = 0; i < MAX_STOPS; i++) {
        if (i == numStops-1){ // last index
            offsetMax = uStops[i][0];
        }
    }

    if (y  < offsetMin || y > offsetMax) {
        finalColor = currentColor;
        return;
    }

    // limit colors
    if (uMaxColors > 0.) {
        float stepSize = 1./uMaxColors;
        float stepNumber = float(floor(y/stepSize));
        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment
    }

    // find color stops
    ColorStop from;
    ColorStop to;

    for (int i = 0; i < MAX_STOPS; i++) {
        if (y >= uStops[i][0]) {
            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);
            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);
        }

        if (i == numStops-1){ // last index
            break;
        }
    }

    // mix colors from stops
    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);
    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);

    float segmentHeight = to.offset - from.offset;
    float relativePos = y - from.offset;// position from 0 to [segmentHeight]
    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].

    float gradientAlpha = uAlpha * currentColor.a;
    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;

    if (uReplace < 0.5) {
        // mix resulting color with current color
        finalColor = gradientColor + currentColor*(1.-gradientColor.a);
    } else {
        // replace with gradient color
        finalColor = gradientColor;
    }
}
`,vertex=`in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 vFilterCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;
}
`,source$r=`struct BaseUniforms {
  uOptions: vec4<f32>,
  uCounts: vec2<f32>,
};

struct StopsUniforms {
  uColors: array<vec3<f32>, MAX_STOPS>,
  uStops: array<vec4<f32>, MAX_STOPS>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;
@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;

struct VSOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
  @location(1) coord : vec2<f32>
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>
{
    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);
  return VSOutput(
   filterVertexPosition(aPosition),
   vTextureCoord,
   filterCoord(vTextureCoord),
  );
}

struct ColorStop {
  offset: f32,
  color: vec3<f32>,
  alpha: f32,
};

fn rotate2d(angle: f32) -> mat2x2<f32>{
  return mat2x2(cos(angle), -sin(angle),
  sin(angle), cos(angle));
}

fn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {
  var center: vec2<f32> = vec2<f32>(0.5);
  var result: vec2<f32> = pos - center;
  result = rotate2d(angle) * result;
  result = result + center;
  return clamp(result.x, 0.0, 1.0);
}

fn projectRadialPosition(pos: vec2<f32>) -> f32 {
  var r: f32 = distance(pos, vec2<f32>(0.5));
  return clamp(2.0 * r, 0.0, 1.0);
}

fn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {
  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);
  var polarAngle: f32 = atan2(-center.y, center.x);
  return ((polarAngle + angle) % PI_2) / PI_2;
}

fn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {
  if (gradientType == TYPE_LINEAR) {
      return projectLinearPosition(pos, angle);
  } else if (gradientType == TYPE_RADIAL) {
      return projectRadialPosition(pos);
  } else if (gradientType == TYPE_CONIC) {
      return projectAnglePosition(pos, angle);
  }

  return pos.y;
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
  @location(1) coord : vec2<f32>
) -> @location(0) vec4<f32> {
  let uType: i32 = i32(baseUniforms.uOptions[0]);
  let uAngle: f32 = baseUniforms.uOptions[1];
  let uAlpha: f32 = baseUniforms.uOptions[2];
  let uReplace: f32 = baseUniforms.uOptions[3];

  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);
  let uMaxColors: f32 = baseUniforms.uCounts[1];

  // current/original color
  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);

  // skip calculations if gradient alpha is 0
  if (uAlpha == 0.0) { return currentColor; }

  // project position
  var y: f32 = projectPosition(coord, uType, radians(uAngle));

  // check gradient bounds
  var offsetMin: f32 = stopsUniforms.uStops[0][0];
  var offsetMax: f32 = 0.0;

  let numStops: i32 = uNumStops;

  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {
      if (i == numStops - 1) { // last index
          offsetMax = stopsUniforms.uStops[i][0];
      }
  }

  if (y  < offsetMin || y > offsetMax) { return currentColor; }

  // limit colors
  if (uMaxColors > 0.0) {
      var stepSize: f32 = 1.0 / uMaxColors;
      var stepNumber: f32 = floor(y / stepSize);
      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment
  }

  // find color stops
  var stopFrom: ColorStop;
  var stopTo: ColorStop;

  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {
      if (y >= stopsUniforms.uStops[i][0]) {
          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);
          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);
      }

      if (i == numStops - 1) { // last index
          break;
      }
  }

  // mix colors from stops
  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);
  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);

  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;
  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]
  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].

  var gradientAlpha: f32 = uAlpha * currentColor.a;
  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;

  if (uReplace < 0.5) {
      // mix resulting color with current color
      return gradientColor + currentColor * (1.0 - gradientColor.a);
  } else {
      // replace with gradient color
      return gradientColor;
  }
}

const PI: f32 = 3.14159265358979323846264;
const PI_2: f32 = PI * 2.0;

const TYPE_LINEAR: i32 = 0;
const TYPE_RADIAL: i32 = 1;
const TYPE_CONIC: i32 = 2;
const MAX_STOPS: i32 = 32;`,GradientParser=GradientParser||{};GradientParser.stringify=function(){var O={"visit_linear-gradient":function(C){return O.visit_gradient(C)},"visit_repeating-linear-gradient":function(C){return O.visit_gradient(C)},"visit_radial-gradient":function(C){return O.visit_gradient(C)},"visit_repeating-radial-gradient":function(C){return O.visit_gradient(C)},visit_gradient:function(C){var A=O.visit(C.orientation);return A&&(A+=", "),C.type+"("+A+O.visit(C.colorStops)+")"},visit_shape:function(C){var A=C.value,z=O.visit(C.at),I=O.visit(C.style);return I&&(A+=" "+I),z&&(A+=" at "+z),A},"visit_default-radial":function(C){var A="",z=O.visit(C.at);return z&&(A+=z),A},"visit_extent-keyword":function(C){var A=C.value,z=O.visit(C.at);return z&&(A+=" at "+z),A},"visit_position-keyword":function(C){return C.value},visit_position:function(C){return O.visit(C.value.x)+" "+O.visit(C.value.y)},"visit_%":function(C){return C.value+"%"},visit_em:function(C){return C.value+"em"},visit_px:function(C){return C.value+"px"},visit_literal:function(C){return O.visit_color(C.value,C)},visit_hex:function(C){return O.visit_color("#"+C.value,C)},visit_rgb:function(C){return O.visit_color("rgb("+C.value.join(", ")+")",C)},visit_rgba:function(C){return O.visit_color("rgba("+C.value.join(", ")+")",C)},visit_color:function(C,A){var z=C,I=O.visit(A.length);return I&&(z+=" "+I),z},visit_angular:function(C){return C.value+"deg"},visit_directional:function(C){return"to "+C.value},visit_array:function(C){var A="",z=C.length;return C.forEach(function(I,L){A+=O.visit(I),L<z-1&&(A+=", ")}),A},visit:function(C){if(!C)return"";var A="";if(C instanceof Array)return O.visit_array(C,A);if(C.type){var z=O["visit_"+C.type];if(z)return z(C);throw Error("Missing visitor visit_"+C.type)}else throw Error("Invalid node.")}};return function(C){return O.visit(C)}}();var GradientParser=GradientParser||{};GradientParser.parse=function(){var O={linearGradient:/^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,repeatingLinearGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,radialGradient:/^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,repeatingRadialGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,sideOrCorner:/^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,extentKeywords:/^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,positionKeywords:/^(left|center|right|top|bottom)/i,pixelValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,percentageValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,emValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,angleValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,startCall:/^\(/,endCall:/^\)/,comma:/^,/,hexColor:/^\#([0-9a-fA-F]+)/,literalColor:/^([a-zA-Z]+)/,rgbColor:/^rgb/i,rgbaColor:/^rgba/i,number:/^(([0-9]*\.[0-9]+)|([0-9]+\.?))/},C="";function A(xt){var Lt=new Error(C+": "+xt);throw Lt.source=C,Lt}function z(){var xt=I();return C.length>0&&A("Invalid input not EOF"),xt}function I(){return Ce(L)}function L(){return K("linear-gradient",O.linearGradient,ne)||K("repeating-linear-gradient",O.repeatingLinearGradient,ne)||K("radial-gradient",O.radialGradient,ue)||K("repeating-radial-gradient",O.repeatingRadialGradient,ue)}function K(xt,Lt,dt){return te(Lt,function(Pt){var br=dt();return br&&(It(O.comma)||A("Missing comma before color stops")),{type:xt,orientation:br,colorStops:Ce(Ge)}})}function te(xt,Lt){var dt=It(xt);if(dt){It(O.startCall)||A("Missing (");var Pt=Lt(dt);return It(O.endCall)||A("Missing )"),Pt}}function ne(){return ie()||oe()}function ie(){return _t("directional",O.sideOrCorner,1)}function oe(){return _t("angular",O.angleValue,1)}function ue(){var xt,Lt=de(),dt;return Lt&&(xt=[],xt.push(Lt),dt=C,It(O.comma)&&(Lt=de(),Lt?xt.push(Lt):C=dt)),xt}function de(){var xt=he()||fe();if(xt)xt.at=xe();else{var Lt=be();if(Lt){xt=Lt;var dt=xe();dt&&(xt.at=dt)}else{var Pt=Se();Pt&&(xt={type:"default-radial",at:Pt})}}return xt}function he(){var xt=_t("shape",/^(circle)/i,0);return xt&&(xt.style=At()||be()),xt}function fe(){var xt=_t("shape",/^(ellipse)/i,0);return xt&&(xt.style=Mt()||be()),xt}function be(){return _t("extent-keyword",O.extentKeywords,1)}function xe(){if(_t("position",/^at/,0)){var xt=Se();return xt||A("Missing positioning value"),xt}}function Se(){var xt=Fe();if(xt.x||xt.y)return{type:"position",value:xt}}function Fe(){return{x:Mt(),y:Mt()}}function Ce(xt){var Lt=xt(),dt=[];if(Lt)for(dt.push(Lt);It(O.comma);)Lt=xt(),Lt?dt.push(Lt):A("One extra comma");return dt}function Ge(){var xt=Ve();return xt||A("Expected color definition"),xt.length=Mt(),xt}function Ve(){return Ze()||Xe()||ct()||pt()}function pt(){return _t("literal",O.literalColor,0)}function Ze(){return _t("hex",O.hexColor,1)}function ct(){return te(O.rgbColor,function(){return{type:"rgb",value:Ce(We)}})}function Xe(){return te(O.rgbaColor,function(){return{type:"rgba",value:Ce(We)}})}function We(){return It(O.number)[1]}function Mt(){return _t("%",O.percentageValue,1)||jt()||At()}function jt(){return _t("position-keyword",O.positionKeywords,1)}function At(){return _t("px",O.pixelValue,1)||_t("em",O.emValue,1)}function _t(xt,Lt,dt){var Pt=It(Lt);if(Pt)return{type:xt,value:Pt[dt]}}function It(xt){var Lt,dt;return dt=/^[\n\r\t\s]+/.exec(C),dt&&zt(dt[0].length),Lt=xt.exec(C),Lt&&zt(Lt[0].length),Lt}function zt(xt){C=C.substr(xt)}return function(xt){return C=xt.toString(),z()}}();var parse=GradientParser.parse;GradientParser.stringify;function parseCssGradient(O){const C=parse(trimCssGradient(O));if(C.length===0)throw new Error("Invalid CSS gradient.");if(C.length!==1)throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");const A=C[0],z=typeFromCssType(A.type),I=stopsFromCssStops(A.colorStops),L=angleFromCssOrientation(A.orientation);return{type:z,stops:I,angle:L}}function typeFromCssType(O){const C={"linear-gradient":0,"radial-gradient":1};if(!(O in C))throw new Error(`Unsupported gradient type "${O}"`);return C[O]}function stopsFromCssStops(O){const C=offsetsFromCssColorStops(O),A=[],z=new Color;for(let I=0;I<O.length;I++){const L=colorAsStringFromCssStop(O[I]),K=z.setValue(L).toArray();A.push({offset:C[I],color:K.slice(0,3),alpha:K[3]})}return A}function colorAsStringFromCssStop(O){switch(O.type){case"hex":return`#${O.value}`;case"literal":return O.value;default:return`${O.type}(${O.value.join(",")})`}}function offsetsFromCssColorStops(O){const C=[];for(let L=0;L<O.length;L++){const K=O[L];let te=-1;K.type==="literal"&&K.length&&"type"in K.length&&K.length.type==="%"&&"value"in K.length&&(te=parseFloat(K.length.value)/100),C.push(te)}const z=L=>{for(let K=L;K<C.length;K++)if(C[K]!==-1)return{indexDelta:K-L,offset:C[K]};return{indexDelta:C.length-1-L,offset:1}};let I=0;for(let L=0;L<C.length;L++){const K=C[L];if(K!==-1)I=K;else if(L===0)C[L]=0;else if(L+1===C.length)C[L]=1;else{const te=z(L),ie=(te.offset-I)/(1+te.indexDelta);for(let oe=0;oe<=te.indexDelta;oe++)C[L+oe]=I+(oe+1)*ie;L+=te.indexDelta,I=C[L]}}return C.map(fixFloatRounding)}function fixFloatRounding(O){return O.toString().length>6?parseFloat(O.toString().substring(0,6)):O}function angleFromCssOrientation(O){if(typeof O=="undefined")return 0;if("type"in O&&"value"in O)switch(O.type){case"angular":return parseFloat(O.value);case"directional":return angleFromDirectionalValue(O.value)}return 0}function angleFromDirectionalValue(O){const C={left:270,top:0,bottom:180,right:90,"left top":315,"top left":315,"left bottom":225,"bottom left":225,"right top":45,"top right":45,"right bottom":135,"bottom right":135};if(!(O in C))throw new Error(`Unsupported directional value "${O}"`);return C[O]}function trimCssGradient(O){let C=O.replace(/\s{2,}/gu," ");return C=C.replace(/;/g,""),C=C.replace(/ ,/g,","),C=C.replace(/\( /g,"("),C=C.replace(/ \)/g,")"),C.trim()}var __defProp$o=Object.defineProperty,__defNormalProp$o=(O,C,A)=>C in O?__defProp$o(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$o=(O,C,A)=>(__defNormalProp$o(O,typeof C!="symbol"?C+"":C,A),A);const ANGLE_OFFSET=90;function sortColorStops(O){return[...O].sort((C,A)=>C.offset-A.offset)}const _ColorGradientFilter=class Br extends Filter{constructor(C){var L,K,te;if(C&&"css"in C?C={...parseCssGradient(C.css||""),alpha:(L=C.alpha)!=null?L:Br.defaults.alpha,maxColors:(K=C.maxColors)!=null?K:Br.defaults.maxColors}:C={...Br.defaults,...C},!C.stops||C.stops.length<2)throw new Error("ColorGradientFilter requires at least 2 color stops.");const A=GpuProgram.from({vertex:{source:source$r,entryPoint:"mainVertex"},fragment:{source:source$r,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex,fragment:fragment$r,name:"color-gradient-filter"}),I=32;super({gpuProgram:A,glProgram:z,resources:{baseUniforms:{uOptions:{value:[C.type,(te=C.angle)!=null?te:ANGLE_OFFSET,C.alpha,C.replace?1:0],type:"vec4<f32>"},uCounts:{value:[C.stops.length,C.maxColors],type:"vec2<f32>"}},stopsUniforms:{uColors:{value:new Float32Array(I*3),type:"vec3<f32>",size:I},uStops:{value:new Float32Array(I*4),type:"vec4<f32>",size:I}}}}),__publicField$o(this,"baseUniforms"),__publicField$o(this,"stopsUniforms"),__publicField$o(this,"_stops",[]),this.baseUniforms=this.resources.baseUniforms.uniforms,this.stopsUniforms=this.resources.stopsUniforms.uniforms,Object.assign(this,C)}get stops(){return this._stops}set stops(C){const A=sortColorStops(C),z=new Color;let I,L,K;for(let te=0;te<A.length;te++){z.setValue(A[te].color);const ne=te*3;[I,L,K]=z.toArray(),this.stopsUniforms.uColors[ne]=I,this.stopsUniforms.uColors[ne+1]=L,this.stopsUniforms.uColors[ne+2]=K,this.stopsUniforms.uStops[te*4]=A[te].offset,this.stopsUniforms.uStops[te*4+1]=A[te].alpha}this.baseUniforms.uCounts[0]=A.length,this._stops=A}get type(){return this.baseUniforms.uOptions[0]}set type(C){this.baseUniforms.uOptions[0]=C}get angle(){return this.baseUniforms.uOptions[1]+ANGLE_OFFSET}set angle(C){this.baseUniforms.uOptions[1]=C-ANGLE_OFFSET}get alpha(){return this.baseUniforms.uOptions[2]}set alpha(C){this.baseUniforms.uOptions[2]=C}get maxColors(){return this.baseUniforms.uCounts[1]}set maxColors(C){this.baseUniforms.uCounts[1]=C}get replace(){return this.baseUniforms.uOptions[3]>.5}set replace(C){this.baseUniforms.uOptions[3]=C?1:0}};__publicField$o(_ColorGradientFilter,"LINEAR",0),__publicField$o(_ColorGradientFilter,"RADIAL",1),__publicField$o(_ColorGradientFilter,"CONIC",2),__publicField$o(_ColorGradientFilter,"defaults",{type:_ColorGradientFilter.LINEAR,stops:[{offset:0,color:16711680,alpha:1},{offset:1,color:255,alpha:1}],alpha:1,angle:90,maxColors:0,replace:!1});var fragment$q=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform float uMix;
uniform float uSize;
uniform float uSliceSize;
uniform float uSlicePixelSize;
uniform float uSliceInnerSize;

void main() {
    vec4 color = texture(uTexture, vTextureCoord.xy);
    vec4 adjusted;

    if (color.a > 0.0) {
        color.rgb /= color.a;
        float innerWidth = uSize - 1.0;
        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);
        float zSlice1 = min(zSlice0 + 1.0, innerWidth);
        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;
        float s0 = xOffset + (zSlice0 * uSliceSize);
        float s1 = xOffset + (zSlice1 * uSliceSize);
        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);
        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));
        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));
        float zOffset = fract(color.b * innerWidth);
        adjusted = mix(slice0Color, slice1Color, zOffset);

        color.rgb *= color.a;
    }

    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);

}`,source$q=`struct ColorMapUniforms {
  uMix: f32,
  uSize: f32,
  uSliceSize: f32,
  uSlicePixelSize: f32,
  uSliceInnerSize: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;
@group(1) @binding(2) var uMapSampler: sampler;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);

  var adjusted: vec4<f32>;

  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);
  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;
  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);
  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);
  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;
  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);
  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);
  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);
  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));
  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));
  let zOffset: f32 = fract(color.b * innerWidth);
  adjusted = mix(slice0Color, slice1Color, zOffset);
  altColor = vec4<f32>(color.rgb * color.a, color.a);

  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);

  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);
}`,__defProp$n=Object.defineProperty,__defNormalProp$n=(O,C,A)=>C in O?__defProp$n(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$n=(O,C,A)=>(__defNormalProp$n(O,typeof C!="symbol"?C+"":C,A),A);const _ColorMapFilter=class dn extends Filter{constructor(...C){var L;let A=(L=C[0])!=null?L:{};if((A instanceof Texture||A instanceof TextureSource)&&(deprecation("6.0.0","ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }"),A={colorMap:A},C[1]!==void 0&&(A.nearest=C[1]),C[2]!==void 0&&(A.mix=C[2])),A={...dn.DEFAULT_OPTIONS,...A},!A.colorMap)throw Error("No color map texture source was provided to ColorMapFilter");const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$q,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$q,name:"color-map-filter"});super({gpuProgram:z,glProgram:I,resources:{colorMapUniforms:{uMix:{value:A.mix,type:"f32"},uSize:{value:0,type:"f32"},uSliceSize:{value:0,type:"f32"},uSlicePixelSize:{value:0,type:"f32"},uSliceInnerSize:{value:0,type:"f32"}},uMapTexture:A.colorMap.source,uMapSampler:A.colorMap.source.style}}),__publicField$n(this,"uniforms"),__publicField$n(this,"_size",0),__publicField$n(this,"_sliceSize",0),__publicField$n(this,"_slicePixelSize",0),__publicField$n(this,"_sliceInnerSize",0),__publicField$n(this,"_nearest",!1),__publicField$n(this,"_scaleMode","linear"),__publicField$n(this,"_colorMap"),this.uniforms=this.resources.colorMapUniforms.uniforms,Object.assign(this,A)}get mix(){return this.uniforms.uMix}set mix(C){this.uniforms.uMix=C}get colorSize(){return this._size}get colorMap(){return this._colorMap}set colorMap(C){if(!C||C===this.colorMap)return;const A=C instanceof Texture?C.source:C;A.style.scaleMode=this._scaleMode,A.autoGenerateMipmaps=!1,this._size=A.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms.uSize=this._size,this.uniforms.uSliceSize=this._sliceSize,this.uniforms.uSlicePixelSize=this._slicePixelSize,this.uniforms.uSliceInnerSize=this._sliceInnerSize,this.resources.uMapTexture=A,this._colorMap=C}get nearest(){return this._nearest}set nearest(C){this._nearest=C,this._scaleMode=C?"nearest":"linear";const A=this._colorMap;A&&A.source&&(A.source.scaleMode=this._scaleMode,A.source.autoGenerateMipmaps=!1,A.source.style.update(),A.source.update())}updateColorMap(){const C=this._colorMap;C!=null&&C.source&&(C.source.update(),this.colorMap=C)}destroy(){var C;(C=this._colorMap)==null||C.destroy(),super.destroy()}};__publicField$n(_ColorMapFilter,"DEFAULT_OPTIONS",{colorMap:Texture.WHITE,nearest:!1,mix:1});var fragment$p=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uColor;
uniform float uAlpha;

void main(void) {
    vec4 c = texture(uTexture, vTextureCoord);
    finalColor = vec4(mix(c.rgb, uColor.rgb, c.a * uAlpha), c.a);
}
`,source$p=`struct ColorOverlayUniforms {
    uColor: vec3<f32>,
    uAlpha: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    let c = textureSample(uTexture, uSampler, uv);
    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb, c.a * colorOverlayUniforms.uAlpha), c.a);
}
`,__defProp$m=Object.defineProperty,__defNormalProp$m=(O,C,A)=>C in O?__defProp$m(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$m=(O,C,A)=>(__defNormalProp$m(O,typeof C!="symbol"?C+"":C,A),A);const _ColorOverlayFilter=class fn extends Filter{constructor(...C){var L,K;let A=(L=C[0])!=null?L:{};(typeof A=="number"||Array.isArray(A)||A instanceof Float32Array)&&(deprecation("6.0.0","ColorOverlayFilter constructor params are now options object. See params: { color, alpha }"),A={color:A},C[1]!==void 0&&(A.alpha=C[1])),A={...fn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$p,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$p,name:"color-overlay-filter"});super({gpuProgram:z,glProgram:I,resources:{colorOverlayUniforms:{uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:A.alpha,type:"f32"}}}}),__publicField$m(this,"uniforms"),__publicField$m(this,"_color"),this.uniforms=this.resources.colorOverlayUniforms.uniforms,this._color=new Color,this.color=(K=A.color)!=null?K:0}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}};__publicField$m(_ColorOverlayFilter,"DEFAULT_OPTIONS",{color:0,alpha:1});var fragment$o=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uOriginalColor;
uniform vec3 uTargetColor;
uniform float uTolerance;

void main(void) {
    vec4 c = texture(uTexture, vTextureCoord);
    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));
    float colorDistance = length(colorDiff);
    float doReplace = step(colorDistance, uTolerance);
    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);
}
`,source$o=`struct ColorReplaceUniforms {
  uOriginalColor: vec3<f32>,
  uTargetColor: vec3<f32>,
  uTolerance: f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;

@fragment
fn mainFragment(
   @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);

  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));
  let colorDistance: f32 = length(colorDiff);
  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);

  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);
}`,__defProp$l=Object.defineProperty,__defNormalProp$l=(O,C,A)=>C in O?__defProp$l(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$l=(O,C,A)=>(__defNormalProp$l(O,typeof C!="symbol"?C+"":C,A),A);const _ColorReplaceFilter=class pn extends Filter{constructor(...C){var L,K,te;let A=(L=C[0])!=null?L:{};(typeof A=="number"||Array.isArray(A)||A instanceof Float32Array)&&(deprecation("6.0.0","ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }"),A={originalColor:A},C[1]!==void 0&&(A.targetColor=C[1]),C[2]!==void 0&&(A.tolerance=C[2])),A={...pn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$o,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$o,name:"color-replace-filter"});super({gpuProgram:z,glProgram:I,resources:{colorReplaceUniforms:{uOriginalColor:{value:new Float32Array(3),type:"vec3<f32>"},uTargetColor:{value:new Float32Array(3),type:"vec3<f32>"},uTolerance:{value:A.tolerance,type:"f32"}}}}),__publicField$l(this,"uniforms"),__publicField$l(this,"_originalColor"),__publicField$l(this,"_targetColor"),this.uniforms=this.resources.colorReplaceUniforms.uniforms,this._originalColor=new Color,this._targetColor=new Color,this.originalColor=(K=A.originalColor)!=null?K:16711680,this.targetColor=(te=A.targetColor)!=null?te:0,Object.assign(this,A)}get originalColor(){return this._originalColor.value}set originalColor(C){this._originalColor.setValue(C);const[A,z,I]=this._originalColor.toArray();this.uniforms.uOriginalColor[0]=A,this.uniforms.uOriginalColor[1]=z,this.uniforms.uOriginalColor[2]=I}get targetColor(){return this._targetColor.value}set targetColor(C){this._targetColor.setValue(C);const[A,z,I]=this._targetColor.toArray();this.uniforms.uTargetColor[0]=A,this.uniforms.uTargetColor[1]=z,this.uniforms.uTargetColor[2]=I}get tolerance(){return this.uniforms.uTolerance}set tolerance(C){this.uniforms.uTolerance=C}set newColor(C){deprecation("6.0.0","ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"),this.targetColor=C}get newColor(){return deprecation("6.0.0","ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"),this.targetColor}set epsilon(C){deprecation("6.0.0","ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"),this.tolerance=C}get epsilon(){return deprecation("6.0.0","ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"),this.tolerance}};__publicField$l(_ColorReplaceFilter,"DEFAULT_OPTIONS",{originalColor:16711680,targetColor:0,tolerance:.4});var fragment$n=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTexelSize;
uniform mat3 uMatrix;

void main(void)
{
    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left
    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center
    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right

    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left
    vec4 c22 = texture(uTexture, vTextureCoord); // mid center
    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right

    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left
    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center
    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right

    finalColor =
        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +
        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +
        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];

    finalColor.a = c22.a;
}`,source$n=`struct ConvolutionUniforms {
    uMatrix: mat3x3<f32>,
    uTexelSize: vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let texelSize = convolutionUniforms.uTexelSize;
    let matrix = convolutionUniforms.uMatrix;

    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left
    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center
    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right

    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left
    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center
    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right

    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left
    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center
    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right

    var finalColor: vec4<f32> = vec4<f32>(
        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +
        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +
        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]
    );

    finalColor.a = c22.a;

    return finalColor;
}`,__defProp$k=Object.defineProperty,__defNormalProp$k=(O,C,A)=>C in O?__defProp$k(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$k=(O,C,A)=>(__defNormalProp$k(O,typeof C!="symbol"?C+"":C,A),A);const _ConvolutionFilter=class mn extends Filter{constructor(...C){var te,ne,ie;let A=(te=C[0])!=null?te:{};Array.isArray(A)&&(deprecation("6.0.0","ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }"),A={matrix:A},C[1]!==void 0&&(A.width=C[1]),C[2]!==void 0&&(A.height=C[2])),A={...mn.DEFAULT_OPTIONS,...A};const z=(ne=A.width)!=null?ne:200,I=(ie=A.height)!=null?ie:200,L=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$n,entryPoint:"mainFragment"}}),K=GlProgram.from({vertex:vertex$1,fragment:fragment$n,name:"convolution-filter"});super({gpuProgram:L,glProgram:K,resources:{convolutionUniforms:{uMatrix:{value:A.matrix,type:"mat3x3<f32>"},uTexelSize:{value:{x:1/z,y:1/I},type:"vec2<f32>"}}}}),__publicField$k(this,"uniforms"),this.uniforms=this.resources.convolutionUniforms.uniforms,this.width=z,this.height=I}get matrix(){return this.uniforms.uMatrix}set matrix(C){C.forEach((A,z)=>{this.uniforms.uMatrix[z]=A})}get width(){return 1/this.uniforms.uTexelSize.x}set width(C){this.uniforms.uTexelSize.x=1/C}get height(){return 1/this.uniforms.uTexelSize.y}set height(C){this.uniforms.uTexelSize.y=1/C}};__publicField$k(_ConvolutionFilter,"DEFAULT_OPTIONS",{matrix:new Float32Array(9),width:200,height:200});var fragment$m=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;

void main(void)
{
    float lum = length(texture(uTexture, vTextureCoord.xy).rgb);

    finalColor = vec4(1.0, 1.0, 1.0, 1.0);

    if (lum < 1.00)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)
        {
            finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.75)
    {
        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)
        {
            finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.50)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)
        {
            finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.3)
    {
        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)
        {
            finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }
}
`,source$m=`@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let lum: f32 = length(textureSample(uTexture, uSampler, uv).rgb);

    if (lum < 1.00)
    {
        if (modulo(position.x + position.y, 10.0) == 0.0)
        {
            return vec4<f32>(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.75)
    {
        if (modulo(position.x - position.y, 10.0) == 0.0)
        {
            return vec4<f32>(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.50)
    {
        if (modulo(position.x + position.y - 5.0, 10.0) == 0.0)
        {
            return vec4<f32>(0.0, 0.0, 0.0, 1.0);
        }
    }

    if (lum < 0.3)
    {
        if (modulo(position.x - position.y - 5.0, 10.0) == 0.0)
        {
            return vec4<f32>(0.0, 0.0, 0.0, 1.0);
        }
    }

    return vec4<f32>(1.0);
}

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}`;class CrossHatchFilter extends Filter{constructor(){const C=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$m,entryPoint:"mainFragment"}}),A=GlProgram.from({vertex:vertex$1,fragment:fragment$m,name:"cross-hatch-filter"});super({gpuProgram:C,glProgram:A,resources:{}})}}var fragment$l=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec4 uLine;
uniform vec2 uNoise;
uniform vec3 uVignette;
uniform float uSeed;
uniform float uTime;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

const float SQRT_2 = 1.414213;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float vignette(vec3 co, vec2 coord)
{
    float outter = SQRT_2 - uVignette[0] * SQRT_2;
    vec2 dir = vec2(0.5) - coord;
    dir.y *= uDimensions.y / uDimensions.x;
    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);
    return darker + (1.0 - darker) * (1.0 - uVignette[1]);
}

float noise(vec2 coord)
{
    vec2 pixelCoord = coord * uInputSize.xy;
    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}

vec3 interlaceLines(vec3 co, vec2 coord)
{
    vec3 color = co;

    float curvature = uLine[0];
    float lineWidth = uLine[1];
    float lineContrast = uLine[2];
    float verticalLine = uLine[3];

    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);

    float _c = curvature > 0. ? curvature : 1.;
    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;
    vec2 uv = dir * k;
    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;
    v *= min(1.0, 2.0 / lineWidth ) / _c;
    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;
    color *= j;

    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);
    color *= 0.99 + ceil(segment) * 0.015;

    return color;
}

void main(void)
{
    finalColor = texture(uTexture, vTextureCoord);
    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;

    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
    {
        float n = noise(vTextureCoord);
        finalColor += vec4(n, n, n, finalColor.a);
    }

    if (uVignette[0] > 0.)
    {
        float v = vignette(finalColor.rgb, coord);
        finalColor *= vec4(v, v, v, finalColor.a);
    }

    if (uLine[1] > 0.0)
    {
        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  
    }
}
`,source$l=`struct CRTUniforms {
    uLine: vec4<f32>,
    uNoise: vec2<f32>,
    uVignette: vec3<f32>,
    uSeed: f32,
    uTime: f32,
    uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;

  let uNoise = crtUniforms.uNoise;

  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
  {
    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);
  }

  if (crtUniforms.uVignette[0] > 0.)
  {
    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);
  }

  if (crtUniforms.uLine[1] > 0.0)
  {
    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  
  }

  return color;
}

const SQRT_2: f32 = 1.414213;

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn rand(co: vec2<f32>) -> f32
{
  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32
{
  let uVignette = crtUniforms.uVignette;
  let uDimensions = crtUniforms.uDimensions;
  
  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;
  var dir: vec2<f32> = vec2<f32>(0.5) - coord;
  dir.y *= uDimensions.y / uDimensions.x;
  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);
  return darker + (1.0 - darker) * (1.0 - uVignette[1]);
}

fn noise(coord: vec2<f32>) -> f32
{
  let uNoise = crtUniforms.uNoise;
  let uSeed = crtUniforms.uSeed;

  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;
  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}

fn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>
{
  var color = co;

  let uDimensions = crtUniforms.uDimensions;

  let curvature: f32 = crtUniforms.uLine[0];
  let lineWidth: f32 = crtUniforms.uLine[1];
  let lineContrast: f32 = crtUniforms.uLine[2];
  let verticalLine: f32 = crtUniforms.uLine[3];

  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);

  let _c: f32 = select(1., curvature, curvature > 0.);
  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);
  let uv: vec2<f32> = dir * k;
  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;
  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;
  color *= j;

  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);
  color *= 0.99 + ceil(segment) * 0.015;

  return color;
}`,__defProp$j=Object.defineProperty,__defNormalProp$j=(O,C,A)=>C in O?__defProp$j(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$j=(O,C,A)=>(__defNormalProp$j(O,typeof C!="symbol"?C+"":C,A),A);const _CRTFilter=class gn extends Filter{constructor(C){C={...gn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$l,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$l,name:"crt-filter"});super({gpuProgram:A,glProgram:z,resources:{crtUniforms:{uLine:{value:new Float32Array(4),type:"vec4<f32>"},uNoise:{value:new Float32Array(2),type:"vec2<f32>"},uVignette:{value:new Float32Array(3),type:"vec3<f32>"},uSeed:{value:C.seed,type:"f32"},uTime:{value:C.time,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField$j(this,"uniforms"),__publicField$j(this,"seed"),__publicField$j(this,"time"),this.uniforms=this.resources.crtUniforms.uniforms,Object.assign(this,C)}apply(C,A,z,I){this.uniforms.uDimensions[0]=A.frame.width,this.uniforms.uDimensions[1]=A.frame.height,this.uniforms.uSeed=this.seed,this.uniforms.uTime=this.time,C.applyFilter(this,A,z,I)}get curvature(){return this.uniforms.uLine[0]}set curvature(C){this.uniforms.uLine[0]=C}get lineWidth(){return this.uniforms.uLine[1]}set lineWidth(C){this.uniforms.uLine[1]=C}get lineContrast(){return this.uniforms.uLine[2]}set lineContrast(C){this.uniforms.uLine[2]=C}get verticalLine(){return this.uniforms.uLine[3]>.5}set verticalLine(C){this.uniforms.uLine[3]=C?1:0}get noise(){return this.uniforms.uNoise[0]}set noise(C){this.uniforms.uNoise[0]=C}get noiseSize(){return this.uniforms.uNoise[1]}set noiseSize(C){this.uniforms.uNoise[1]=C}get vignetting(){return this.uniforms.uVignette[0]}set vignetting(C){this.uniforms.uVignette[0]=C}get vignettingAlpha(){return this.uniforms.uVignette[1]}set vignettingAlpha(C){this.uniforms.uVignette[1]=C}get vignettingBlur(){return this.uniforms.uVignette[2]}set vignettingBlur(C){this.uniforms.uVignette[2]=C}};__publicField$j(_CRTFilter,"DEFAULT_OPTIONS",{curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0,seed:0});var fragment$k=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uAngle;
uniform float uScale;
uniform bool uGrayScale;

uniform vec4 uInputSize;

float pattern()
{
    float s = sin(uAngle), c = cos(uAngle);
    vec2 tex = vTextureCoord * uInputSize.xy;
    vec2 point = vec2(
        c * tex.x - s * tex.y,
        s * tex.x + c * tex.y
    ) * uScale;
    return (sin(point.x) * sin(point.y)) * 4.0;
    }

    void main()
    {
    vec4 color = texture(uTexture, vTextureCoord);
    vec3 colorRGB = vec3(color);

    if (uGrayScale)
    {
        colorRGB = vec3(color.r + color.g + color.b) / 3.0;
    }

    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);
}
`,source$k=`struct DotUniforms {
  uScale:f32,
  uAngle:f32,
  uGrayScale:f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));
  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead 
  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);

  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);
}

fn pattern(uv: vec2<f32>) -> f32
{
  let s: f32 = sin(dotUniforms.uAngle);
  let c: f32 = cos(dotUniforms.uAngle);
  
  let tex: vec2<f32> = uv * gfu.uInputSize.xy;
  
  let p: vec2<f32> = vec2<f32>(
      c * tex.x - s * tex.y,
      s * tex.x + c * tex.y
  ) * dotUniforms.uScale;

  return (sin(p.x) * sin(p.y)) * 4.0;
}`,__defProp$i=Object.defineProperty,__defNormalProp$i=(O,C,A)=>C in O?__defProp$i(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$i=(O,C,A)=>(__defNormalProp$i(O,typeof C!="symbol"?C+"":C,A),A);const _DotFilter=class xn extends Filter{constructor(...C){var K;let A=(K=C[0])!=null?K:{};typeof A=="number"&&(deprecation("6.0.0","DotFilter constructor params are now options object. See params: { scale, angle, grayscale }"),A={scale:A},C[1]!==void 0&&(A.angle=C[1]),C[2]!==void 0&&(A.grayscale=C[2])),A={...xn.DEFAULT_OPTIONS,...A};const z={uScale:{value:A.scale,type:"f32"},uAngle:{value:A.angle,type:"f32"},uGrayScale:{value:A.grayscale?1:0,type:"f32"}},I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$k,entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$k,name:"dot-filter"});super({gpuProgram:I,glProgram:L,resources:{dotUniforms:z}})}get scale(){return this.resources.dotUniforms.uniforms.uScale}set scale(C){this.resources.dotUniforms.uniforms.uScale=C}get angle(){return this.resources.dotUniforms.uniforms.uAngle}set angle(C){this.resources.dotUniforms.uniforms.uAngle=C}get grayscale(){return this.resources.dotUniforms.uniforms.uGrayScale===1}set grayscale(C){this.resources.dotUniforms.uniforms.uGrayScale=C?1:0}};__publicField$i(_DotFilter,"DEFAULT_OPTIONS",{scale:1,angle:5,grayscale:!0});var fragment$j=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uAlpha;
uniform vec3 uColor;
uniform vec2 uOffset;

uniform vec4 uInputSize;

void main(void){
    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);

    // Premultiply alpha
    sample.rgb = uColor.rgb * sample.a;

    // alpha user alpha
    sample *= uAlpha;

    finalColor = sample;
}`,source$j=`struct DropShadowUniforms {
  uAlpha: f32,
  uColor: vec3<f32>,
  uOffset: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);

  // Premultiply alpha
  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);
  // alpha user alpha
  color *= dropShadowUniforms.uAlpha;

  return color;
}`,__defProp$h=Object.defineProperty,__defNormalProp$h=(O,C,A)=>C in O?__defProp$h(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$h=(O,C,A)=>(__defNormalProp$h(O,typeof C!="symbol"?C+"":C,A),A);const _DropShadowFilter=class vn extends Filter{constructor(C){var I,L;C={...vn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$j,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$j,name:"drop-shadow-filter"});super({gpuProgram:A,glProgram:z,resources:{dropShadowUniforms:{uAlpha:{value:C.alpha,type:"f32"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uOffset:{value:C.offset,type:"vec2<f32>"}}},resolution:C.resolution}),__publicField$h(this,"uniforms"),__publicField$h(this,"shadowOnly",!1),__publicField$h(this,"_color"),__publicField$h(this,"_blurFilter"),__publicField$h(this,"_basePass"),this.uniforms=this.resources.dropShadowUniforms.uniforms,this._color=new Color,this.color=(I=C.color)!=null?I:0,this._blurFilter=new KawaseBlurFilter({strength:(L=C.kernels)!=null?L:C.blur,quality:C.kernels?void 0:C.quality}),this._basePass=new Filter({gpuProgram:GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:`
                    @group(0) @binding(1) var uTexture: texture_2d<f32>; 
                    @group(0) @binding(2) var uSampler: sampler;
                    @fragment
                    fn mainFragment(
                        @builtin(position) position: vec4<f32>,
                        @location(0) uv : vec2<f32>
                    ) -> @location(0) vec4<f32> {
                        return textureSample(uTexture, uSampler, uv);
                    }
                    `,entryPoint:"mainFragment"}}),glProgram:GlProgram.from({vertex:vertex$1,fragment:`
                in vec2 vTextureCoord;
                out vec4 finalColor;
                uniform sampler2D uTexture;

                void main(void){
                    finalColor = texture(uTexture, vTextureCoord);
                }
                `,name:"drop-shadow-filter"}),resources:{}}),Object.assign(this,C)}apply(C,A,z,I){const L=TexturePool.getSameSizeTexture(A);C.applyFilter(this,A,L,!0),this._blurFilter.apply(C,L,z,I),this.shadowOnly||C.applyFilter(this._basePass,A,z,!1),TexturePool.returnTexture(L)}get offset(){return this.uniforms.uOffset}set offset(C){this.uniforms.uOffset=C,this._updatePadding()}get offsetX(){return this.offset.x}set offsetX(C){this.offset.x=C,this._updatePadding()}get offsetY(){return this.offset.y}set offsetY(C){this.offset.y=C,this._updatePadding()}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}get blur(){return this._blurFilter.strength}set blur(C){this._blurFilter.strength=C,this._updatePadding()}get quality(){return this._blurFilter.quality}set quality(C){this._blurFilter.quality=C,this._updatePadding()}get kernels(){return this._blurFilter.kernels}set kernels(C){this._blurFilter.kernels=C}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(C){typeof C=="number"&&(C={x:C,y:C}),Array.isArray(C)&&(C={x:C[0],y:C[1]}),this._blurFilter.pixelSize=C}get pixelSizeX(){return this._blurFilter.pixelSizeX}set pixelSizeX(C){this._blurFilter.pixelSizeX=C}get pixelSizeY(){return this._blurFilter.pixelSizeY}set pixelSizeY(C){this._blurFilter.pixelSizeY=C}_updatePadding(){const C=Math.max(Math.abs(this.offsetX),Math.abs(this.offsetY));this.padding=C+this.blur*2+this.quality*4}};__publicField$h(_DropShadowFilter,"DEFAULT_OPTIONS",{offset:{x:4,y:4},color:0,alpha:.5,shadowOnly:!1,kernels:void 0,blur:2,quality:3,pixelSize:{x:1,y:1},resolution:1});var fragment$i=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uStrength;

uniform vec4 uInputSize;

void main(void)
{
	vec2 onePixel = vec2(1.0 / uInputSize);

	vec4 color;

	color.rgb = vec3(0.5);

	color -= texture(uTexture, vTextureCoord - onePixel) * uStrength;
	color += texture(uTexture, vTextureCoord + onePixel) * uStrength;

	color.rgb = vec3((color.r + color.g + color.b) / 3.0);

	float alpha = texture(uTexture, vTextureCoord).a;

	finalColor = vec4(color.rgb * alpha, alpha);
}
`,source$i=`struct EmbossUniforms {
  uStrength:f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> embossUniforms : EmbossUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let onePixel: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);
	var color: vec3<f32> = vec3<f32>(0.5);

	color -= (textureSample(uTexture, uSampler, uv - onePixel) * embossUniforms.uStrength).rgb;
	color += (textureSample(uTexture, uSampler, uv + onePixel) * embossUniforms.uStrength).rgb;

	color = vec3<f32>((color.r + color.g + color.b) / 3.0);

	let blendColor: vec4<f32> = textureSample(uTexture, uSampler, uv);

	return vec4<f32>(color.rgb * blendColor.a, blendColor.a);
}`,__defProp$g=Object.defineProperty,__defNormalProp$g=(O,C,A)=>C in O?__defProp$g(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$g=(O,C,A)=>(__defNormalProp$g(O,typeof C!="symbol"?C+"":C,A),A);class EmbossFilter extends Filter{constructor(C=5){const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$i,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$i,name:"emboss-filter"});super({gpuProgram:A,glProgram:z,resources:{embossUniforms:{uStrength:{value:C,type:"f32"}}}}),__publicField$g(this,"uniforms"),this.uniforms=this.resources.embossUniforms.uniforms}get strength(){return this.uniforms.uStrength}set strength(C){this.uniforms.uStrength=C}}var fragment$h=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uDisplacementMap;
uniform float uSeed;
uniform vec2 uDimensions;
uniform float uAspect;
uniform float uFillMode;
uniform float uOffset;
uniform float uDirection;
uniform vec2 uRed;
uniform vec2 uGreen;
uniform vec2 uBlue;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const int TRANSPARENT = 0;
const int ORIGINAL = 1;
const int LOOP = 2;
const int CLAMP = 3;
const int MIRROR = 4;

void main(void)
{
    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;

    if (coord.x > 1.0 || coord.y > 1.0) {
        return;
    }

    float sinDir = sin(uDirection);
    float cosDir = cos(uDirection);

    float cx = coord.x - 0.5;
    float cy = (coord.y - 0.5) * uAspect;
    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;

    // displacementMap: repeat
    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);

    // displacementMap: mirror
    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);

    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));

    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);

    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);

    int fillMode = int(uFillMode);

    if (fillMode == CLAMP) {
        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    } else {
        if( coord.x > uInputClamp.z ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.x -= uInputClamp.z;
            } else if (fillMode == MIRROR) {
                coord.x = uInputClamp.z * 2.0 - coord.x;
            }
        } else if( coord.x < uInputClamp.x ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.x += uInputClamp.z;
            } else if (fillMode == MIRROR) {
                coord.x *= -uInputClamp.z;
            }
        }

        if( coord.y > uInputClamp.w ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.y -= uInputClamp.w;
            } else if (fillMode == MIRROR) {
                coord.y = uInputClamp.w * 2.0 - coord.y;
            }
        } else if( coord.y < uInputClamp.y ) {
            if (fillMode == TRANSPARENT) {
                discard;
            } else if (fillMode == LOOP) {
                coord.y += uInputClamp.w;
            } else if (fillMode == MIRROR) {
                coord.y *= -uInputClamp.w;
            }
        }
    }

    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;
    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;
    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;
    finalColor.a = texture(uTexture, coord).a;
}
`,source$h=`struct GlitchUniforms {
  uSeed: f32,
  uDimensions: vec2<f32>,
  uAspect: f32,
  uFillMode: f32,
  uOffset: f32,
  uDirection: f32,
  uRed: vec2<f32>,
  uGreen: vec2<f32>,
  uBlue: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;
@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; 
@group(1) @binding(2) var uDisplacementSampler: sampler; 

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uSeed: f32 = glitchUniforms.uSeed;
  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;
  let uAspect: f32 = glitchUniforms.uAspect;
  let uOffset: f32 = glitchUniforms.uOffset;
  let uDirection: f32 = glitchUniforms.uDirection;
  let uRed: vec2<f32> = glitchUniforms.uRed;
  let uGreen: vec2<f32> = glitchUniforms.uGreen;
  let uBlue: vec2<f32> = glitchUniforms.uBlue;

  let uInputSize: vec4<f32> = gfu.uInputSize;
  let uInputClamp: vec4<f32> = gfu.uInputClamp;

  var discarded: bool = false;
  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;

    if (coord.x > 1.0 || coord.y > 1.0) {
      discarded = true;
    }

    let sinDir: f32 = sin(uDirection);
    let cosDir: f32 = cos(uDirection);

    let cx: f32 = coord.x - 0.5;
    let cy: f32 = (coord.y - 0.5) * uAspect;
    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;

    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);

    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));

    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);

    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);

    let fillMode: i32 = i32(glitchUniforms.uFillMode);

    if (fillMode == CLAMP) {
      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    } else {
      if (coord.x > uInputClamp.z) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.x = coord.x - uInputClamp.z;
        } else if (fillMode == MIRROR) {
          coord.x = uInputClamp.z * 2.0 - coord.x;
        }
      } else if (coord.x < uInputClamp.x) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.x = coord.x + uInputClamp.z;
        } else if (fillMode == MIRROR) {
          coord.x = coord.x * -uInputClamp.z;
        }
      }

      if (coord.y > uInputClamp.w) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.y = coord.y - uInputClamp.w;
        } else if (fillMode == MIRROR) {
          coord.y = uInputClamp.w * 2.0 - coord.y;
        }
      } else if (coord.y < uInputClamp.y) {
        if (fillMode == TRANSPARENT) {
          discarded = true;
        } else if (fillMode == LOOP) {
          coord.y = coord.y + uInputClamp.w;
        } else if (fillMode == MIRROR) {
          coord.y = coord.y * -uInputClamp.w;
        }
      }
    }

    let seedR: f32 = 1.0 - uSeed * 0.4;
    let seedG: f32 = 1.0 - uSeed * 0.3;
    let seedB: f32 = 1.0 - uSeed * 0.2;

    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);
    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);
    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);

    let r = textureSample(uTexture, uSampler, coord + offsetR).r;
    let g = textureSample(uTexture, uSampler, coord + offsetG).g;
    let b = textureSample(uTexture, uSampler, coord + offsetB).b;
    let a = textureSample(uTexture, uSampler, coord).a;

    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);
}

const TRANSPARENT: i32 = 0;
const ORIGINAL: i32 = 1;
const LOOP: i32 = 2;
const CLAMP: i32 = 3;
const MIRROR: i32 = 4;`,__defProp$f=Object.defineProperty,__defNormalProp$f=(O,C,A)=>C in O?__defProp$f(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$f=(O,C,A)=>(__defNormalProp$f(O,typeof C!="symbol"?C+"":C,A),A);const _GlitchFilter=class yn extends Filter{constructor(C){var K,te,ne,ie,oe;C={...yn.defaults,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$h,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$h,name:"glitch-filter"}),I=document.createElement("canvas");I.width=4,I.height=(K=C.sampleSize)!=null?K:512;const L=new Texture({source:new ImageSource({resource:I})});super({gpuProgram:A,glProgram:z,resources:{glitchUniforms:{uSeed:{value:(te=C==null?void 0:C.seed)!=null?te:0,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"},uAspect:{value:1,type:"f32"},uFillMode:{value:(ne=C==null?void 0:C.fillMode)!=null?ne:0,type:"f32"},uOffset:{value:(ie=C==null?void 0:C.offset)!=null?ie:100,type:"f32"},uDirection:{value:(oe=C==null?void 0:C.direction)!=null?oe:0,type:"f32"},uRed:{value:C.red,type:"vec2<f32>"},uGreen:{value:C.green,type:"vec2<f32>"},uBlue:{value:C.blue,type:"vec2<f32>"}},uDisplacementMap:L.source,uDisplacementSampler:L.source.style}}),__publicField$f(this,"uniforms"),__publicField$f(this,"average",!1),__publicField$f(this,"minSize",8),__publicField$f(this,"sampleSize",512),__publicField$f(this,"_canvas"),__publicField$f(this,"texture"),__publicField$f(this,"_slices",0),__publicField$f(this,"_sizes",new Float32Array(1)),__publicField$f(this,"_offsets",new Float32Array(1)),this.uniforms=this.resources.glitchUniforms.uniforms,this._canvas=I,this.texture=L,Object.assign(this,C)}apply(C,A,z,I){const{width:L,height:K}=A.frame;this.uniforms.uDimensions[0]=L,this.uniforms.uDimensions[1]=K,this.uniforms.uAspect=K/L,C.applyFilter(this,A,z,I)}_randomizeSizes(){const C=this._sizes,A=this._slices-1,z=this.sampleSize,I=Math.min(this.minSize/z,.9/this._slices);if(this.average){const L=this._slices;let K=1;for(let te=0;te<A;te++){const ne=K/(L-te),ie=Math.max(ne*(1-Math.random()*.6),I);C[te]=ie,K-=ie}C[A]=K}else{let L=1;const K=Math.sqrt(1/this._slices);for(let te=0;te<A;te++){const ne=Math.max(K*L*Math.random(),I);C[te]=ne,L-=ne}C[A]=L}this.shuffle()}shuffle(){const C=this._sizes,A=this._slices-1;for(let z=A;z>0;z--){const I=Math.random()*z>>0,L=C[z];C[z]=C[I],C[I]=L}}_randomizeOffsets(){for(let C=0;C<this._slices;C++)this._offsets[C]=Math.random()*(Math.random()<.5?-1:1)}refresh(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()}redraw(){const C=this.sampleSize,A=this.texture,z=this._canvas.getContext("2d");z.clearRect(0,0,8,C);let I,L=0;for(let K=0;K<this._slices;K++){I=Math.floor(this._offsets[K]*256);const te=this._sizes[K]*C,ne=I>0?I:0,ie=I<0?-I:0;z.fillStyle=`rgba(${ne}, ${ie}, 0, 1)`,z.fillRect(0,L>>0,C,te+1>>0),L+=te}A.source.update()}set sizes(C){const A=Math.min(this._slices,C.length);for(let z=0;z<A;z++)this._sizes[z]=C[z]}get sizes(){return this._sizes}set offsets(C){const A=Math.min(this._slices,C.length);for(let z=0;z<A;z++)this._offsets[z]=C[z]}get offsets(){return this._offsets}get slices(){return this._slices}set slices(C){this._slices!==C&&(this._slices=C,this._sizes=new Float32Array(C),this._offsets=new Float32Array(C),this.refresh())}get offset(){return this.uniforms.uOffset}set offset(C){this.uniforms.uOffset=C}get seed(){return this.uniforms.uSeed}set seed(C){this.uniforms.uSeed=C}get fillMode(){return this.uniforms.uFillMode}set fillMode(C){this.uniforms.uFillMode=C}get direction(){return this.uniforms.uDirection/DEG_TO_RAD}set direction(C){this.uniforms.uDirection=C*DEG_TO_RAD}get red(){return this.uniforms.uRed}set red(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uRed=C}get green(){return this.uniforms.uGreen}set green(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uGreen=C}get blue(){return this.uniforms.uBlue}set blue(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uBlue=C}destroy(){var C;(C=this.texture)==null||C.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null}};__publicField$f(_GlitchFilter,"defaults",{slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:{x:0,y:0},green:{x:0,y:0},blue:{x:0,y:0},minSize:8,sampleSize:512});var fragment$g=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uStrength;
uniform vec3 uColor;
uniform float uKnockout;
uniform float uAlpha;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const float PI = 3.14159265358979323846264;

// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions
const float DIST = __DIST__;
const float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);
const float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);
const float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;

void main(void) {
    vec2 px = vec2(1.) / uInputSize.xy;

    float totalAlpha = 0.;

    vec2 direction;
    vec2 displaced;
    vec4 curColor;

    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {
      direction = vec2(cos(angle), sin(angle)) * px;

      for (float curDistance = 0.; curDistance < DIST; curDistance++) {
          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);
          curColor = texture(uTexture, displaced);
          totalAlpha += (DIST - curDistance) * curColor.a;
      }
    }
    
    curColor = texture(uTexture, vTextureCoord);

    vec4 glowColor = vec4(uColor, uAlpha);
    bool knockout = uKnockout > .5;
    float innerStrength = uStrength[0];
    float outerStrength = uStrength[1];

    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;
    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;
    float innerGlowStrength = min(1., innerGlowAlpha);
    
    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);
    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;
    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);
    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;

    if (knockout) {
      float resultAlpha = outerGlowAlpha + innerGlowAlpha;
      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);
    }
    else {
      finalColor = innerColor + outerGlowColor;
    }
}
`,source$g=`struct GlowUniforms {
  uDistance: f32,
  uStrength: vec2<f32>,
  uColor: vec3<f32>,
  uAlpha: f32,
  uQuality: f32,
  uKnockout: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let quality = glowUniforms.uQuality;
  let distance = glowUniforms.uDistance;

  let dist: f32 = glowUniforms.uDistance;
  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);
  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);

  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);

  var totalAlpha: f32 = 0.0;

  var direction: vec2<f32>;
  var displaced: vec2<f32>;
  var curColor: vec4<f32>;

  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {
    direction = vec2<f32>(cos(angle), sin(angle)) * px;
    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {
      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));
      curColor = textureSample(uTexture, uSampler, displaced);
      totalAlpha += (dist - curDistance) * curColor.a;
    }
  }
    
  curColor = textureSample(uTexture, uSampler, uv);

  let glowColorRGB = glowUniforms.uColor;
  let glowAlpha = glowUniforms.uAlpha;
  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);
  let knockout: bool = glowUniforms.uKnockout > 0.5;
  let innerStrength = glowUniforms.uStrength[0];
  let outerStrength = glowUniforms.uStrength[1];

  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));
  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;
  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);
  
  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);
  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;
  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);
  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;
  
  if (knockout) {
    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;
    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);
  }
  else {
    return innerColor + outerGlowColor;
  }
}

const PI: f32 = 3.14159265358979323846264;`,__defProp$e=Object.defineProperty,__defNormalProp$e=(O,C,A)=>C in O?__defProp$e(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$e=(O,C,A)=>(__defNormalProp$e(O,typeof C!="symbol"?C+"":C,A),A);const _GlowFilter=class _n extends Filter{constructor(C){var K,te,ne,ie;C={..._n.DEFAULT_OPTIONS,...C};const A=(K=C.distance)!=null?K:10,z=(te=C.quality)!=null?te:.1,I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$g,entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$g.replace(/__ANGLE_STEP_SIZE__/gi,`${(1/z/A).toFixed(7)}`).replace(/__DIST__/gi,`${A.toFixed(0)}.0`),name:"glow-filter"});super({gpuProgram:I,glProgram:L,resources:{glowUniforms:{uDistance:{value:A,type:"f32"},uStrength:{value:[C.innerStrength,C.outerStrength],type:"vec2<f32>"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:C.alpha,type:"f32"},uQuality:{value:z,type:"f32"},uKnockout:{value:(ne=C==null?void 0:C.knockout)!=null&&ne?1:0,type:"f32"}}},padding:A}),__publicField$e(this,"uniforms"),__publicField$e(this,"_color"),this.uniforms=this.resources.glowUniforms.uniforms,this._color=new Color,this.color=(ie=C.color)!=null?ie:16777215}get distance(){return this.uniforms.uDistance}set distance(C){this.uniforms.uDistance=this.padding=C}get innerStrength(){return this.uniforms.uStrength[0]}set innerStrength(C){this.uniforms.uStrength[0]=C}get outerStrength(){return this.uniforms.uStrength[1]}set outerStrength(C){this.uniforms.uStrength[1]=C}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}get quality(){return this.uniforms.uQuality}set quality(C){this.uniforms.uQuality=C}get knockout(){return this.uniforms.uKnockout===1}set knockout(C){this.uniforms.uKnockout=C?1:0}};__publicField$e(_GlowFilter,"DEFAULT_OPTIONS",{distance:10,outerStrength:4,innerStrength:0,color:16777215,alpha:1,quality:.1,knockout:!1});let GlowFilter=_GlowFilter;var fragment$f=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uDimensions;
uniform float uParallel;
uniform vec2 uLight;
uniform float uAspect;
uniform float uTime;
uniform vec3 uRay;

uniform vec4 uInputSize;

\${PERLIN}

void main(void) {
    vec2 uDimensions = uDimensions;
    bool uParallel = uParallel > 0.5;
    vec2 uLight = uLight;
    float uAspect = uAspect;

    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;

    float d;

    if (uParallel) {
        float _cos = uLight.x;
        float _sin = uLight.y;
        d = (_cos * coord.x) + (_sin * coord.y * uAspect);
    } else {
        float dx = coord.x - uLight.x / uDimensions.x;
        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;
        float dis = sqrt(dx * dx + dy * dy) + 0.00001;
        d = dy / dis;
    }

    float uTime = uTime;
    vec3 uRay = uRay;

    float gain = uRay[0];
    float lacunarity = uRay[1];
    float alpha = uRay[2];

    vec3 dir = vec3(d, d, 0.0);
    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);
    noise = mix(noise, 0.0, 0.3);
    //fade vertically.
    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);
    mist.a = 1.0;
    // apply user alpha
    mist *= alpha;

    finalColor = texture(uTexture, vTextureCoord) + mist;
}
`,source$f=`struct GodrayUniforms {
  uLight: vec2<f32>,
  uParallel: f32,
  uAspect: f32,
  uTime: f32,
  uRay: vec3<f32>,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;
  let uParallel: bool = godrayUniforms.uParallel > 0.5;
  let uLight: vec2<f32> = godrayUniforms.uLight;
  let uAspect: f32 = godrayUniforms.uAspect;

  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;

  var d: f32;

  if (uParallel) {
    let _cos: f32 = uLight.x;
    let _sin: f32 = uLight.y;
    d = (_cos * coord.x) + (_sin * coord.y * uAspect);
  } else {
    let dx: f32 = coord.x - uLight.x / uDimensions.x;
    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;
    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;
    d = dy / dis;
  }

  let uTime: f32 = godrayUniforms.uTime;
  let uRay: vec3<f32> = godrayUniforms.uRay;
  
  let gain = uRay[0];
  let lacunarity = uRay[1];
  let alpha = uRay[2];

  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);
  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);
  noise = mix(noise, 0.0, 0.3);
  //fade vertically.
  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);
  mist.a = 1.0;
  // apply user alpha
  mist *= alpha;
  return textureSample(uTexture, uSampler, uv) + mist;
}

\${PERLIN}`,perlin=`vec3 mod289(vec3 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec4 mod289(vec4 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec4 permute(vec4 x)
{
    return mod289(((x * 34.0) + 1.0) * x);
}
vec4 taylorInvSqrt(vec4 r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}
vec3 fade(vec3 t)
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
// Classic Perlin noise, periodic variant
float pnoise(vec3 P, vec3 rep)
{
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = Pi0.zzzz;
    vec4 iz1 = Pi1.zzzz;
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
    return 2.2 * n_xyz;
}
float turb(vec3 P, vec3 rep, float lacunarity, float gain)
{
    float sum = 0.0;
    float sc = 1.0;
    float totalgain = 1.0;
    for (float i = 0.0; i < 6.0; i++)
    {
        sum += totalgain * pnoise(P * sc, rep);
        sc *= lacunarity;
        totalgain *= gain;
    }
    return abs(sum);
}
`,sourcePerlin=`// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39

fn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>
{
  return x - y * floor(x/y);
}
fn mod289Vec3(x: vec3<f32>) -> vec3<f32>
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
fn mod289Vec4(x: vec4<f32>) -> vec4<f32>
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
fn permute4(x: vec4<f32>) -> vec4<f32>
{
    return mod289Vec4(((x * 34.0) + 1.0) * x);
}
fn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>
{
    return 1.79284291400159 - 0.85373472095314 * r;
}
fn fade3(t: vec3<f32>) -> vec3<f32>
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
fn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise2(P: vec2<f32>) -> f32 {
  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);
  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);
  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation
  let ix = Pi.xzxz;
  let iy = Pi.yyww;
  let fx = Pf.xzxz;
  let fy = Pf.yyww;
  let i = permute4(permute4(ix) + iy);
  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...
  let gy = abs(gx) - 0.5;
  let tx = floor(gx + 0.5);
  gx = gx - tx;
  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);
  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);
  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);
  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);
  let norm = 1.79284291400159 - 0.85373472095314 *
      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 = g00 * norm.x;
  g01 = g01 * norm.y;
  g10 = g10 * norm.z;
  g11 = g11 * norm.w;
  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));
  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));
  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));
  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));
  let fade_xy = fade2(Pf.xy);
  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));
  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

// Classic Perlin noise, periodic variant
fn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32
{
    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period
    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289Vec3(Pi0);
    Pi1 = mod289Vec3(Pi1);
    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation
    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0
    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);
    let iz0: vec4<f32> = Pi0.zzzz;
    let iz1: vec4<f32> = Pi1.zzzz;
    let ixy: vec4<f32> = permute4(permute4(ix) + iy);
    let ixy0: vec4<f32> = permute4(ixy + iz0);
    let ixy1: vec4<f32> = permute4(ixy + iz1);
    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);
    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);
    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));
    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);
    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);
    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);
    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);
    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));
    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);
    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);
    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);
    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);
    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);
    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);
    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);
    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);
    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);
    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);
    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    let n000: f32 = dot(g000, Pf0);
    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));
    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));
    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));
    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));
    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));
    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));
    let n111: f32 = dot(g111, Pf1);
    let fade_xyz: vec3<f32> = fade3(Pf0);
    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);
    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);
    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);
    return 2.2 * n_xyz;
}
fn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32
{
    var sum: f32 = 0.0;
    var sc: f32 = 1.0;
    var totalgain: f32 = 1.0;
    for (var i = 0.0; i < 6.0; i += 1)
    {
        sum += totalgain * perlinNoise3(P * sc, rep);
        sc *= lacunarity;
        totalgain *= gain;
    }
    return abs(sum);
}`,__defProp$d=Object.defineProperty,__defNormalProp$d=(O,C,A)=>C in O?__defProp$d(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$d=(O,C,A)=>(__defNormalProp$d(O,typeof C!="symbol"?C+"":C,A),A);const _GodrayFilter=class bn extends Filter{constructor(C){C={...bn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$f.replace("${PERLIN}",sourcePerlin),entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$f.replace("${PERLIN}",perlin),name:"god-ray-filter"});super({gpuProgram:A,glProgram:z,resources:{godrayUniforms:{uLight:{value:new Float32Array(2),type:"vec2<f32>"},uParallel:{value:0,type:"f32"},uAspect:{value:0,type:"f32"},uTime:{value:C.time,type:"f32"},uRay:{value:new Float32Array(3),type:"vec3<f32>"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField$d(this,"uniforms"),__publicField$d(this,"time",0),__publicField$d(this,"_angleLight",[0,0]),__publicField$d(this,"_angle",0),__publicField$d(this,"_center"),this.uniforms=this.resources.godrayUniforms.uniforms,Object.assign(this,C)}apply(C,A,z,I){const L=A.frame.width,K=A.frame.height;this.uniforms.uLight[0]=this.parallel?this._angleLight[0]:this._center.x,this.uniforms.uLight[1]=this.parallel?this._angleLight[1]:this._center.y,this.uniforms.uDimensions[0]=L,this.uniforms.uDimensions[1]=K,this.uniforms.uAspect=K/L,this.uniforms.uTime=this.time,C.applyFilter(this,A,z,I)}get angle(){return this._angle}set angle(C){this._angle=C;const A=C*DEG_TO_RAD;this._angleLight[0]=Math.cos(A),this._angleLight[1]=Math.sin(A)}get parallel(){return this.uniforms.uParallel>.5}set parallel(C){this.uniforms.uParallel=C?1:0}get center(){return this._center}set center(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this._center=C}get centerX(){return this.center.x}set centerX(C){this.center.x=C}get centerY(){return this.center.y}set centerY(C){this.center.y=C}get gain(){return this.uniforms.uRay[0]}set gain(C){this.uniforms.uRay[0]=C}get lacunarity(){return this.uniforms.uRay[1]}set lacunarity(C){this.uniforms.uRay[1]=C}get alpha(){return this.uniforms.uRay[2]}set alpha(C){this.uniforms.uRay[2]=C}};__publicField$d(_GodrayFilter,"DEFAULT_OPTIONS",{angle:30,gain:.5,lacunarity:2.5,parallel:!0,time:0,center:{x:0,y:0},alpha:1});var fragment$e=`in vec2 vTextureCoord;

out vec4 finalColor;

uniform sampler2D uTexture;

// https://en.wikipedia.org/wiki/Luma_(video)
const vec3 weight = vec3(0.299, 0.587, 0.114);

void main()
{
    vec4 c = texture(uTexture, vTextureCoord);
    finalColor = vec4(
        vec3(c.r * weight.r + c.g * weight.g  + c.b * weight.b),
        c.a
    );
}
`,source$e=`@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  let g: f32 = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));
  return vec4<f32>(vec3<f32>(g), 1.);
}`;class GrayscaleFilter extends Filter{constructor(){const C=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$e,entryPoint:"mainFragment"}}),A=GlProgram.from({vertex:vertex$1,fragment:fragment$e,name:"grayscale-filter"});super({gpuProgram:C,glProgram:A,resources:{}})}}var fragment$d=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec3 uHsl;
uniform float uAlpha;
uniform float uColorize;

// https://en.wikipedia.org/wiki/Luma_(video)
const vec3 weight = vec3(0.299, 0.587, 0.114);

float getWeightedAverage(vec3 rgb) {
    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;
}

// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243
const vec3 k = vec3(0.57735, 0.57735, 0.57735);

vec3 hueShift(vec3 color, float angle) {
    float cosAngle = cos(angle);
    return vec3(
    color * cosAngle +
    cross(k, color) * sin(angle) +
    k * dot(k, color) * (1.0 - cosAngle)
    );
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    vec3 resultRGB = color.rgb;

    float hue = uHsl[0];
    float saturation = uHsl[1];
    float lightness = uHsl[2];

    // colorize
    if (uColorize > 0.5) {
        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);
    }

    // hue
    resultRGB = hueShift(resultRGB, hue);

    // saturation
    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js
    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;

    if (saturation > 0.) {
        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));
    } else {
        resultRGB -= (average - resultRGB) * saturation;
    }

    // lightness
    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));

    // alpha
    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);
}
`,source$d=`struct HslUniforms {
  uHsl:vec3<f32>,
  uColorize:f32,
  uAlpha:f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);
    var resultRGB: vec3<f32> = color.rgb;

    let hue: f32 = hslUniforms.uHsl[0];
    let saturation: f32 = hslUniforms.uHsl[1];
    let lightness: f32 = hslUniforms.uHsl[2];

    // colorize
    if (hslUniforms.uColorize > 0.5) {
        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);
    }

    // hue
    resultRGB = hueShift(resultRGB, hue);

    // saturation
    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js
    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;

    if (saturation > 0.) {
        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));
    } else {
        resultRGB -= (average - resultRGB) * saturation;
    }

    // lightness
    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));

    // alpha
    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);
}

// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243
const k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);

fn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> 
{
    let cosAngle: f32 = cos(angle);
    return vec3<f32>(
    color * cosAngle +
    cross(k, color) * sin(angle) +
    k * dot(k, color) * (1.0 - cosAngle)
    );
}`,__defProp$c=Object.defineProperty,__defNormalProp$c=(O,C,A)=>C in O?__defProp$c(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$c=(O,C,A)=>(__defNormalProp$c(O,typeof C!="symbol"?C+"":C,A),A);const _HslAdjustmentFilter=class Sn extends Filter{constructor(C){C={...Sn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$d,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$d,name:"hsl-adjustment-filter"});super({gpuProgram:A,glProgram:z,resources:{hslUniforms:{uHsl:{value:new Float32Array(3),type:"vec3<f32>"},uColorize:{value:C.colorize?1:0,type:"f32"},uAlpha:{value:C.alpha,type:"f32"}}}}),__publicField$c(this,"uniforms"),__publicField$c(this,"_hue"),this.uniforms=this.resources.hslUniforms.uniforms,Object.assign(this,C)}get hue(){return this._hue}set hue(C){this._hue=C,this.uniforms.uHsl[0]=C*(Math.PI/180)}get saturation(){return this.uniforms.uHsl[1]}set saturation(C){this.uniforms.uHsl[1]=C}get lightness(){return this.uniforms.uHsl[2]}set lightness(C){this.uniforms.uHsl[2]=C}get colorize(){return this.uniforms.uColorize===1}set colorize(C){this.uniforms.uColorize=C?1:0}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}};__publicField$c(_HslAdjustmentFilter,"DEFAULT_OPTIONS",{hue:0,saturation:0,lightness:0,colorize:!1,alpha:1});var fragment$c=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uVelocity;
uniform int uKernelSize;
uniform float uOffset;

uniform vec4 uInputSize;

const int MAX_KERNEL_SIZE = 2048;

// Notice:
// the perfect way:
//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);
// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.
// So use uKernelSize directly.

void main(void)
{
    vec4 color = texture(uTexture, vTextureCoord);

    if (uKernelSize == 0)
    {
        finalColor = color;
        return;
    }

    vec2 velocity = uVelocity / uInputSize.xy;
    float offset = -uOffset / length(uVelocity) - 0.5;
    int k = uKernelSize - 1;

    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {
        if (i == k) {
            break;
        }
        vec2 bias = velocity * (float(i) / float(k) + offset);
        color += texture(uTexture, vTextureCoord + bias);
    }
    finalColor = color / float(uKernelSize);
}
`,source$c=`struct MotionBlurUniforms {
  uVelocity: vec2<f32>,
  uKernelSize: f32,
  uOffset: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uVelocity = motionBlurUniforms.uVelocity;
  let uKernelSize = motionBlurUniforms.uKernelSize;
  let uOffset = motionBlurUniforms.uOffset;

  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;
  let offset: f32 = -uOffset / length(uVelocity) - 0.5;
  let k: i32 = i32(min(uKernelSize - 1, MAX_KERNEL_SIZE - 1));

  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  for(var i: i32 = 0; i < k; i += 1) {
    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);
    color += textureSample(uTexture, uSampler, uv + bias);
  }
  
  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);
}

const MAX_KERNEL_SIZE: f32 = 2048;`,__defProp$b=Object.defineProperty,__defNormalProp$b=(O,C,A)=>C in O?__defProp$b(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$b=(O,C,A)=>(__defNormalProp$b(O,typeof C!="symbol"?C+"":C,A),A);const _MotionBlurFilter=class Tn extends Filter{constructor(...C){var L,K;let A=(L=C[0])!=null?L:{};if(Array.isArray(A)||"x"in A&&"y"in A||A instanceof ObservablePoint){deprecation("6.0.0","MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }");const te="x"in A?A.x:A[0],ne="y"in A?A.y:A[1];A={velocity:{x:te,y:ne}},C[1]!==void 0&&(A.kernelSize=C[1]),C[2]!==void 0&&(A.offset=C[2])}A={...Tn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$c,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$c,name:"motion-blur-filter"});super({gpuProgram:z,glProgram:I,resources:{motionBlurUniforms:{uVelocity:{value:A.velocity,type:"vec2<f32>"},uKernelSize:{value:Math.trunc((K=A.kernelSize)!=null?K:5),type:"i32"},uOffset:{value:A.offset,type:"f32"}}}}),__publicField$b(this,"uniforms"),__publicField$b(this,"_kernelSize"),this.uniforms=this.resources.motionBlurUniforms.uniforms,Object.assign(this,A)}get velocity(){return this.uniforms.uVelocity}set velocity(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uVelocity=C,this._updateDirty()}get velocityX(){return this.velocity.x}set velocityX(C){this.velocity.x=C,this._updateDirty()}get velocityY(){return this.velocity.y}set velocityY(C){this.velocity.y=C,this._updateDirty()}get kernelSize(){return this._kernelSize}set kernelSize(C){this._kernelSize=C,this._updateDirty()}get offset(){return this.uniforms.uOffset}set offset(C){this.uniforms.uOffset=C}_updateDirty(){this.padding=(Math.max(Math.abs(this.velocityX),Math.abs(this.velocityY))>>0)+1,this.uniforms.uKernelSize=this.velocityX!==0||this.velocityY!==0?this._kernelSize:0}};__publicField$b(_MotionBlurFilter,"DEFAULT_OPTIONS",{velocity:{x:0,y:0},kernelSize:5,offset:0});var fragment$b=`in vec2 vTextureCoord;
out vec4 finalColor;

const int MAX_COLORS = \${MAX_COLORS};

uniform sampler2D uTexture;
uniform vec3 uOriginalColors[MAX_COLORS];
uniform vec3 uTargetColors[MAX_COLORS];
uniform float uTolerance;

void main(void)
{
    finalColor = texture(uTexture, vTextureCoord);

    float alpha = finalColor.a;
    if (alpha < 0.0001)
    {
      return;
    }

    vec3 color = finalColor.rgb / alpha;

    for(int i = 0; i < MAX_COLORS; i++)
    {
      vec3 origColor = uOriginalColors[i];
      if (origColor.r < 0.0)
      {
        break;
      }
      vec3 colorDiff = origColor - color;
      if (length(colorDiff) < uTolerance)
      {
        vec3 targetColor = uTargetColors[i];
        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);
        return;
      }
    }
}
`,source$b=`struct MultiColorReplaceUniforms {
  uOriginalColors: array<vec3<f32>, MAX_COLORS>,
  uTargetColors: array<vec3<f32>, MAX_COLORS>,
  uTolerance:f32,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;
  let uTargetColors = multiColorReplaceUniforms.uTargetColors;
  let uTolerance = multiColorReplaceUniforms.uTolerance;

  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  let alpha: f32 = color.a;

  if (alpha > 0.0001)
  {
    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;

    for(var i: i32 = 0; i < MAX_COLORS; i += 1)
    {
      let origColor: vec3<f32> = uOriginalColors[i];
      if (origColor.r < 0.0)
      {
        break;
      }
      let colorDiff: vec3<f32> = origColor - modColor;
      
      if (length(colorDiff) < uTolerance)
      {
        let targetColor: vec3<f32> = uTargetColors[i];
        color = vec4((targetColor + colorDiff) * alpha, alpha);
        return color;
      }
    }
  }

  return color;
}

const MAX_COLORS: i32 = \${MAX_COLORS};`,__defProp$a=Object.defineProperty,__defNormalProp$a=(O,C,A)=>C in O?__defProp$a(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$a=(O,C,A)=>(__defNormalProp$a(O,typeof C!="symbol"?C+"":C,A),A);const _MultiColorReplaceFilter=class wn extends Filter{constructor(...C){var K,te;let A=(K=C[0])!=null?K:{};Array.isArray(A)&&(deprecation("6.0.0","MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }"),A={replacements:A},C[1]&&(A.tolerance=C[1]),C[2]&&(A.maxColors=C[2])),A={...wn.DEFAULT_OPTIONS,...A};const z=(te=A.maxColors)!=null?te:A.replacements.length,I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$b.replace(/\$\{MAX_COLORS\}/g,z.toFixed(0)),entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$b.replace(/\$\{MAX_COLORS\}/g,z.toFixed(0)),name:"multi-color-replace-filter"});super({gpuProgram:I,glProgram:L,resources:{multiColorReplaceUniforms:{uOriginalColors:{value:new Float32Array(3*z),type:"vec3<f32>",size:z},uTargetColors:{value:new Float32Array(3*z),type:"vec3<f32>",size:z},uTolerance:{value:A.tolerance,type:"f32"}}}}),__publicField$a(this,"uniforms"),__publicField$a(this,"_replacements",[]),__publicField$a(this,"_maxColors"),this._maxColors=z,this.uniforms=this.resources.multiColorReplaceUniforms.uniforms,this.replacements=A.replacements}set replacements(C){const A=this.uniforms.uOriginalColors,z=this.uniforms.uTargetColors,I=C.length,L=new Color;if(I>this._maxColors)throw new Error(`Length of replacements (${I}) exceeds the maximum colors length (${this._maxColors})`);A[I*3]=-1;let K,te,ne;for(let ie=0;ie<I;ie++){const oe=C[ie];L.setValue(oe[0]),[K,te,ne]=L.toArray(),A[ie*3]=K,A[ie*3+1]=te,A[ie*3+2]=ne,L.setValue(oe[1]),[K,te,ne]=L.toArray(),z[ie*3]=K,z[ie*3+1]=te,z[ie*3+2]=ne}this._replacements=C}get replacements(){return this._replacements}refresh(){this.replacements=this._replacements}get maxColors(){return this._maxColors}get tolerance(){return this.uniforms.uTolerance}set tolerance(C){this.uniforms.uTolerance=C}set epsilon(C){deprecation("6.0.0","MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"),this.tolerance=C}get epsilon(){return deprecation("6.0.0","MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"),this.tolerance}};__publicField$a(_MultiColorReplaceFilter,"DEFAULT_OPTIONS",{replacements:[[16711680,255]],tolerance:.05,maxColors:void 0});var fragment$a=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uSepia;
uniform vec2 uNoise;
uniform vec3 uScratch;
uniform vec3 uVignetting;
uniform float uSeed;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

const float SQRT_2 = 1.414213;
const vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 Overlay(vec3 src, vec3 dst)
{
    // if (dst <= 0.5) then: 2 * src * dst
    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)
    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),
                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),
                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));
}


void main()
{
    finalColor = texture(uTexture, vTextureCoord);
    vec3 color = finalColor.rgb;

    if (uSepia > 0.0)
    {
        float gray = (color.x + color.y + color.z) / 3.0;
        vec3 grayscale = vec3(gray);

        color = Overlay(SEPIA_RGB, grayscale);

        color = grayscale + uSepia * (color - grayscale);
    }

    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;

    float vignette = uVignetting[0];
    float vignetteAlpha = uVignetting[1];
    float vignetteBlur = uVignetting[2];

    if (vignette > 0.0)
    {
        float outter = SQRT_2 - vignette * SQRT_2;
        vec2 dir = vec2(vec2(0.5, 0.5) - coord);
        dir.y *= uDimensions.y / uDimensions.x;
        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);
        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);
    }

    float scratch = uScratch[0];
    float scratchDensity = uScratch[1];
    float scratchWidth = uScratch[2];

    if (scratchDensity > uSeed && scratch != 0.0)
    {
        float phase = uSeed * 256.0;
        float s = mod(floor(phase), 2.0);
        float dist = 1.0 / scratchDensity;
        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));
        if (d < uSeed * 0.6 + 0.4)
        {
            highp float period = scratchDensity * 10.0;

            float xx = coord.x * period + phase;
            float aa = abs(mod(xx, 0.5) * 4.0);
            float bb = mod(floor(xx / 0.5), 2.0);
            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);

            float kk = 2.0 * period;
            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);
            float dh = dw * kk;

            float tine = (yy - (2.0 - dh));

            if (tine > 0.0) {
                float _sign = sign(scratch);

                tine = s * tine / period + scratch + 0.1;
                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);

                color.rgb *= tine;
            }
        }
    }

    float noise = uNoise[0];
    float noiseSize = uNoise[1];

    if (noise > 0.0 && noiseSize > 0.0)
    {
        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;
        pixelCoord.x = floor(pixelCoord.x / noiseSize);
        pixelCoord.y = floor(pixelCoord.y / noiseSize);
        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);
        // float _noise = snoise(d) * 0.5;
        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;
        color += _noise * noise;
    }

    finalColor.rgb = color;
}`,source$a=`struct OldFilmUniforms {
    uSepia: f32,
    uNoise: vec2<f32>,
    uScratch: vec3<f32>,
    uVignetting: vec3<f32>,
    uSeed: f32,
    uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  if (oldFilmUniforms.uSepia > 0.)
  {
    color = vec4<f32>(sepia(color.rgb), color.a);
  }

  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;

  if (oldFilmUniforms.uVignetting[0] > 0.)
  {
    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);
  }

  let uScratch = oldFilmUniforms.uScratch; 

  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)
  {
    color = vec4<f32>(scratch(color.rgb, coord), color.a);
  }

  let uNoise = oldFilmUniforms.uNoise;

  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)
  {
    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);
  }

  return color;
}

const SQRT_2: f32 = 1.414213;
const SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

fn rand(co: vec2<f32>) -> f32
{
  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>
{
    // if (dst <= 0.5) then: 2 * src * dst
    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)

    return vec3<f32>(
      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), 
      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),
      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))
    );
}

fn sepia(co: vec3<f32>) -> vec3<f32>
{
  let gray: f32 = (co.x + co.y + co.z) / 3.0;
  let grayscale: vec3<f32> = vec3<f32>(gray);
  let color = overlay(SEPIA_RGB, grayscale);
  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);
}

fn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32
{
  let uVignetting = oldFilmUniforms.uVignetting;
  let uDimensions = oldFilmUniforms.uDimensions;
  
  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;
  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);
  dir.y *= uDimensions.y / uDimensions.x;
  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);
  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);
}

fn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>
{
  var color = co;
  let uScratch = oldFilmUniforms.uScratch;
  let uSeed = oldFilmUniforms.uSeed;
  let uDimensions = oldFilmUniforms.uDimensions;

  let phase: f32 = uSeed * 256.0;
  let s: f32 = modulo(floor(phase), 2.0);
  let dist: f32 = 1.0 / uScratch[1];
  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));

  if (d < uSeed * 0.6 + 0.4)
  {
    let period: f32 = uScratch[1] * 10.0;

    let xx: f32 = coord.x * period + phase;
    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);
    let bb: f32 = modulo(floor(xx / 0.5), 2.0);
    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);

    let kk: f32 = 2.0 * period;
    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);
    let dh: f32 = dw * kk;

    var tine: f32 = (yy - (2.0 - dh));

    if (tine > 0.0) {
        let _sign: f32 = sign(uScratch[0]);

        tine = s * tine / period + uScratch[0] + 0.1;
        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);

        color *= tine;
    }
  }

  return color;
}

fn noise(coord: vec2<f32>) -> f32
{
  let uNoise = oldFilmUniforms.uNoise;
  let uSeed = oldFilmUniforms.uSeed;

  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;
  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);
  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);
  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];
}`,__defProp$9=Object.defineProperty,__defNormalProp$9=(O,C,A)=>C in O?__defProp$9(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$9=(O,C,A)=>(__defNormalProp$9(O,typeof C!="symbol"?C+"":C,A),A);const _OldFilmFilter=class Cn extends Filter{constructor(C){C={...Cn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$a,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$a,name:"old-film-filter"});super({gpuProgram:A,glProgram:z,resources:{oldFilmUniforms:{uSepia:{value:C.sepia,type:"f32"},uNoise:{value:new Float32Array(2),type:"vec2<f32>"},uScratch:{value:new Float32Array(3),type:"vec3<f32>"},uVignetting:{value:new Float32Array(3),type:"vec3<f32>"},uSeed:{value:C.seed,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField$9(this,"uniforms"),__publicField$9(this,"seed"),this.uniforms=this.resources.oldFilmUniforms.uniforms,Object.assign(this,C)}apply(C,A,z,I){this.uniforms.uDimensions[0]=A.frame.width,this.uniforms.uDimensions[1]=A.frame.height,this.uniforms.uSeed=this.seed,C.applyFilter(this,A,z,I)}get sepia(){return this.uniforms.uSepia}set sepia(C){this.uniforms.uSepia=C}get noise(){return this.uniforms.uNoise[0]}set noise(C){this.uniforms.uNoise[0]=C}get noiseSize(){return this.uniforms.uNoise[1]}set noiseSize(C){this.uniforms.uNoise[1]=C}get scratch(){return this.uniforms.uScratch[0]}set scratch(C){this.uniforms.uScratch[0]=C}get scratchDensity(){return this.uniforms.uScratch[1]}set scratchDensity(C){this.uniforms.uScratch[1]=C}get scratchWidth(){return this.uniforms.uScratch[2]}set scratchWidth(C){this.uniforms.uScratch[2]=C}get vignetting(){return this.uniforms.uVignetting[0]}set vignetting(C){this.uniforms.uVignetting[0]=C}get vignettingAlpha(){return this.uniforms.uVignetting[1]}set vignettingAlpha(C){this.uniforms.uVignetting[1]=C}get vignettingBlur(){return this.uniforms.uVignetting[2]}set vignettingBlur(C){this.uniforms.uVignetting[2]=C}};__publicField$9(_OldFilmFilter,"DEFAULT_OPTIONS",{sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,seed:0});var fragment$9=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uThickness;
uniform vec3 uColor;
uniform float uAlpha;
uniform float uKnockout;

uniform vec4 uInputClamp;

const float DOUBLE_PI = 2. * 3.14159265358979323846264;
const float ANGLE_STEP = \${ANGLE_STEP};

float outlineMaxAlphaAtPos(vec2 pos) {
    if (uThickness.x == 0. || uThickness.y == 0.) {
        return 0.;
    }

    vec4 displacedColor;
    vec2 displacedPos;
    float maxAlpha = 0.;

    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {
        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);
        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);
        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));
        maxAlpha = max(maxAlpha, displacedColor.a);
    }

    return maxAlpha;
}

void main(void) {
    vec4 sourceColor = texture(uTexture, vTextureCoord);
    vec4 contentColor = sourceColor * float(uKnockout < 0.5);
    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);
    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);
    finalColor = contentColor + outlineColor;
}
`,source$9=`struct OutlineUniforms {
  uThickness:vec2<f32>,
  uColor:vec3<f32>,
  uAlpha:f32,
  uAngleStep:f32,
  uKnockout:f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);
  
  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);
  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);
  
  return contentColor + outlineColor;
}

fn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {
  let thickness = outlineUniforms.uThickness;

  if (thickness.x == 0. || thickness.y == 0.) {
    return 0.;
  }
  
  let angleStep = outlineUniforms.uAngleStep;

  var displacedColor: vec4<f32>;
  var displacedPos: vec2<f32>;

  var maxAlpha: f32 = 0.;
  var displaced: vec2<f32>;
  var curColor: vec4<f32>;

  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)
  {
    displaced.x = uv.x + thickness.x * cos(angle);
    displaced.y = uv.y + thickness.y * sin(angle);
    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));
    maxAlpha = max(maxAlpha, curColor.a);
  }

  return maxAlpha;
}

const DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;`,__defProp$8=Object.defineProperty,__defNormalProp$8=(O,C,A)=>C in O?__defProp$8(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$8=(O,C,A)=>(__defNormalProp$8(O,typeof C!="symbol"?C+"":C,A),A);const _OutlineFilter=class _r extends Filter{constructor(...C){var K,te,ne;let A=(K=C[0])!=null?K:{};typeof A=="number"&&(deprecation("6.0.0","OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }"),A={thickness:A},C[1]!==void 0&&(A.color=C[1]),C[2]!==void 0&&(A.quality=C[2]),C[3]!==void 0&&(A.alpha=C[3]),C[4]!==void 0&&(A.knockout=C[4])),A={..._r.DEFAULT_OPTIONS,...A};const z=(te=A.quality)!=null?te:.1,I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$9,entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$9.replace(/\$\{ANGLE_STEP\}/,_r.getAngleStep(z).toFixed(7)),name:"outline-filter"});super({gpuProgram:I,glProgram:L,resources:{outlineUniforms:{uThickness:{value:new Float32Array(2),type:"vec2<f32>"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:A.alpha,type:"f32"},uAngleStep:{value:0,type:"f32"},uKnockout:{value:A.knockout?1:0,type:"f32"}}}}),__publicField$8(this,"uniforms"),__publicField$8(this,"_thickness"),__publicField$8(this,"_quality"),__publicField$8(this,"_color"),this.uniforms=this.resources.outlineUniforms.uniforms,this.uniforms.uAngleStep=_r.getAngleStep(z),this._color=new Color,this.color=(ne=A.color)!=null?ne:0,Object.assign(this,A)}apply(C,A,z,I){this.uniforms.uThickness[0]=this.thickness/A.source.width,this.uniforms.uThickness[1]=this.thickness/A.source.height,C.applyFilter(this,A,z,I)}static getAngleStep(C){return parseFloat((Math.PI*2/Math.max(C*_r.MAX_SAMPLES,_r.MIN_SAMPLES)).toFixed(7))}get thickness(){return this._thickness}set thickness(C){this._thickness=this.padding=C}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}get quality(){return this._quality}set quality(C){this._quality=C,this.uniforms.uAngleStep=_r.getAngleStep(C)}get knockout(){return this.uniforms.uKnockout===1}set knockout(C){this.uniforms.uKnockout=C?1:0}};__publicField$8(_OutlineFilter,"DEFAULT_OPTIONS",{thickness:1,color:0,alpha:1,quality:.1,knockout:!1}),__publicField$8(_OutlineFilter,"MIN_SAMPLES",1),__publicField$8(_OutlineFilter,"MAX_SAMPLES",100);var fragment$8=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform vec2 uSize;
uniform sampler2D uTexture;
uniform vec4 uInputSize;

vec2 mapCoord( vec2 coord )
{
    coord *= uInputSize.xy;
    coord += uInputSize.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= uInputSize.zw;
    coord /= uInputSize.xy;

    return coord;
}

vec2 pixelate(vec2 coord, vec2 uSize)
{
	return floor( coord / uSize ) * uSize;
}

void main(void)
{
    vec2 coord = mapCoord(vTextureCoord);
    coord = pixelate(coord, uSize);
    coord = unmapCoord(coord);
    finalColor = texture(uTexture, coord);
}
`,source$8=`struct PixelateUniforms {
  uSize:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  let pixelSize: vec2<f32> = pixelateUniforms.uSize;
  let coord: vec2<f32> = mapCoord(uv);

  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);
  pixCoord = unmapCoord(pixCoord);

  return textureSample(uTexture, uSampler, pixCoord);
}

fn mapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord *= gfu.uInputSize.xy;
  mappedCoord += gfu.uOutputFrame.xy;
  return mappedCoord;
}

fn unmapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord -= gfu.uOutputFrame.xy;
  mappedCoord /= gfu.uInputSize.xy;
  return mappedCoord;
}

fn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>
{
  return floor( coord / size ) * size;
}

`;class PixelateFilter extends Filter{constructor(C=10){const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$8,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$8,name:"pixelate-filter"});super({gpuProgram:A,glProgram:z,resources:{pixelateUniforms:{uSize:{value:new Float32Array(2),type:"vec2<f32>"}}}}),this.size=C}get size(){return this.resources.pixelateUniforms.uniforms.uSize}set size(C){C instanceof Point?(this.sizeX=C.x,this.sizeY=C.y):Array.isArray(C)?this.resources.pixelateUniforms.uniforms.uSize=C:this.sizeX=this.sizeY=C}get sizeX(){return this.resources.pixelateUniforms.uniforms.uSize[0]}set sizeX(C){this.resources.pixelateUniforms.uniforms.uSize[0]=C}get sizeY(){return this.resources.pixelateUniforms.uniforms.uSize[1]}set sizeY(C){this.resources.pixelateUniforms.uniforms.uSize[1]=C}}var fragment$7=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uRadian;
uniform vec2 uCenter;
uniform float uRadius;
uniform int uKernelSize;

uniform vec4 uInputSize;

const int MAX_KERNEL_SIZE = 2048;

void main(void)
{
    vec4 color = texture(uTexture, vTextureCoord);

    if (uKernelSize == 0)
    {
        finalColor = color;
        return;
    }

    float aspect = uInputSize.y / uInputSize.x;
    vec2 center = uCenter.xy / uInputSize.xy;
    float gradient = uRadius / uInputSize.x * 0.3;
    float radius = uRadius / uInputSize.x - gradient * 0.5;
    int k = uKernelSize - 1;

    vec2 coord = vTextureCoord;
    vec2 dir = vec2(center - coord);
    float dist = length(vec2(dir.x, dir.y * aspect));

    float radianStep = uRadian;
    if (radius >= 0.0 && dist > radius) {
        float delta = dist - radius;
        float gap = gradient;
        float scale = 1.0 - abs(delta / gap);
        if (scale <= 0.0) {
            finalColor = color;
            return;
        }
        radianStep *= scale;
    }
    radianStep /= float(k);

    float s = sin(radianStep);
    float c = cos(radianStep);
    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));

    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {
        if (i == k) {
            break;
        }

        coord -= center;
        coord.y *= aspect;
        coord = rotationMatrix * coord;
        coord.y /= aspect;
        coord += center;

        vec4 sample = texture(uTexture, coord);

        // switch to pre-multiplied alpha to correctly blur transparent images
        // sample.rgb *= sample.a;

        color += sample;
    }

    finalColor = color / float(uKernelSize);
}
`,source$7=`struct RadialBlurUniforms {
  uRadian: f32,
  uCenter: vec2<f32>,
  uKernelSize: f32,
  uRadius: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uRadian = radialBlurUniforms.uRadian;
  let uCenter = radialBlurUniforms.uCenter;
  let uKernelSize = radialBlurUniforms.uKernelSize;
  let uRadius = radialBlurUniforms.uRadius;
  
  var returnColorOnly = false;

  if (uKernelSize == 0)
  {
    returnColorOnly = true;
  }

  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;
  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;
  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;
  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;
  let k: i32 = i32(uKernelSize - 1);

  var coord: vec2<f32> = uv;
  let dir: vec2<f32> = vec2<f32>(center - coord);
  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));

  var radianStep: f32 = uRadian;
  
  if (radius >= 0.0 && dist > radius)
  {
    let delta: f32 = dist - radius;
    let gap: f32 = gradient;
    let scale: f32 = 1.0 - abs(delta / gap);
    if (scale <= 0.0) {
      returnColorOnly = true;
    }
    radianStep *= scale;
  }

  radianStep /= f32(k);

  let s: f32 = sin(radianStep);
  let c: f32 = cos(radianStep);
  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));
  
  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let baseColor = vec4<f32>(color);

  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);

  for(var i: i32 = 0; i < minK; i += 1) 
  {
    coord -= center;
    coord.y *= aspect;
    coord = rotationMatrix * coord;
    coord.y /= aspect;
    coord += center;
    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);
    // switch to pre-multiplied alpha to correctly blur transparent images
    // sample.rgb *= sample.a;
    color += sample;
  }

  return select(color / f32(uKernelSize), baseColor, returnColorOnly);
}

const MAX_KERNEL_SIZE: i32 = 2048;`,__defProp$7=Object.defineProperty,__defNormalProp$7=(O,C,A)=>C in O?__defProp$7(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$7=(O,C,A)=>(__defNormalProp$7(O,typeof C!="symbol"?C+"":C,A),A);const _RadialBlurFilter=class Pn extends Filter{constructor(...C){var L;let A=(L=C[0])!=null?L:{};if(typeof A=="number"){if(deprecation("6.0.0","RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }"),A={angle:A},C[1]){const K="x"in C[1]?C[1].x:C[1][0],te="y"in C[1]?C[1].y:C[1][1];A.center={x:K,y:te}}C[2]&&(A.kernelSize=C[2]),C[3]&&(A.radius=C[3])}A={...Pn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$7,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$7,name:"radial-blur-filter"});super({gpuProgram:z,glProgram:I,resources:{radialBlurUniforms:{uRadian:{value:0,type:"f32"},uCenter:{value:A.center,type:"vec2<f32>"},uKernelSize:{value:A.kernelSize,type:"i32"},uRadius:{value:A.radius,type:"f32"}}}}),__publicField$7(this,"uniforms"),__publicField$7(this,"_angle"),__publicField$7(this,"_kernelSize"),this.uniforms=this.resources.radialBlurUniforms.uniforms,Object.assign(this,A)}_updateKernelSize(){this.uniforms.uKernelSize=this._angle!==0?this.kernelSize:0}get angle(){return this._angle}set angle(C){this._angle=C,this.uniforms.uRadian=C*Math.PI/180,this._updateKernelSize()}get center(){return this.uniforms.uCenter}set center(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uCenter=C}get centerX(){return this.center.x}set centerX(C){this.center.x=C}get centerY(){return this.center.y}set centerY(C){this.center.y=C}get kernelSize(){return this._kernelSize}set kernelSize(C){this._kernelSize=C,this._updateKernelSize()}get radius(){return this.uniforms.uRadius}set radius(C){this.uniforms.uRadius=C<0||C===1/0?-1:C}};__publicField$7(_RadialBlurFilter,"DEFAULT_OPTIONS",{angle:0,center:{x:0,y:0},kernelSize:5,radius:-1});var fragment$6=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uMirror;
uniform float uBoundary;
uniform vec2 uAmplitude;
uniform vec2 uWavelength;
uniform vec2 uAlpha;
uniform float uTime;
uniform vec2 uDimensions;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;
    vec2 coord = pixelCoord / uDimensions;

    if (coord.y < uBoundary) {
        finalColor = texture(uTexture, vTextureCoord);
        return;
    }

    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);
    float areaY = uBoundary * uDimensions.y / uInputSize.y;
    float v = areaY + areaY - vTextureCoord.y;
    float y = uMirror > 0.5 ? v : vTextureCoord.y;

    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;
    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;
    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;

    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;
    x = clamp(x, uInputClamp.x, uInputClamp.z);

    vec4 color = texture(uTexture, vec2(x, y));

    finalColor = color * _alpha;
}
`,source$6=`struct ReflectionUniforms {
  uMirror: f32,
  uBoundary: f32,
  uAmplitude: vec2<f32>,
  uWavelength: vec2<f32>,
  uAlpha: vec2<f32>,
  uTime: f32,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;
  let uBoundary: f32 = reflectionUniforms.uBoundary;
  let uMirror: bool = reflectionUniforms.uMirror > 0.5;
  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;
  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;
  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;
  let uTime: f32 = reflectionUniforms.uTime;

  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;
  let coord: vec2<f32> = pixelCoord /uDimensions;
  var returnColorOnly: bool = false;

  if (coord.y < uBoundary) {
    returnColorOnly = true;
  }

  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);
  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;
  let v: f32 = areaY + areaY - uv.y;
  let y: f32 = select(uv.y, v, uMirror);

  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;
  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;
  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);

  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;
  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);
  
  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;
}

fn rand(co: vec2<f32>) -> f32 
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}`,__defProp$6=Object.defineProperty,__defNormalProp$6=(O,C,A)=>C in O?__defProp$6(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$6=(O,C,A)=>(__defNormalProp$6(O,typeof C!="symbol"?C+"":C,A),A);const _ReflectionFilter=class En extends Filter{constructor(C){C={...En.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$6,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$6,name:"reflection-filter"});super({gpuProgram:A,glProgram:z,resources:{reflectionUniforms:{uMirror:{value:C.mirror?1:0,type:"f32"},uBoundary:{value:C.boundary,type:"f32"},uAmplitude:{value:C.amplitude,type:"vec2<f32>"},uWavelength:{value:C.waveLength,type:"vec2<f32>"},uAlpha:{value:C.alpha,type:"vec2<f32>"},uTime:{value:C.time,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField$6(this,"uniforms"),__publicField$6(this,"time",0),this.uniforms=this.resources.reflectionUniforms.uniforms,Object.assign(this,C)}apply(C,A,z,I){this.uniforms.uDimensions[0]=A.frame.width,this.uniforms.uDimensions[1]=A.frame.height,this.uniforms.uTime=this.time,C.applyFilter(this,A,z,I)}get mirror(){return this.uniforms.uMirror>.5}set mirror(C){this.uniforms.uMirror=C?1:0}get boundary(){return this.uniforms.uBoundary}set boundary(C){this.uniforms.uBoundary=C}get amplitude(){return Array.from(this.uniforms.uAmplitude)}set amplitude(C){this.uniforms.uAmplitude[0]=C[0],this.uniforms.uAmplitude[1]=C[1]}get amplitudeStart(){return this.uniforms.uAmplitude[0]}set amplitudeStart(C){this.uniforms.uAmplitude[0]=C}get amplitudeEnd(){return this.uniforms.uAmplitude[1]}set amplitudeEnd(C){this.uniforms.uAmplitude[1]=C}get waveLength(){return Array.from(this.uniforms.uWavelength)}set waveLength(C){this.uniforms.uWavelength[0]=C[0],this.uniforms.uWavelength[1]=C[1]}get wavelengthStart(){return this.uniforms.uWavelength[0]}set wavelengthStart(C){this.uniforms.uWavelength[0]=C}get wavelengthEnd(){return this.uniforms.uWavelength[1]}set wavelengthEnd(C){this.uniforms.uWavelength[1]=C}get alpha(){return Array.from(this.uniforms.uAlpha)}set alpha(C){this.uniforms.uAlpha[0]=C[0],this.uniforms.uAlpha[1]=C[1]}get alphaStart(){return this.uniforms.uAlpha[0]}set alphaStart(C){this.uniforms.uAlpha[0]=C}get alphaEnd(){return this.uniforms.uAlpha[1]}set alphaEnd(C){this.uniforms.uAlpha[1]=C}};__publicField$6(_ReflectionFilter,"DEFAULT_OPTIONS",{mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0});var fragment$5=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec4 uInputSize;
uniform vec2 uRed;
uniform vec2 uGreen;
uniform vec2 uBlue;

void main(void)
{
   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;
   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;
   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;
   float a = texture(uTexture, vTextureCoord).a;
   finalColor = vec4(r, g, b, a);
}
`,source$5=`struct RgbSplitUniforms {
    uRed: vec2<f32>,
    uGreen: vec2<f32>,
    uBlue: vec3<f32>,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;
    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;
    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;
    let a = textureSample(uTexture, uSampler, uv).a;
    return vec4<f32>(r, g, b, a);
}
`,__defProp$5=Object.defineProperty,__defNormalProp$5=(O,C,A)=>C in O?__defProp$5(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$5=(O,C,A)=>(__defNormalProp$5(O,typeof C!="symbol"?C+"":C,A),A);const _RGBSplitFilter=class An extends Filter{constructor(...C){var L;let A=(L=C[0])!=null?L:{};(Array.isArray(A)||"x"in A&&"y"in A)&&(deprecation("6.0.0","RGBSplitFilter constructor params are now options object. See params: { red, green, blue }"),A={red:A},C[1]!==void 0&&(A.green=C[1]),C[2]!==void 0&&(A.blue=C[2])),A={...An.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$5,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$5,name:"rgb-split-filter"});super({gpuProgram:z,glProgram:I,resources:{rgbSplitUniforms:{uRed:{value:A.red,type:"vec2<f32>"},uGreen:{value:A.green,type:"vec2<f32>"},uBlue:{value:A.blue,type:"vec2<f32>"}}}}),__publicField$5(this,"uniforms"),this.uniforms=this.resources.rgbSplitUniforms.uniforms,Object.assign(this,A)}get red(){return this.uniforms.uRed}set red(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uRed=C}get redX(){return this.red.x}set redX(C){this.red.x=C}get redY(){return this.red.y}set redY(C){this.red.y=C}get green(){return this.uniforms.uGreen}set green(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uGreen=C}get greenX(){return this.green.x}set greenX(C){this.green.x=C}get greenY(){return this.green.y}set greenY(C){this.green.y=C}get blue(){return this.uniforms.uBlue}set blue(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uBlue=C}get blueX(){return this.blue.x}set blueX(C){this.blue.x=C}get blueY(){return this.blue.y}set blueY(C){this.blue.y=C}};__publicField$5(_RGBSplitFilter,"DEFAULT_OPTIONS",{red:{x:-10,y:0},green:{x:0,y:10},blue:{x:0,y:0}});var fragment$4=`
precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uCenter;
uniform float uTime;
uniform float uSpeed;
uniform vec4 uWave;

uniform vec4 uInputSize;
uniform vec4 uInputClamp;

const float PI = 3.14159;

void main()
{
    float uAmplitude = uWave[0];
    float uWavelength = uWave[1];
    float uBrightness = uWave[2];
    float uRadius = uWave[3];

    float halfWavelength = uWavelength * 0.5 / uInputSize.x;
    float maxRadius = uRadius / uInputSize.x;
    float currentRadius = uTime * uSpeed / uInputSize.x;

    float fade = 1.0;

    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            finalColor = texture(uTexture, vTextureCoord);
            return;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }

    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);
    dir.y *= uInputSize.y / uInputSize.x;
    float dist = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        finalColor = texture(uTexture, vTextureCoord);
        return;
    }

    vec2 diffUV = normalize(dir);

    float diff = (dist - currentRadius) / halfWavelength;

    float p = 1.0 - pow(abs(diff), 2.0);

    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );
    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );

    vec2 offset = diffUV * powDiff / uInputSize.xy;

    // Do clamp :
    vec2 coord = vTextureCoord + offset;
    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);
    vec4 color = texture(uTexture, clampedCoord);
    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    // No clamp :
    // finalColor = texture(uTexture, vTextureCoord + offset);

    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;

    finalColor = color;
}
`,source$4=`
struct ShockWaveUniforms {
    uTime: f32,
    uOffset: vec2<f32>,
    uSpeed: f32,
    uWave: vec4<f32>,
};

struct GlobalFilterUniforms {
    uInputSize:vec4<f32>,
    uInputPixel:vec4<f32>,
    uInputClamp:vec4<f32>,
    uOutputFrame:vec4<f32>,
    uGlobalFrame:vec4<f32>,
    uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {

    let uTime = shockwaveUniforms.uTime;
    let uOffset = shockwaveUniforms.uOffset;
    let uSpeed = shockwaveUniforms.uSpeed;
    let uAmplitude = shockwaveUniforms.uWave[0];
    let uWavelength = shockwaveUniforms.uWave[1];
    let uBrightness = shockwaveUniforms.uWave[2];
    let uRadius = shockwaveUniforms.uWave[3];
    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;
    let maxRadius: f32 = uRadius / gfu.uInputSize.x;
    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;
    var fade: f32 = 1.0;
    var returnColorOnly: bool = false;
    
    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            returnColorOnly = true;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }
    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);
    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;

    let dist:f32 = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        returnColorOnly = true;
    }

    let diffUV: vec2<f32> = normalize(dir);
    let diff: f32 = (dist - currentRadius) / halfWavelength;
    let p: f32 = 1.0 - pow(abs(diff), 2.0);
    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );
    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;
    // Do clamp :
    let coord: vec2<f32> = uv + offset;
    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);

    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);
    
    if (boolVec2(coord, clampedCoord)) 
    {
        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));
    }
    // No clamp :
    var finalColor = clampedColor;

    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);
}

fn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
    if (x.x == y.x && x.y == y.y)
    {
        return true;
    }
    
    return false;
}

const PI: f32 = 3.14159265358979323846264;
`,__defProp$4=Object.defineProperty,__defNormalProp$4=(O,C,A)=>C in O?__defProp$4(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$4=(O,C,A)=>(__defNormalProp$4(O,typeof C!="symbol"?C+"":C,A),A);const _ShockwaveFilter=class Fn extends Filter{constructor(...C){var L;let A=(L=C[0])!=null?L:{};(Array.isArray(A)||"x"in A&&"y"in A)&&(deprecation("6.0.0","ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }"),A={center:A,...C[1]},C[2]!==void 0&&(A.time=C[2])),A={...Fn.DEFAULT_OPTIONS,...A};const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$4,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$4,name:"shockwave-filter"});super({gpuProgram:z,glProgram:I,resources:{shockwaveUniforms:{uTime:{value:A.time,type:"f32"},uCenter:{value:A.center,type:"vec2<f32>"},uSpeed:{value:A.speed,type:"f32"},uWave:{value:new Float32Array(4),type:"vec4<f32>"}}}}),__publicField$4(this,"uniforms"),__publicField$4(this,"time"),this.time=0,this.uniforms=this.resources.shockwaveUniforms.uniforms,Object.assign(this,A)}apply(C,A,z,I){this.uniforms.uTime=this.time,C.applyFilter(this,A,z,I)}get center(){return this.uniforms.uCenter}set center(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uCenter=C}get centerX(){return this.uniforms.uCenter.x}set centerX(C){this.uniforms.uCenter.x=C}get centerY(){return this.uniforms.uCenter.y}set centerY(C){this.uniforms.uCenter.y=C}get speed(){return this.uniforms.uSpeed}set speed(C){this.uniforms.uSpeed=C}get amplitude(){return this.uniforms.uWave[0]}set amplitude(C){this.uniforms.uWave[0]=C}get wavelength(){return this.uniforms.uWave[1]}set wavelength(C){this.uniforms.uWave[1]=C}get brightness(){return this.uniforms.uWave[2]}set brightness(C){this.uniforms.uWave[2]=C}get radius(){return this.uniforms.uWave[3]}set radius(C){this.uniforms.uWave[3]=C}};__publicField$4(_ShockwaveFilter,"DEFAULT_OPTIONS",{center:{x:0,y:0},speed:500,amplitude:30,wavelength:160,brightness:1,radius:-1});var fragment$3=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;
uniform vec3 uColor;
uniform float uAlpha;
uniform vec2 uDimensions;

uniform vec4 uInputSize;

void main() {
    vec4 diffuseColor = texture(uTexture, vTextureCoord);
    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;
    vec4 light = texture(uMapTexture, lightCoord);
    vec3 ambient = uColor.rgb * uAlpha;
    vec3 intensity = ambient + light.rgb;
    vec3 color = diffuseColor.rgb * intensity;
    finalColor = vec4(color, diffuseColor.a);
}
`,source$3=`struct SimpleLightmapUniforms {
  uColor: vec3<f32>,
  uAlpha: f32,
  uDimensions: vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;
@group(1) @binding(2) var uMapSampler: sampler;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>,
) -> @location(0) vec4<f32> {
  let uColor = simpleLightmapUniforms.uColor;
  let uAlpha = simpleLightmapUniforms.uAlpha;
  let uDimensions = simpleLightmapUniforms.uDimensions;

  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);
  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;
  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);
  let ambient: vec3<f32> = uColor * uAlpha;
  let intensity: vec3<f32> = ambient + light.rgb;
  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;
  return vec4<f32>(finalColor, diffuseColor.a);
}`,__defProp$3=Object.defineProperty,__defNormalProp$3=(O,C,A)=>C in O?__defProp$3(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$3=(O,C,A)=>(__defNormalProp$3(O,typeof C!="symbol"?C+"":C,A),A);const _SimpleLightmapFilter=class Mn extends Filter{constructor(...C){var L,K;let A=(L=C[0])!=null?L:{};if(A instanceof Texture&&(deprecation("6.0.0","SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }"),A={lightMap:A},C[1]!==void 0&&(A.color=C[1]),C[2]!==void 0&&(A.alpha=C[2])),A={...Mn.DEFAULT_OPTIONS,...A},!A.lightMap)throw Error("No light map texture source was provided to SimpleLightmapFilter");const z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$3,entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment$3,name:"simple-lightmap-filter"});super({gpuProgram:z,glProgram:I,resources:{simpleLightmapUniforms:{uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:A.alpha,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}},uMapTexture:A.lightMap.source,uMapSampler:A.lightMap.source.style}}),__publicField$3(this,"uniforms"),__publicField$3(this,"_color"),__publicField$3(this,"_lightMap"),this.uniforms=this.resources.simpleLightmapUniforms.uniforms,this._color=new Color,this.color=(K=A.color)!=null?K:0,Object.assign(this,A)}apply(C,A,z,I){this.uniforms.uDimensions[0]=A.frame.width,this.uniforms.uDimensions[1]=A.frame.height,C.applyFilter(this,A,z,I)}get lightMap(){return this._lightMap}set lightMap(C){this._lightMap=C,this.resources.uMapTexture=C.source,this.resources.uMapSampler=C.source.style}get color(){return this._color.value}set color(C){this._color.setValue(C);const[A,z,I]=this._color.toArray();this.uniforms.uColor[0]=A,this.uniforms.uColor[1]=z,this.uniforms.uColor[2]=I}get alpha(){return this.uniforms.uAlpha}set alpha(C){this.uniforms.uAlpha=C}};__publicField$3(_SimpleLightmapFilter,"DEFAULT_OPTIONS",{lightMap:Texture.WHITE,color:0,alpha:1});var fragment$2=`in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uBlur;
uniform vec2 uStart;
uniform vec2 uEnd;
uniform vec2 uDelta;
uniform vec2 uDimensions;

float random(vec3 scale, float seed)
{
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

void main(void)
{
    vec4 color = vec4(0.0);
    float total = 0.0;

    float blur = uBlur[0];
    float gradientBlur = uBlur[1];

    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));
    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uDimensions - uStart, normal)) / gradientBlur) * blur;

    for (float t = -30.0; t <= 30.0; t++)
    {
        float percent = (t + offset - 0.5) / 30.0;
        float weight = 1.0 - abs(percent);
        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uDimensions * percent * radius);
        sample.rgb *= sample.a;
        color += sample * weight;
        total += weight;
    }

    color /= total;
    color.rgb /= color.a + 0.00001;

    finalColor = color;
}
`,source$2=`struct TiltShiftUniforms {
  uBlur: vec2<f32>,
  uStart: vec2<f32>,
  uEnd: vec2<f32>,
  uDelta: vec2<f32>,
  uDimensions: vec2<f32>,
};

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uBlur = tiltShiftUniforms.uBlur[0];
  let uBlurGradient = tiltShiftUniforms.uBlur[1];
  let uStart = tiltShiftUniforms.uStart;
  let uEnd = tiltShiftUniforms.uEnd;
  let uDelta = tiltShiftUniforms.uDelta;
  let uDimensions = tiltShiftUniforms.uDimensions;

  var color: vec4<f32> = vec4<f32>(0.0);
  var total: f32 = 0.0;

  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);
  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));
  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * uDimensions - uStart, normal)) / uBlurGradient) * uBlur;

  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)
  {
    var percent: f32 = (t + offset - 0.5) / 30.0;
    var weight: f32 = 1.0 - abs(percent);
    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / uDimensions * percent * radius);
    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a
    color += sample * weight;
    total += weight;
  }

  color /= total;
  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001

  return color;
}


fn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32
{
  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);
}`,__defProp$2=Object.defineProperty,__defNormalProp$2=(O,C,A)=>C in O?__defProp$2(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$2=(O,C,A)=>(__defNormalProp$2(O,typeof C!="symbol"?C+"":C,A),A);const _TiltShiftAxisFilter=class Rn extends Filter{constructor(C){const{width:A,height:z}=ViewSystem.defaultOptions;C={...Rn.DEFAULT_OPTIONS,start:{x:0,y:z/2},end:{x:A,y:z/2},...C};const I=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$2,entryPoint:"mainFragment"}}),L=GlProgram.from({vertex:vertex$1,fragment:fragment$2,name:"tilt-shift-axis-filter"});super({gpuProgram:I,glProgram:L,resources:{tiltShiftUniforms:{uBlur:{value:new Float32Array([C.blur,C.gradientBlur]),type:"vec2<f32>"},uStart:{value:C.start,type:"vec2<f32>"},uEnd:{value:C.end,type:"vec2<f32>"},uDelta:{value:new Float32Array([0,0]),type:"vec2<f32>"},uDimensions:{value:new Float32Array([A,z]),type:"vec2<f32>"}}}}),__publicField$2(this,"uniforms"),__publicField$2(this,"_tiltAxis"),this.uniforms=this.resources.tiltShiftUniforms.uniforms,this._tiltAxis=C.axis}updateDimensions(C){const{uDimensions:A}=this.uniforms;A[0]=C.frame.width,A[1]=C.frame.height}updateDelta(){if(this.uniforms.uDelta[0]=0,this.uniforms.uDelta[1]=0,this._tiltAxis===void 0)return;const C=this.uniforms.uEnd,A=this.uniforms.uStart,z=C.x-A.x,I=C.y-A.y,L=Math.sqrt(z*z+I*I),K=this._tiltAxis==="vertical";this.uniforms.uDelta[0]=K?-I/L:z/L,this.uniforms.uDelta[1]=K?z/L:I/L}};__publicField$2(_TiltShiftAxisFilter,"DEFAULT_OPTIONS",{blur:100,gradientBlur:600});var fragment$1=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uTwist;
uniform vec2 uOffset;
uniform vec4 uInputSize;

vec2 mapCoord( vec2 coord )
{
    coord *= uInputSize.xy;
    coord += uInputSize.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= uInputSize.zw;
    coord /= uInputSize.xy;

    return coord;
}

vec2 twist(vec2 coord)
{
    coord -= uOffset;

    float dist = length(coord);
    float uRadius = uTwist[0];
    float uAngle = uTwist[1];

    if (dist < uRadius)
    {
        float ratioDist = (uRadius - dist) / uRadius;
        float angleMod = ratioDist * ratioDist * uAngle;
        float s = sin(angleMod);
        float c = cos(angleMod);
        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);
    }

    coord += uOffset;

    return coord;
}

void main(void)
{
    vec2 coord = mapCoord(vTextureCoord);
    coord = twist(coord);
    coord = unmapCoord(coord);
    finalColor = texture(uTexture, coord);
}
`,source$1=`struct TwistUniforms {
  uTwist:vec2<f32>,
  uOffset:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));
}

fn mapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord *= gfu.uInputSize.xy;
  mappedCoord += gfu.uOutputFrame.xy;
  return mappedCoord;
}

fn unmapCoord(coord: vec2<f32> ) -> vec2<f32>
{
  var mappedCoord: vec2<f32> = coord;
  mappedCoord -= gfu.uOutputFrame.xy;
  mappedCoord /= gfu.uInputSize.xy;
  return mappedCoord;
}

fn twist(coord: vec2<f32>) -> vec2<f32>
{
  var twistedCoord: vec2<f32> = coord;
  let uRadius = twistUniforms.uTwist[0];
  let uAngle = twistUniforms.uTwist[1];
  let uOffset = twistUniforms.uOffset;

  twistedCoord -= uOffset;
  
  let dist = length(twistedCoord);

  if (dist < uRadius)
  {
    let ratioDist: f32 = (uRadius - dist) / uRadius;
    let angleMod: f32 = ratioDist * ratioDist * uAngle;
    let s: f32 = sin(angleMod);
    let c: f32 = cos(angleMod);
    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);
  }

  twistedCoord += uOffset;
  return twistedCoord;
}
`,__defProp$1=Object.defineProperty,__defNormalProp$1=(O,C,A)=>C in O?__defProp$1(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField$1=(O,C,A)=>(__defNormalProp$1(O,typeof C!="symbol"?C+"":C,A),A);const _TwistFilter=class zn extends Filter{constructor(C){var I,L;C={...zn.DEFAULT_OPTIONS,...C};const A=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source$1,entryPoint:"mainFragment"}}),z=GlProgram.from({vertex:vertex$1,fragment:fragment$1,name:"twist-filter"});super({gpuProgram:A,glProgram:z,resources:{twistUniforms:{uTwist:{value:[(I=C.radius)!=null?I:0,(L=C.angle)!=null?L:0],type:"vec2<f32>"},uOffset:{value:C.offset,type:"vec2<f32>"}}},...C}),__publicField$1(this,"uniforms"),this.uniforms=this.resources.twistUniforms.uniforms}get radius(){return this.uniforms.uTwist[0]}set radius(C){this.uniforms.uTwist[0]=C}get angle(){return this.uniforms.uTwist[1]}set angle(C){this.uniforms.uTwist[1]=C}get offset(){return this.uniforms.uOffset}set offset(C){this.uniforms.uOffset=C}get offsetX(){return this.offset.x}set offsetX(C){this.offset.x=C}get offsetY(){return this.offset.y}set offsetY(C){this.offset.y=C}};__publicField$1(_TwistFilter,"DEFAULT_OPTIONS",{padding:20,radius:200,angle:4,offset:{x:0,y:0}});var fragment=`precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform float uStrength;
uniform vec2 uCenter;
uniform vec2 uRadii;

uniform vec4 uInputSize;

const float MAX_KERNEL_SIZE = \${MAX_KERNEL_SIZE};

// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand(vec2 co, float seed) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);
    return fract(sin(sn) * c + seed);
}

void main() {
    float minGradient = uRadii[0] * 0.3;
    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;

    float gradient = uRadii[1] * 0.3;
    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;

    float countLimit = MAX_KERNEL_SIZE;

    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);
    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));

    float strength = uStrength;

    float delta = 0.0;
    float gap;
    if (dist < innerRadius) {
        delta = innerRadius - dist;
        gap = minGradient;
    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity
        delta = dist - radius;
        gap = gradient;
    }

    if (delta > 0.0) {
        float normalCount = gap / uInputSize.x;
        delta = (normalCount - delta) / normalCount;
        countLimit *= delta;
        strength *= delta;
        if (countLimit < 1.0)
        {
            gl_FragColor = texture(uTexture, vTextureCoord);
            return;
        }
    }

    // randomize the lookup values to hide the fixed number of samples
    float offset = rand(vTextureCoord, 0.0);

    float total = 0.0;
    vec4 color = vec4(0.0);

    dir *= strength;

    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {
        float percent = (t + offset) / MAX_KERNEL_SIZE;
        float weight = 4.0 * (percent - percent * percent);
        vec2 p = vTextureCoord + dir * percent;
        vec4 sample = texture(uTexture, p);

        // switch to pre-multiplied alpha to correctly blur transparent images
        // sample.rgb *= sample.a;

        color += sample * weight;
        total += weight;

        if (t > countLimit){
            break;
        }
    }

    color /= total;
    // switch back from pre-multiplied alpha
    // color.rgb /= color.a + 0.00001;

    gl_FragColor = color;
}
`,source=`struct ZoomBlurUniforms {
    uStrength:f32,
    uCenter:vec2<f32>,
    uRadii:vec2<f32>,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>; 
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uStrength = zoomBlurUniforms.uStrength;
  let uCenter = zoomBlurUniforms.uCenter;
  let uRadii = zoomBlurUniforms.uRadii;

  let minGradient: f32 = uRadii[0] * 0.3;
  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;

  let gradient: f32 = uRadii[1] * 0.3;
  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;

  let MAX_KERNEL_SIZE: f32 = \${MAX_KERNEL_SIZE};

  var countLimit: f32 = MAX_KERNEL_SIZE;

  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);
  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));

  var strength: f32 = uStrength;

  var delta: f32 = 0.0;
  var gap: f32;

  if (dist < innerRadius) {
      delta = innerRadius - dist;
      gap = minGradient;
  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity
      delta = dist - radius;
      gap = gradient;
  }

  var returnColorOnly: bool = false;

  if (delta > 0.0) {
    let normalCount: f32 = gap / gfu.uInputSize.x;
    delta = (normalCount - delta) / normalCount;
    countLimit *= delta;
    strength *= delta;
    
    if (countLimit < 1.0)
    {
      returnColorOnly = true;;
    }
  }

  // randomize the lookup values to hide the fixed number of samples
  let offset: f32 = rand(uv, 0.0);

  var total: f32 = 0.0;
  var color: vec4<f32> = vec4<f32>(0.);

  dir *= strength;

  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {
    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;
    let weight: f32 = 4.0 * (percent - percent * percent);
    let p: vec2<f32> = uv + dir * percent;
    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);
    
    if (t < countLimit)
    {
      color += sample * weight;
      total += weight;
    }
  }

  color /= total;

  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);
}

fn modulo(x: f32, y: f32) -> f32
{
  return x - y * floor(x/y);
}

// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
fn rand(co: vec2<f32>, seed: f32) -> f32
{
  let a: f32 = 12.9898;
  let b: f32 = 78.233;
  let c: f32 = 43758.5453;
  let dt: f32 = dot(co + seed, vec2<f32>(a, b));
  let sn: f32 = modulo(dt, 3.14159);
  return fract(sin(sn) * c + seed);
}`,__defProp=Object.defineProperty,__defNormalProp=(O,C,A)=>C in O?__defProp(O,C,{enumerable:!0,configurable:!0,writable:!0,value:A}):O[C]=A,__publicField=(O,C,A)=>(__defNormalProp(O,typeof C!="symbol"?C+"":C,A),A);const _ZoomBlurFilter=class On extends Filter{constructor(C){var L;C={...On.DEFAULT_OPTIONS,...C};const A=(L=C.maxKernelSize)!=null?L:32,z=GpuProgram.from({vertex:{source:wgslVertex,entryPoint:"mainVertex"},fragment:{source:source.replace("${MAX_KERNEL_SIZE}",A.toFixed(1)),entryPoint:"mainFragment"}}),I=GlProgram.from({vertex:vertex$1,fragment:fragment.replace("${MAX_KERNEL_SIZE}",A.toFixed(1)),name:"zoom-blur-filter"});super({gpuProgram:z,glProgram:I,resources:{zoomBlurUniforms:{uStrength:{value:C.strength,type:"f32"},uCenter:{value:C.center,type:"vec2<f32>"},uRadii:{value:new Float32Array(2),type:"vec2<f32>"}}}}),__publicField(this,"uniforms"),this.uniforms=this.resources.zoomBlurUniforms.uniforms,Object.assign(this,C)}get strength(){return this.uniforms.uStrength}set strength(C){this.uniforms.uStrength=C}get center(){return this.uniforms.uCenter}set center(C){Array.isArray(C)&&(C={x:C[0],y:C[1]}),this.uniforms.uCenter=C}get centerX(){return this.uniforms.uCenter.x}set centerX(C){this.uniforms.uCenter.x=C}get centerY(){return this.uniforms.uCenter.y}set centerY(C){this.uniforms.uCenter.y=C}get innerRadius(){return this.uniforms.uRadii[0]}set innerRadius(C){this.uniforms.uRadii[0]=C}get radius(){return this.uniforms.uRadii[1]}set radius(C){this.uniforms.uRadii[1]=C<0||C===1/0?-1:C}};__publicField(_ZoomBlurFilter,"DEFAULT_OPTIONS",{strength:.1,center:{x:0,y:0},innerRadius:0,radius:-1,maxKernelSize:32});var __accessCheck=(O,C,A)=>{if(!C.has(O))throw TypeError("Cannot "+A)},__privateGet=(O,C,A)=>(__accessCheck(O,C,"read from private field"),A?A.call(O):C.get(O)),__privateAdd=(O,C,A)=>{if(C.has(O))throw TypeError("Cannot add the same private member more than once");C instanceof WeakSet?C.add(O):C.set(O,A)},__privateSet=(O,C,A,z)=>(__accessCheck(O,C,"write to private field"),z?z.call(O,A):C.set(O,A),A),__privateWrapper=(O,C,A,z)=>({set _(I){__privateSet(O,C,I,A)},get _(){return __privateGet(O,C,z)}}),__privateMethod=(O,C,A)=>(__accessCheck(O,C,"access private method"),A),bytes=new Uint8Array(8),view=new DataView(bytes.buffer),u8=O=>[(O%256+256)%256],u16=O=>(view.setUint16(0,O,!1),[bytes[0],bytes[1]]),i16=O=>(view.setInt16(0,O,!1),[bytes[0],bytes[1]]),u24=O=>(view.setUint32(0,O,!1),[bytes[1],bytes[2],bytes[3]]),u32=O=>(view.setUint32(0,O,!1),[bytes[0],bytes[1],bytes[2],bytes[3]]),i32=O=>(view.setInt32(0,O,!1),[bytes[0],bytes[1],bytes[2],bytes[3]]),u64=O=>(view.setUint32(0,Math.floor(O/2**32),!1),view.setUint32(4,O,!1),[bytes[0],bytes[1],bytes[2],bytes[3],bytes[4],bytes[5],bytes[6],bytes[7]]),fixed_8_8=O=>(view.setInt16(0,2**8*O,!1),[bytes[0],bytes[1]]),fixed_16_16=O=>(view.setInt32(0,2**16*O,!1),[bytes[0],bytes[1],bytes[2],bytes[3]]),fixed_2_30=O=>(view.setInt32(0,2**30*O,!1),[bytes[0],bytes[1],bytes[2],bytes[3]]),ascii=(O,C=!1)=>{let A=Array(O.length).fill(null).map((z,I)=>O.charCodeAt(I));return C&&A.push(0),A},last=O=>O&&O[O.length-1],lastPresentedSample=O=>{let C;for(let A of O)(!C||A.presentationTimestamp>C.presentationTimestamp)&&(C=A);return C},intoTimescale=(O,C,A=!0)=>{let z=O*C;return A?Math.round(z):z},rotationMatrix=O=>{let C=O*(Math.PI/180),A=Math.cos(C),z=Math.sin(C);return[A,z,0,-z,A,0,0,0,1]},IDENTITY_MATRIX=rotationMatrix(0),matrixToBytes=O=>[fixed_16_16(O[0]),fixed_16_16(O[1]),fixed_2_30(O[2]),fixed_16_16(O[3]),fixed_16_16(O[4]),fixed_2_30(O[5]),fixed_16_16(O[6]),fixed_16_16(O[7]),fixed_2_30(O[8])],deepClone=O=>!O||typeof O!="object"?O:Array.isArray(O)?O.map(deepClone):Object.fromEntries(Object.entries(O).map(([C,A])=>[C,deepClone(A)])),isU32=O=>O>=0&&O<2**32,box=(O,C,A)=>({type:O,contents:C&&new Uint8Array(C.flat(10)),children:A}),fullBox=(O,C,A,z,I)=>box(O,[u8(C),u24(A),z!=null?z:[]],I),ftyp=O=>{let C=512;return O.fragmented?box("ftyp",[ascii("iso5"),u32(C),ascii("iso5"),ascii("iso6"),ascii("mp41")]):box("ftyp",[ascii("isom"),u32(C),ascii("isom"),O.holdsAvc?ascii("avc1"):[],ascii("mp41")])},mdat=O=>({type:"mdat",largeSize:O}),free=O=>({type:"free",size:O}),moov=(O,C,A=!1)=>box("moov",null,[mvhd(C,O),...O.map(z=>trak(z,C)),A?mvex(O):null]),mvhd=(O,C)=>{let A=intoTimescale(Math.max(0,...C.filter(K=>K.samples.length>0).map(K=>{const te=lastPresentedSample(K.samples);return te.presentationTimestamp+te.duration})),GLOBAL_TIMESCALE),z=Math.max(...C.map(K=>K.id))+1,I=!isU32(O)||!isU32(A),L=I?u64:u32;return fullBox("mvhd",+I,0,[L(O),L(O),u32(GLOBAL_TIMESCALE),L(A),fixed_16_16(1),fixed_8_8(1),Array(10).fill(0),matrixToBytes(IDENTITY_MATRIX),Array(24).fill(0),u32(z)])},trak=(O,C)=>box("trak",null,[tkhd(O,C),mdia(O,C)]),tkhd=(O,C)=>{let A=lastPresentedSample(O.samples),z=intoTimescale(A?A.presentationTimestamp+A.duration:0,GLOBAL_TIMESCALE),I=!isU32(C)||!isU32(z),L=I?u64:u32,K;return O.info.type==="video"?K=typeof O.info.rotation=="number"?rotationMatrix(O.info.rotation):O.info.rotation:K=IDENTITY_MATRIX,fullBox("tkhd",+I,3,[L(C),L(C),u32(O.id),u32(0),L(z),Array(8).fill(0),u16(0),u16(0),fixed_8_8(O.info.type==="audio"?1:0),u16(0),matrixToBytes(K),fixed_16_16(O.info.type==="video"?O.info.width:0),fixed_16_16(O.info.type==="video"?O.info.height:0)])},mdia=(O,C)=>box("mdia",null,[mdhd(O,C),hdlr(O.info.type==="video"?"vide":"soun"),minf(O)]),mdhd=(O,C)=>{let A=lastPresentedSample(O.samples),z=intoTimescale(A?A.presentationTimestamp+A.duration:0,O.timescale),I=!isU32(C)||!isU32(z),L=I?u64:u32;return fullBox("mdhd",+I,0,[L(C),L(C),u32(O.timescale),L(z),u16(21956),u16(0)])},hdlr=O=>fullBox("hdlr",0,0,[ascii("mhlr"),ascii(O),u32(0),u32(0),u32(0),ascii("mp4-muxer-hdlr",!0)]),minf=O=>box("minf",null,[O.info.type==="video"?vmhd():smhd(),dinf(),stbl(O)]),vmhd=()=>fullBox("vmhd",0,1,[u16(0),u16(0),u16(0),u16(0)]),smhd=()=>fullBox("smhd",0,0,[u16(0),u16(0)]),dinf=()=>box("dinf",null,[dref()]),dref=()=>fullBox("dref",0,0,[u32(1)],[url()]),url=()=>fullBox("url ",0,1),stbl=O=>{const C=O.compositionTimeOffsetTable.length>1||O.compositionTimeOffsetTable.some(A=>A.sampleCompositionTimeOffset!==0);return box("stbl",null,[stsd(O),stts(O),stss(O),stsc(O),stsz(O),stco(O),C?ctts(O):null])},stsd=O=>fullBox("stsd",0,0,[u32(1)],[O.info.type==="video"?videoSampleDescription(VIDEO_CODEC_TO_BOX_NAME[O.info.codec],O):soundSampleDescription(AUDIO_CODEC_TO_BOX_NAME[O.info.codec],O)]),videoSampleDescription=(O,C)=>box(O,[Array(6).fill(0),u16(1),u16(0),u16(0),Array(12).fill(0),u16(C.info.width),u16(C.info.height),u32(4718592),u32(4718592),u32(0),u16(1),Array(32).fill(0),u16(24),i16(65535)],[VIDEO_CODEC_TO_CONFIGURATION_BOX[C.info.codec](C)]),avcC=O=>O.info.decoderConfig&&box("avcC",[...new Uint8Array(O.info.decoderConfig.description)]),hvcC=O=>O.info.decoderConfig&&box("hvcC",[...new Uint8Array(O.info.decoderConfig.description)]),vpcC=O=>{if(!O.info.decoderConfig)return null;let C=O.info.decoderConfig;if(!C.colorSpace)throw new Error("'colorSpace' is required in the decoder config for VP9.");let A=C.codec.split("."),z=Number(A[1]),I=Number(A[2]),L=Number(A[3]),K=0,te=(L<<4)+(K<<1)+Number(C.colorSpace.fullRange),ne=2,ie=2,oe=2;return fullBox("vpcC",1,0,[u8(z),u8(I),u8(te),u8(ne),u8(ie),u8(oe),u16(0)])},av1C=()=>{let O=1,C=1,A=(O<<7)+C;return box("av1C",[A,0,0,0])},soundSampleDescription=(O,C)=>box(O,[Array(6).fill(0),u16(1),u16(0),u16(0),u32(0),u16(C.info.numberOfChannels),u16(16),u16(0),u16(0),fixed_16_16(C.info.sampleRate)],[AUDIO_CODEC_TO_CONFIGURATION_BOX[C.info.codec](C)]),esds=O=>{let C=new Uint8Array(O.info.decoderConfig.description);return fullBox("esds",0,0,[u32(58753152),u8(32+C.byteLength),u16(1),u8(0),u32(75530368),u8(18+C.byteLength),u8(64),u8(21),u24(0),u32(130071),u32(130071),u32(92307584),u8(C.byteLength),...C,u32(109084800),u8(1),u8(2)])},dOps=O=>{let C=3840,A=0;const z=O.info.decoderConfig.description;if(z){const I=new DataView(ArrayBuffer.isView(z)?z.buffer:z);C=I.getUint16(10,!0),A=I.getInt16(14,!0)}return box("dOps",[u8(0),u8(O.info.numberOfChannels),u16(C),u32(O.info.sampleRate),fixed_8_8(A),u8(0)])},stts=O=>fullBox("stts",0,0,[u32(O.timeToSampleTable.length),O.timeToSampleTable.map(C=>[u32(C.sampleCount),u32(C.sampleDelta)])]),stss=O=>{if(O.samples.every(A=>A.type==="key"))return null;let C=[...O.samples.entries()].filter(([,A])=>A.type==="key");return fullBox("stss",0,0,[u32(C.length),C.map(([A])=>u32(A+1))])},stsc=O=>fullBox("stsc",0,0,[u32(O.compactlyCodedChunkTable.length),O.compactlyCodedChunkTable.map(C=>[u32(C.firstChunk),u32(C.samplesPerChunk),u32(1)])]),stsz=O=>fullBox("stsz",0,0,[u32(0),u32(O.samples.length),O.samples.map(C=>u32(C.size))]),stco=O=>O.finalizedChunks.length>0&&last(O.finalizedChunks).offset>=2**32?fullBox("co64",0,0,[u32(O.finalizedChunks.length),O.finalizedChunks.map(C=>u64(C.offset))]):fullBox("stco",0,0,[u32(O.finalizedChunks.length),O.finalizedChunks.map(C=>u32(C.offset))]),ctts=O=>fullBox("ctts",0,0,[u32(O.compositionTimeOffsetTable.length),O.compositionTimeOffsetTable.map(C=>[u32(C.sampleCount),u32(C.sampleCompositionTimeOffset)])]),mvex=O=>box("mvex",null,O.map(trex)),trex=O=>fullBox("trex",0,0,[u32(O.id),u32(1),u32(0),u32(0),u32(0)]),moof=(O,C)=>box("moof",null,[mfhd(O),...C.map(traf)]),mfhd=O=>fullBox("mfhd",0,0,[u32(O)]),fragmentSampleFlags=O=>{let C=0,A=0,z=0,I=0,L=O.type==="delta";return A|=+L,L?C|=1:C|=2,C<<24|A<<16|z<<8|I},traf=O=>box("traf",null,[tfhd(O),tfdt(O),trun(O)]),tfhd=O=>{var I;let C=0;C|=8,C|=16,C|=32,C|=131072;let A=(I=O.currentChunk.samples[1])!=null?I:O.currentChunk.samples[0],z={duration:A.timescaleUnitsToNextSample,size:A.size,flags:fragmentSampleFlags(A)};return fullBox("tfhd",0,C,[u32(O.id),u32(z.duration),u32(z.size),u32(z.flags)])},tfdt=O=>fullBox("tfdt",1,0,[u64(intoTimescale(O.currentChunk.startTimestamp,O.timescale))]),trun=O=>{let C=O.currentChunk.samples.map(be=>be.timescaleUnitsToNextSample),A=O.currentChunk.samples.map(be=>be.size),z=O.currentChunk.samples.map(fragmentSampleFlags),I=O.currentChunk.samples.map(be=>intoTimescale(be.presentationTimestamp-be.decodeTimestamp,O.timescale)),L=new Set(C),K=new Set(A),te=new Set(z),ne=new Set(I),ie=te.size===2&&z[0]!==z[1],oe=L.size>1,ue=K.size>1,de=!ie&&te.size>1,he=ne.size>1||[...ne].some(be=>be!==0),fe=0;return fe|=1,fe|=4*+ie,fe|=256*+oe,fe|=512*+ue,fe|=1024*+de,fe|=2048*+he,fullBox("trun",1,fe,[u32(O.currentChunk.samples.length),u32(O.currentChunk.offset-O.currentChunk.moofOffset||0),ie?u32(z[0]):[],O.currentChunk.samples.map((be,xe)=>[oe?u32(C[xe]):[],ue?u32(A[xe]):[],de?u32(z[xe]):[],he?i32(I[xe]):[]])])},mfra=O=>box("mfra",null,[...O.map(tfra),mfro()]),tfra=(O,C)=>fullBox("tfra",1,0,[u32(O.id),u32(63),u32(O.finalizedChunks.length),O.finalizedChunks.map(z=>[u64(intoTimescale(z.startTimestamp,O.timescale)),u64(z.moofOffset),u32(C+1),u32(1),u32(1)])]),mfro=()=>fullBox("mfro",0,0,[u32(0)]),VIDEO_CODEC_TO_BOX_NAME={avc:"avc1",hevc:"hvc1",vp9:"vp09",av1:"av01"},VIDEO_CODEC_TO_CONFIGURATION_BOX={avc:avcC,hevc:hvcC,vp9:vpcC,av1:av1C},AUDIO_CODEC_TO_BOX_NAME={aac:"mp4a",opus:"Opus"},AUDIO_CODEC_TO_CONFIGURATION_BOX={aac:esds,opus:dOps},ArrayBufferTarget=class{constructor(){this.buffer=null}},StreamTarget=class{constructor(O){if(this.options=O,typeof O!="object")throw new TypeError("StreamTarget requires an options object to be passed to its constructor.");if(O.onData){if(typeof O.onData!="function")throw new TypeError("options.onData, when provided, must be a function.");if(O.onData.length<2)throw new TypeError("options.onData, when provided, must be a function that takes in at least two arguments (data and position). Ignoring the position argument, which specifies the byte offset at which the data is to be written, can lead to broken outputs.")}if(O.chunked!==void 0&&typeof O.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(O.chunkSize!==void 0&&(!Number.isInteger(O.chunkSize)||O.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer.")}},FileSystemWritableFileStreamTarget=class{constructor(O,C){if(this.stream=O,this.options=C,!(O instanceof FileSystemWritableFileStream))throw new TypeError("FileSystemWritableFileStreamTarget requires a FileSystemWritableFileStream instance.");if(C!==void 0&&typeof C!="object")throw new TypeError("FileSystemWritableFileStreamTarget's options, when provided, must be an object.");if(C&&C.chunkSize!==void 0&&(!Number.isInteger(C.chunkSize)||C.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer")}},_helper,_helperView,Writer=class{constructor(){this.pos=0,__privateAdd(this,_helper,new Uint8Array(8)),__privateAdd(this,_helperView,new DataView(__privateGet(this,_helper).buffer)),this.offsets=new WeakMap}seek(O){this.pos=O}writeU32(O){__privateGet(this,_helperView).setUint32(0,O,!1),this.write(__privateGet(this,_helper).subarray(0,4))}writeU64(O){__privateGet(this,_helperView).setUint32(0,Math.floor(O/2**32),!1),__privateGet(this,_helperView).setUint32(4,O,!1),this.write(__privateGet(this,_helper).subarray(0,8))}writeAscii(O){for(let C=0;C<O.length;C++)__privateGet(this,_helperView).setUint8(C%8,O.charCodeAt(C)),C%8===7&&this.write(__privateGet(this,_helper));O.length%8!==0&&this.write(__privateGet(this,_helper).subarray(0,O.length%8))}writeBox(O){var C,A;if(this.offsets.set(O,this.pos),O.contents&&!O.children)this.writeBoxHeader(O,(C=O.size)!=null?C:O.contents.byteLength+8),this.write(O.contents);else{let z=this.pos;if(this.writeBoxHeader(O,0),O.contents&&this.write(O.contents),O.children)for(let K of O.children)K&&this.writeBox(K);let I=this.pos,L=(A=O.size)!=null?A:I-z;this.seek(z),this.writeBoxHeader(O,L),this.seek(I)}}writeBoxHeader(O,C){this.writeU32(O.largeSize?1:C),this.writeAscii(O.type),O.largeSize&&this.writeU64(C)}measureBoxHeader(O){return 8+(O.largeSize?8:0)}patchBox(O){let C=this.pos;this.seek(this.offsets.get(O)),this.writeBox(O),this.seek(C)}measureBox(O){if(O.contents&&!O.children)return this.measureBoxHeader(O)+O.contents.byteLength;{let C=this.measureBoxHeader(O);if(O.contents&&(C+=O.contents.byteLength),O.children)for(let A of O.children)A&&(C+=this.measureBox(A));return C}}};_helper=new WeakMap,_helperView=new WeakMap;var _target,_buffer,_bytes,_maxPos,_ensureSize,ensureSize_fn,ArrayBufferTargetWriter=class extends Writer{constructor(O){super(),__privateAdd(this,_ensureSize),__privateAdd(this,_target,void 0),__privateAdd(this,_buffer,new ArrayBuffer(2**16)),__privateAdd(this,_bytes,new Uint8Array(__privateGet(this,_buffer))),__privateAdd(this,_maxPos,0),__privateSet(this,_target,O)}write(O){__privateMethod(this,_ensureSize,ensureSize_fn).call(this,this.pos+O.byteLength),__privateGet(this,_bytes).set(O,this.pos),this.pos+=O.byteLength,__privateSet(this,_maxPos,Math.max(__privateGet(this,_maxPos),this.pos))}finalize(){__privateMethod(this,_ensureSize,ensureSize_fn).call(this,this.pos),__privateGet(this,_target).buffer=__privateGet(this,_buffer).slice(0,Math.max(__privateGet(this,_maxPos),this.pos))}};_target=new WeakMap,_buffer=new WeakMap,_bytes=new WeakMap,_maxPos=new WeakMap,_ensureSize=new WeakSet,ensureSize_fn=function(O){let C=__privateGet(this,_buffer).byteLength;for(;C<O;)C*=2;if(C===__privateGet(this,_buffer).byteLength)return;let A=new ArrayBuffer(C),z=new Uint8Array(A);z.set(__privateGet(this,_bytes),0),__privateSet(this,_buffer,A),__privateSet(this,_bytes,z)};var _target2,_sections,StreamTargetWriter=class extends Writer{constructor(O){super(),__privateAdd(this,_target2,void 0),__privateAdd(this,_sections,[]),__privateSet(this,_target2,O)}write(O){__privateGet(this,_sections).push({data:O.slice(),start:this.pos}),this.pos+=O.byteLength}flush(){var A,z;if(__privateGet(this,_sections).length===0)return;let O=[],C=[...__privateGet(this,_sections)].sort((I,L)=>I.start-L.start);O.push({start:C[0].start,size:C[0].data.byteLength});for(let I=1;I<C.length;I++){let L=O[O.length-1],K=C[I];K.start<=L.start+L.size?L.size=Math.max(L.size,K.start+K.data.byteLength-L.start):O.push({start:K.start,size:K.data.byteLength})}for(let I of O){I.data=new Uint8Array(I.size);for(let L of __privateGet(this,_sections))I.start<=L.start&&L.start<I.start+I.size&&I.data.set(L.data,L.start-I.start);(z=(A=__privateGet(this,_target2).options).onData)==null||z.call(A,I.data,I.start)}__privateGet(this,_sections).length=0}finalize(){}};_target2=new WeakMap,_sections=new WeakMap;var DEFAULT_CHUNK_SIZE=2**24,MAX_CHUNKS_AT_ONCE=2,_target3,_chunkSize,_chunks,_writeDataIntoChunks,writeDataIntoChunks_fn,_insertSectionIntoChunk,insertSectionIntoChunk_fn,_createChunk,createChunk_fn,_flushChunks,flushChunks_fn,ChunkedStreamTargetWriter=class extends Writer{constructor(O){var C,A;if(super(),__privateAdd(this,_writeDataIntoChunks),__privateAdd(this,_insertSectionIntoChunk),__privateAdd(this,_createChunk),__privateAdd(this,_flushChunks),__privateAdd(this,_target3,void 0),__privateAdd(this,_chunkSize,void 0),__privateAdd(this,_chunks,[]),__privateSet(this,_target3,O),__privateSet(this,_chunkSize,(A=(C=O.options)==null?void 0:C.chunkSize)!=null?A:DEFAULT_CHUNK_SIZE),!Number.isInteger(__privateGet(this,_chunkSize))||__privateGet(this,_chunkSize)<2**10)throw new Error("Invalid StreamTarget options: chunkSize must be an integer not smaller than 1024.")}write(O){__privateMethod(this,_writeDataIntoChunks,writeDataIntoChunks_fn).call(this,O,this.pos),__privateMethod(this,_flushChunks,flushChunks_fn).call(this),this.pos+=O.byteLength}finalize(){__privateMethod(this,_flushChunks,flushChunks_fn).call(this,!0)}};_target3=new WeakMap,_chunkSize=new WeakMap,_chunks=new WeakMap,_writeDataIntoChunks=new WeakSet,writeDataIntoChunks_fn=function(O,C){let A=__privateGet(this,_chunks).findIndex(te=>te.start<=C&&C<te.start+__privateGet(this,_chunkSize));A===-1&&(A=__privateMethod(this,_createChunk,createChunk_fn).call(this,C));let z=__privateGet(this,_chunks)[A],I=C-z.start,L=O.subarray(0,Math.min(__privateGet(this,_chunkSize)-I,O.byteLength));z.data.set(L,I);let K={start:I,end:I+L.byteLength};if(__privateMethod(this,_insertSectionIntoChunk,insertSectionIntoChunk_fn).call(this,z,K),z.written[0].start===0&&z.written[0].end===__privateGet(this,_chunkSize)&&(z.shouldFlush=!0),__privateGet(this,_chunks).length>MAX_CHUNKS_AT_ONCE){for(let te=0;te<__privateGet(this,_chunks).length-1;te++)__privateGet(this,_chunks)[te].shouldFlush=!0;__privateMethod(this,_flushChunks,flushChunks_fn).call(this)}L.byteLength<O.byteLength&&__privateMethod(this,_writeDataIntoChunks,writeDataIntoChunks_fn).call(this,O.subarray(L.byteLength),C+L.byteLength)},_insertSectionIntoChunk=new WeakSet,insertSectionIntoChunk_fn=function(O,C){let A=0,z=O.written.length-1,I=-1;for(;A<=z;){let L=Math.floor(A+(z-A+1)/2);O.written[L].start<=C.start?(A=L+1,I=L):z=L-1}for(O.written.splice(I+1,0,C),(I===-1||O.written[I].end<C.start)&&I++;I<O.written.length-1&&O.written[I].end>=O.written[I+1].start;)O.written[I].end=Math.max(O.written[I].end,O.written[I+1].end),O.written.splice(I+1,1)},_createChunk=new WeakSet,createChunk_fn=function(O){let A={start:Math.floor(O/__privateGet(this,_chunkSize))*__privateGet(this,_chunkSize),data:new Uint8Array(__privateGet(this,_chunkSize)),written:[],shouldFlush:!1};return __privateGet(this,_chunks).push(A),__privateGet(this,_chunks).sort((z,I)=>z.start-I.start),__privateGet(this,_chunks).indexOf(A)},_flushChunks=new WeakSet,flushChunks_fn=function(O=!1){var C,A;for(let z=0;z<__privateGet(this,_chunks).length;z++){let I=__privateGet(this,_chunks)[z];if(!(!I.shouldFlush&&!O)){for(let L of I.written)(A=(C=__privateGet(this,_target3).options).onData)==null||A.call(C,I.data.subarray(L.start,L.end),I.start+L.start);__privateGet(this,_chunks).splice(z--,1)}}};var FileSystemWritableFileStreamTargetWriter=class extends ChunkedStreamTargetWriter{constructor(O){var C;super(new StreamTarget({onData:(A,z)=>O.stream.write({type:"write",data:A,position:z}),chunkSize:(C=O.options)==null?void 0:C.chunkSize}))}},GLOBAL_TIMESCALE=1e3,SUPPORTED_VIDEO_CODECS2=["avc","hevc","vp9","av1"],SUPPORTED_AUDIO_CODECS2=["aac","opus"],TIMESTAMP_OFFSET=2082844800,FIRST_TIMESTAMP_BEHAVIORS=["strict","offset","cross-track-offset"],_options,_writer,_ftypSize,_mdat,_videoTrack,_audioTrack,_creationTime,_finalizedChunks,_nextFragmentNumber,_videoSampleQueue,_audioSampleQueue,_finalized,_validateOptions,validateOptions_fn,_writeHeader,writeHeader_fn,_computeMoovSizeUpperBound,computeMoovSizeUpperBound_fn,_prepareTracks,prepareTracks_fn,_generateMpeg4AudioSpecificConfig,generateMpeg4AudioSpecificConfig_fn,_createSampleForTrack,createSampleForTrack_fn,_addSampleToTrack,addSampleToTrack_fn,_validateTimestamp,validateTimestamp_fn,_finalizeCurrentChunk,finalizeCurrentChunk_fn,_finalizeFragment,finalizeFragment_fn,_maybeFlushStreamingTargetWriter,maybeFlushStreamingTargetWriter_fn,_ensureNotFinalized,ensureNotFinalized_fn,Muxer=class{constructor(O){var C;if(__privateAdd(this,_validateOptions),__privateAdd(this,_writeHeader),__privateAdd(this,_computeMoovSizeUpperBound),__privateAdd(this,_prepareTracks),__privateAdd(this,_generateMpeg4AudioSpecificConfig),__privateAdd(this,_createSampleForTrack),__privateAdd(this,_addSampleToTrack),__privateAdd(this,_validateTimestamp),__privateAdd(this,_finalizeCurrentChunk),__privateAdd(this,_finalizeFragment),__privateAdd(this,_maybeFlushStreamingTargetWriter),__privateAdd(this,_ensureNotFinalized),__privateAdd(this,_options,void 0),__privateAdd(this,_writer,void 0),__privateAdd(this,_ftypSize,void 0),__privateAdd(this,_mdat,void 0),__privateAdd(this,_videoTrack,null),__privateAdd(this,_audioTrack,null),__privateAdd(this,_creationTime,Math.floor(Date.now()/1e3)+TIMESTAMP_OFFSET),__privateAdd(this,_finalizedChunks,[]),__privateAdd(this,_nextFragmentNumber,1),__privateAdd(this,_videoSampleQueue,[]),__privateAdd(this,_audioSampleQueue,[]),__privateAdd(this,_finalized,!1),__privateMethod(this,_validateOptions,validateOptions_fn).call(this,O),O.video=deepClone(O.video),O.audio=deepClone(O.audio),O.fastStart=deepClone(O.fastStart),this.target=O.target,__privateSet(this,_options,{firstTimestampBehavior:"strict",...O}),O.target instanceof ArrayBufferTarget)__privateSet(this,_writer,new ArrayBufferTargetWriter(O.target));else if(O.target instanceof StreamTarget)__privateSet(this,_writer,(C=O.target.options)!=null&&C.chunked?new ChunkedStreamTargetWriter(O.target):new StreamTargetWriter(O.target));else if(O.target instanceof FileSystemWritableFileStreamTarget)__privateSet(this,_writer,new FileSystemWritableFileStreamTargetWriter(O.target));else throw new Error(`Invalid target: ${O.target}`);__privateMethod(this,_prepareTracks,prepareTracks_fn).call(this),__privateMethod(this,_writeHeader,writeHeader_fn).call(this)}addVideoChunk(O,C,A,z){if(!(O instanceof EncodedVideoChunk))throw new TypeError("addVideoChunk's first argument (sample) must be of type EncodedVideoChunk.");if(C&&typeof C!="object")throw new TypeError("addVideoChunk's second argument (meta), when provided, must be an object.");if(A!==void 0&&(!Number.isFinite(A)||A<0))throw new TypeError("addVideoChunk's third argument (timestamp), when provided, must be a non-negative real number.");if(z!==void 0&&!Number.isFinite(z))throw new TypeError("addVideoChunk's fourth argument (compositionTimeOffset), when provided, must be a real number.");let I=new Uint8Array(O.byteLength);O.copyTo(I),this.addVideoChunkRaw(I,O.type,A!=null?A:O.timestamp,O.duration,C,z)}addVideoChunkRaw(O,C,A,z,I,L){if(!(O instanceof Uint8Array))throw new TypeError("addVideoChunkRaw's first argument (data) must be an instance of Uint8Array.");if(C!=="key"&&C!=="delta")throw new TypeError("addVideoChunkRaw's second argument (type) must be either 'key' or 'delta'.");if(!Number.isFinite(A)||A<0)throw new TypeError("addVideoChunkRaw's third argument (timestamp) must be a non-negative real number.");if(!Number.isFinite(z)||z<0)throw new TypeError("addVideoChunkRaw's fourth argument (duration) must be a non-negative real number.");if(I&&typeof I!="object")throw new TypeError("addVideoChunkRaw's fifth argument (meta), when provided, must be an object.");if(L!==void 0&&!Number.isFinite(L))throw new TypeError("addVideoChunkRaw's sixth argument (compositionTimeOffset), when provided, must be a real number.");if(__privateMethod(this,_ensureNotFinalized,ensureNotFinalized_fn).call(this),!__privateGet(this,_options).video)throw new Error("No video track declared.");if(typeof __privateGet(this,_options).fastStart=="object"&&__privateGet(this,_videoTrack).samples.length===__privateGet(this,_options).fastStart.expectedVideoChunks)throw new Error(`Cannot add more video chunks than specified in 'fastStart' (${__privateGet(this,_options).fastStart.expectedVideoChunks}).`);let K=__privateMethod(this,_createSampleForTrack,createSampleForTrack_fn).call(this,__privateGet(this,_videoTrack),O,C,A,z,I,L);if(__privateGet(this,_options).fastStart==="fragmented"&&__privateGet(this,_audioTrack)){for(;__privateGet(this,_audioSampleQueue).length>0&&__privateGet(this,_audioSampleQueue)[0].decodeTimestamp<=K.decodeTimestamp;){let te=__privateGet(this,_audioSampleQueue).shift();__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_audioTrack),te)}K.decodeTimestamp<=__privateGet(this,_audioTrack).lastDecodeTimestamp?__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_videoTrack),K):__privateGet(this,_videoSampleQueue).push(K)}else __privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_videoTrack),K)}addAudioChunk(O,C,A){if(!(O instanceof EncodedAudioChunk))throw new TypeError("addAudioChunk's first argument (sample) must be of type EncodedAudioChunk.");if(C&&typeof C!="object")throw new TypeError("addAudioChunk's second argument (meta), when provided, must be an object.");if(A!==void 0&&(!Number.isFinite(A)||A<0))throw new TypeError("addAudioChunk's third argument (timestamp), when provided, must be a non-negative real number.");let z=new Uint8Array(O.byteLength);O.copyTo(z),this.addAudioChunkRaw(z,O.type,A!=null?A:O.timestamp,O.duration,C)}addAudioChunkRaw(O,C,A,z,I){if(!(O instanceof Uint8Array))throw new TypeError("addAudioChunkRaw's first argument (data) must be an instance of Uint8Array.");if(C!=="key"&&C!=="delta")throw new TypeError("addAudioChunkRaw's second argument (type) must be either 'key' or 'delta'.");if(!Number.isFinite(A)||A<0)throw new TypeError("addAudioChunkRaw's third argument (timestamp) must be a non-negative real number.");if(!Number.isFinite(z)||z<0)throw new TypeError("addAudioChunkRaw's fourth argument (duration) must be a non-negative real number.");if(I&&typeof I!="object")throw new TypeError("addAudioChunkRaw's fifth argument (meta), when provided, must be an object.");if(__privateMethod(this,_ensureNotFinalized,ensureNotFinalized_fn).call(this),!__privateGet(this,_options).audio)throw new Error("No audio track declared.");if(typeof __privateGet(this,_options).fastStart=="object"&&__privateGet(this,_audioTrack).samples.length===__privateGet(this,_options).fastStart.expectedAudioChunks)throw new Error(`Cannot add more audio chunks than specified in 'fastStart' (${__privateGet(this,_options).fastStart.expectedAudioChunks}).`);let L=__privateMethod(this,_createSampleForTrack,createSampleForTrack_fn).call(this,__privateGet(this,_audioTrack),O,C,A,z,I);if(__privateGet(this,_options).fastStart==="fragmented"&&__privateGet(this,_videoTrack)){for(;__privateGet(this,_videoSampleQueue).length>0&&__privateGet(this,_videoSampleQueue)[0].decodeTimestamp<=L.decodeTimestamp;){let K=__privateGet(this,_videoSampleQueue).shift();__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_videoTrack),K)}L.decodeTimestamp<=__privateGet(this,_videoTrack).lastDecodeTimestamp?__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_audioTrack),L):__privateGet(this,_audioSampleQueue).push(L)}else __privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_audioTrack),L)}finalize(){if(__privateGet(this,_finalized))throw new Error("Cannot finalize a muxer more than once.");if(__privateGet(this,_options).fastStart==="fragmented"){for(let C of __privateGet(this,_videoSampleQueue))__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_videoTrack),C);for(let C of __privateGet(this,_audioSampleQueue))__privateMethod(this,_addSampleToTrack,addSampleToTrack_fn).call(this,__privateGet(this,_audioTrack),C);__privateMethod(this,_finalizeFragment,finalizeFragment_fn).call(this,!1)}else __privateGet(this,_videoTrack)&&__privateMethod(this,_finalizeCurrentChunk,finalizeCurrentChunk_fn).call(this,__privateGet(this,_videoTrack)),__privateGet(this,_audioTrack)&&__privateMethod(this,_finalizeCurrentChunk,finalizeCurrentChunk_fn).call(this,__privateGet(this,_audioTrack));let O=[__privateGet(this,_videoTrack),__privateGet(this,_audioTrack)].filter(Boolean);if(__privateGet(this,_options).fastStart==="in-memory"){let C;for(let z=0;z<2;z++){let I=moov(O,__privateGet(this,_creationTime)),L=__privateGet(this,_writer).measureBox(I);C=__privateGet(this,_writer).measureBox(__privateGet(this,_mdat));let K=__privateGet(this,_writer).pos+L+C;for(let te of __privateGet(this,_finalizedChunks)){te.offset=K;for(let{data:ne}of te.samples)K+=ne.byteLength,C+=ne.byteLength}if(K<2**32)break;C>=2**32&&(__privateGet(this,_mdat).largeSize=!0)}let A=moov(O,__privateGet(this,_creationTime));__privateGet(this,_writer).writeBox(A),__privateGet(this,_mdat).size=C,__privateGet(this,_writer).writeBox(__privateGet(this,_mdat));for(let z of __privateGet(this,_finalizedChunks))for(let I of z.samples)__privateGet(this,_writer).write(I.data),I.data=null}else if(__privateGet(this,_options).fastStart==="fragmented"){let C=__privateGet(this,_writer).pos,A=mfra(O);__privateGet(this,_writer).writeBox(A);let z=__privateGet(this,_writer).pos-C;__privateGet(this,_writer).seek(__privateGet(this,_writer).pos-4),__privateGet(this,_writer).writeU32(z)}else{let C=__privateGet(this,_writer).offsets.get(__privateGet(this,_mdat)),A=__privateGet(this,_writer).pos-C;__privateGet(this,_mdat).size=A,__privateGet(this,_mdat).largeSize=A>=2**32,__privateGet(this,_writer).patchBox(__privateGet(this,_mdat));let z=moov(O,__privateGet(this,_creationTime));if(typeof __privateGet(this,_options).fastStart=="object"){__privateGet(this,_writer).seek(__privateGet(this,_ftypSize)),__privateGet(this,_writer).writeBox(z);let I=C-__privateGet(this,_writer).pos;__privateGet(this,_writer).writeBox(free(I))}else __privateGet(this,_writer).writeBox(z)}__privateMethod(this,_maybeFlushStreamingTargetWriter,maybeFlushStreamingTargetWriter_fn).call(this),__privateGet(this,_writer).finalize(),__privateSet(this,_finalized,!0)}};_options=new WeakMap,_writer=new WeakMap,_ftypSize=new WeakMap,_mdat=new WeakMap,_videoTrack=new WeakMap,_audioTrack=new WeakMap,_creationTime=new WeakMap,_finalizedChunks=new WeakMap,_nextFragmentNumber=new WeakMap,_videoSampleQueue=new WeakMap,_audioSampleQueue=new WeakMap,_finalized=new WeakMap,_validateOptions=new WeakSet,validateOptions_fn=function(O){if(typeof O!="object")throw new TypeError("The muxer requires an options object to be passed to its constructor.");if(O.video){if(!SUPPORTED_VIDEO_CODECS2.includes(O.video.codec))throw new TypeError(`Unsupported video codec: ${O.video.codec}`);if(!Number.isInteger(O.video.width)||O.video.width<=0)throw new TypeError(`Invalid video width: ${O.video.width}. Must be a positive integer.`);if(!Number.isInteger(O.video.height)||O.video.height<=0)throw new TypeError(`Invalid video height: ${O.video.height}. Must be a positive integer.`);const C=O.video.rotation;if(typeof C=="number"&&![0,90,180,270].includes(C))throw new TypeError(`Invalid video rotation: ${C}. Has to be 0, 90, 180 or 270.`);if(Array.isArray(C)&&(C.length!==9||C.some(A=>typeof A!="number")))throw new TypeError(`Invalid video transformation matrix: ${C.join()}`);if(O.video.frameRate!==void 0&&(!Number.isInteger(O.video.frameRate)||O.video.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${O.video.frameRate}. Must be a positive integer.`)}if(O.audio){if(!SUPPORTED_AUDIO_CODECS2.includes(O.audio.codec))throw new TypeError(`Unsupported audio codec: ${O.audio.codec}`);if(!Number.isInteger(O.audio.numberOfChannels)||O.audio.numberOfChannels<=0)throw new TypeError(`Invalid number of audio channels: ${O.audio.numberOfChannels}. Must be a positive integer.`);if(!Number.isInteger(O.audio.sampleRate)||O.audio.sampleRate<=0)throw new TypeError(`Invalid audio sample rate: ${O.audio.sampleRate}. Must be a positive integer.`)}if(O.firstTimestampBehavior&&!FIRST_TIMESTAMP_BEHAVIORS.includes(O.firstTimestampBehavior))throw new TypeError(`Invalid first timestamp behavior: ${O.firstTimestampBehavior}`);if(typeof O.fastStart=="object"){if(O.video){if(O.fastStart.expectedVideoChunks===void 0)throw new TypeError("'fastStart' is an object but is missing property 'expectedVideoChunks'.");if(!Number.isInteger(O.fastStart.expectedVideoChunks)||O.fastStart.expectedVideoChunks<0)throw new TypeError("'expectedVideoChunks' must be a non-negative integer.")}if(O.audio){if(O.fastStart.expectedAudioChunks===void 0)throw new TypeError("'fastStart' is an object but is missing property 'expectedAudioChunks'.");if(!Number.isInteger(O.fastStart.expectedAudioChunks)||O.fastStart.expectedAudioChunks<0)throw new TypeError("'expectedAudioChunks' must be a non-negative integer.")}}else if(![!1,"in-memory","fragmented"].includes(O.fastStart))throw new TypeError("'fastStart' option must be false, 'in-memory', 'fragmented' or an object.")},_writeHeader=new WeakSet,writeHeader_fn=function(){var O;if(__privateGet(this,_writer).writeBox(ftyp({holdsAvc:((O=__privateGet(this,_options).video)==null?void 0:O.codec)==="avc",fragmented:__privateGet(this,_options).fastStart==="fragmented"})),__privateSet(this,_ftypSize,__privateGet(this,_writer).pos),__privateGet(this,_options).fastStart==="in-memory")__privateSet(this,_mdat,mdat(!1));else if(__privateGet(this,_options).fastStart!=="fragmented"){if(typeof __privateGet(this,_options).fastStart=="object"){let C=__privateMethod(this,_computeMoovSizeUpperBound,computeMoovSizeUpperBound_fn).call(this);__privateGet(this,_writer).seek(__privateGet(this,_writer).pos+C)}__privateSet(this,_mdat,mdat(!0)),__privateGet(this,_writer).writeBox(__privateGet(this,_mdat))}__privateMethod(this,_maybeFlushStreamingTargetWriter,maybeFlushStreamingTargetWriter_fn).call(this)},_computeMoovSizeUpperBound=new WeakSet,computeMoovSizeUpperBound_fn=function(){if(typeof __privateGet(this,_options).fastStart!="object")return;let O=0,C=[__privateGet(this,_options).fastStart.expectedVideoChunks,__privateGet(this,_options).fastStart.expectedAudioChunks];for(let A of C)!A||(O+=(4+4)*Math.ceil(2/3*A),O+=4*A,O+=(4+4+4)*Math.ceil(2/3*A),O+=4*A,O+=8*A);return O+=4096,O},_prepareTracks=new WeakSet,prepareTracks_fn=function(){var O,C;if(__privateGet(this,_options).video&&__privateSet(this,_videoTrack,{id:1,info:{type:"video",codec:__privateGet(this,_options).video.codec,width:__privateGet(this,_options).video.width,height:__privateGet(this,_options).video.height,rotation:(O=__privateGet(this,_options).video.rotation)!=null?O:0,decoderConfig:null},timescale:(C=__privateGet(this,_options).video.frameRate)!=null?C:57600,samples:[],finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,lastDecodeTimestamp:-1,timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,compactlyCodedChunkTable:[]}),__privateGet(this,_options).audio){let A=__privateMethod(this,_generateMpeg4AudioSpecificConfig,generateMpeg4AudioSpecificConfig_fn).call(this,2,__privateGet(this,_options).audio.sampleRate,__privateGet(this,_options).audio.numberOfChannels);__privateSet(this,_audioTrack,{id:__privateGet(this,_options).video?2:1,info:{type:"audio",codec:__privateGet(this,_options).audio.codec,numberOfChannels:__privateGet(this,_options).audio.numberOfChannels,sampleRate:__privateGet(this,_options).audio.sampleRate,decoderConfig:{codec:__privateGet(this,_options).audio.codec,description:A,numberOfChannels:__privateGet(this,_options).audio.numberOfChannels,sampleRate:__privateGet(this,_options).audio.sampleRate}},timescale:__privateGet(this,_options).audio.sampleRate,samples:[],finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,lastDecodeTimestamp:-1,timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,compactlyCodedChunkTable:[]})}},_generateMpeg4AudioSpecificConfig=new WeakSet,generateMpeg4AudioSpecificConfig_fn=function(O,C,A){let I=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350].indexOf(C),L=A,K="";K+=O.toString(2).padStart(5,"0"),K+=I.toString(2).padStart(4,"0"),I===15&&(K+=C.toString(2).padStart(24,"0")),K+=L.toString(2).padStart(4,"0");let te=Math.ceil(K.length/8)*8;K=K.padEnd(te,"0");let ne=new Uint8Array(K.length/8);for(let ie=0;ie<K.length;ie+=8)ne[ie/8]=parseInt(K.slice(ie,ie+8),2);return ne},_createSampleForTrack=new WeakSet,createSampleForTrack_fn=function(O,C,A,z,I,L,K){let te=z/1e6,ne=(z-(K!=null?K:0))/1e6,ie=I/1e6,oe=__privateMethod(this,_validateTimestamp,validateTimestamp_fn).call(this,te,ne,O);return te=oe.presentationTimestamp,ne=oe.decodeTimestamp,L!=null&&L.decoderConfig&&(O.info.decoderConfig===null?O.info.decoderConfig=L.decoderConfig:Object.assign(O.info.decoderConfig,L.decoderConfig)),{presentationTimestamp:te,decodeTimestamp:ne,duration:ie,data:C,size:C.byteLength,type:A,timescaleUnitsToNextSample:intoTimescale(ie,O.timescale)}},_addSampleToTrack=new WeakSet,addSampleToTrack_fn=function(O,C){var I;__privateGet(this,_options).fastStart!=="fragmented"&&O.samples.push(C);const A=intoTimescale(C.presentationTimestamp-C.decodeTimestamp,O.timescale);if(O.lastTimescaleUnits!==null){let L=intoTimescale(C.decodeTimestamp,O.timescale,!1),K=Math.round(L-O.lastTimescaleUnits);if(O.lastTimescaleUnits+=K,O.lastSample.timescaleUnitsToNextSample=K,__privateGet(this,_options).fastStart!=="fragmented"){let te=last(O.timeToSampleTable);te.sampleCount===1?(te.sampleDelta=K,te.sampleCount++):te.sampleDelta===K?te.sampleCount++:(te.sampleCount--,O.timeToSampleTable.push({sampleCount:2,sampleDelta:K}));const ne=last(O.compositionTimeOffsetTable);ne.sampleCompositionTimeOffset===A?ne.sampleCount++:O.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:A})}}else O.lastTimescaleUnits=0,__privateGet(this,_options).fastStart!=="fragmented"&&(O.timeToSampleTable.push({sampleCount:1,sampleDelta:intoTimescale(C.duration,O.timescale)}),O.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:A}));O.lastSample=C;let z=!1;if(!O.currentChunk)z=!0;else{let L=C.presentationTimestamp-O.currentChunk.startTimestamp;if(__privateGet(this,_options).fastStart==="fragmented"){let K=(I=__privateGet(this,_videoTrack))!=null?I:__privateGet(this,_audioTrack);O===K&&C.type==="key"&&L>=1&&(z=!0,__privateMethod(this,_finalizeFragment,finalizeFragment_fn).call(this))}else z=L>=.5}z&&(O.currentChunk&&__privateMethod(this,_finalizeCurrentChunk,finalizeCurrentChunk_fn).call(this,O),O.currentChunk={startTimestamp:C.presentationTimestamp,samples:[]}),O.currentChunk.samples.push(C)},_validateTimestamp=new WeakSet,validateTimestamp_fn=function(O,C,A){var K,te,ne,ie;const z=__privateGet(this,_options).firstTimestampBehavior==="strict",I=A.lastDecodeTimestamp===-1;if(z&&I&&C!==0)throw new Error(`The first chunk for your media track must have a timestamp of 0 (received DTS=${C}).Non-zero first timestamps are often caused by directly piping frames or audio data from a MediaStreamTrack into the encoder. Their timestamps are typically relative to the age of thedocument, which is probably what you want.

If you want to offset all timestamps of a track such that the first one is zero, set firstTimestampBehavior: 'offset' in the options.
`);if(__privateGet(this,_options).firstTimestampBehavior==="offset"||__privateGet(this,_options).firstTimestampBehavior==="cross-track-offset"){A.firstDecodeTimestamp===void 0&&(A.firstDecodeTimestamp=C);let oe;__privateGet(this,_options).firstTimestampBehavior==="offset"?oe=A.firstDecodeTimestamp:oe=Math.min((te=(K=__privateGet(this,_videoTrack))==null?void 0:K.firstDecodeTimestamp)!=null?te:1/0,(ie=(ne=__privateGet(this,_audioTrack))==null?void 0:ne.firstDecodeTimestamp)!=null?ie:1/0),C-=oe,O-=oe}if(C<A.lastDecodeTimestamp)throw new Error(`Timestamps must be monotonically increasing (DTS went from ${A.lastDecodeTimestamp*1e6} to ${C*1e6}).`);return A.lastDecodeTimestamp=C,{presentationTimestamp:O,decodeTimestamp:C}},_finalizeCurrentChunk=new WeakSet,finalizeCurrentChunk_fn=function(O){if(__privateGet(this,_options).fastStart==="fragmented")throw new Error("Can't finalize individual chunks if 'fastStart' is set to 'fragmented'.");if(!!O.currentChunk){if(O.finalizedChunks.push(O.currentChunk),__privateGet(this,_finalizedChunks).push(O.currentChunk),(O.compactlyCodedChunkTable.length===0||last(O.compactlyCodedChunkTable).samplesPerChunk!==O.currentChunk.samples.length)&&O.compactlyCodedChunkTable.push({firstChunk:O.finalizedChunks.length,samplesPerChunk:O.currentChunk.samples.length}),__privateGet(this,_options).fastStart==="in-memory"){O.currentChunk.offset=0;return}O.currentChunk.offset=__privateGet(this,_writer).pos;for(let C of O.currentChunk.samples)__privateGet(this,_writer).write(C.data),C.data=null;__privateMethod(this,_maybeFlushStreamingTargetWriter,maybeFlushStreamingTargetWriter_fn).call(this)}},_finalizeFragment=new WeakSet,finalizeFragment_fn=function(O=!0){if(__privateGet(this,_options).fastStart!=="fragmented")throw new Error("Can't finalize a fragment unless 'fastStart' is set to 'fragmented'.");let C=[__privateGet(this,_videoTrack),__privateGet(this,_audioTrack)].filter(te=>te&&te.currentChunk);if(C.length===0)return;let A=__privateWrapper(this,_nextFragmentNumber)._++;if(A===1){let te=moov(C,__privateGet(this,_creationTime),!0);__privateGet(this,_writer).writeBox(te)}let z=__privateGet(this,_writer).pos,I=moof(A,C);__privateGet(this,_writer).writeBox(I);{let te=mdat(!1),ne=0;for(let oe of C)for(let ue of oe.currentChunk.samples)ne+=ue.size;let ie=__privateGet(this,_writer).measureBox(te)+ne;ie>=2**32&&(te.largeSize=!0,ie=__privateGet(this,_writer).measureBox(te)+ne),te.size=ie,__privateGet(this,_writer).writeBox(te)}for(let te of C){te.currentChunk.offset=__privateGet(this,_writer).pos,te.currentChunk.moofOffset=z;for(let ne of te.currentChunk.samples)__privateGet(this,_writer).write(ne.data),ne.data=null}let L=__privateGet(this,_writer).pos;__privateGet(this,_writer).seek(__privateGet(this,_writer).offsets.get(I));let K=moof(A,C);__privateGet(this,_writer).writeBox(K),__privateGet(this,_writer).seek(L);for(let te of C)te.finalizedChunks.push(te.currentChunk),__privateGet(this,_finalizedChunks).push(te.currentChunk),te.currentChunk=null;O&&__privateMethod(this,_maybeFlushStreamingTargetWriter,maybeFlushStreamingTargetWriter_fn).call(this)},_maybeFlushStreamingTargetWriter=new WeakSet,maybeFlushStreamingTargetWriter_fn=function(){__privateGet(this,_writer)instanceof StreamTargetWriter&&__privateGet(this,_writer).flush()},_ensureNotFinalized=new WeakSet,ensureNotFinalized_fn=function(){if(__privateGet(this,_finalized))throw new Error("Cannot add new video or audio chunks after the file has been finalized.")};const v=30;function ve(O,C=v){if(C<1)throw new Error("FPS must be greater or equal to 1");return Math.round(O*C)}function k(O,C=v){if(C<1)throw new Error("FPS must be greater or equal to 1");return Math.round(O/C*1e3)}class h{constructor(C=0){we(this,"time");this.time=Math.round(C)}get millis(){return this.time}set millis(C){this.time=Math.round(C)}get frames(){return ve(this.millis/1e3)}set frames(C){this.millis=k(C)}get seconds(){return this.millis/1e3}set seconds(C){this.millis=C*1e3}addMillis(C){return this.millis=this.millis+C,this}addFrames(C){const A=k(C);return this.millis=this.millis+A,this}add(C){return new h(C.millis+this.millis)}subtract(C){return new h(this.millis-C.millis)}static fromSeconds(C){const A=new h;return A.millis=C*1e3,A}static fromFrames(C,A){const z=new h;return z.millis=k(C,A),z}copy(){return new h(this.millis)}toJSON(){return this.millis}static fromJSON(C){return new h(C)}}function kt(O,C){return[O.slice(0,C),O.slice(C)].filter(A=>A.length>0)}function D(O,C){return C?Math.floor(Math.random()*(C-O+1)+O):O}function Dt(O){const C=new Float32Array(O.length*O.numberOfChannels);let A=0;for(let z=0;z<O.numberOfChannels;z++){const I=O.getChannelData(z);C.set(I,A),A=I.length}return C}function Ue(O,C=44100,A=2){const z=Math.floor(O.duration*C),I=new OfflineAudioContext(A,1,C).createBuffer(A,z,C);for(let L=0;L<O.numberOfChannels;L++){const K=O.getChannelData(L),te=I.getChannelData(L),ne=O.sampleRate/C;for(let ie=0;ie<te.length;ie++){const oe=ie*ne,ue=Math.floor(oe),de=Math.ceil(oe);if(de>=K.length)te[ie]=K[ue];else{const he=oe-ue;te[ie]=K[ue]*(1-he)+K[de]*he}}}return I}class tt extends Error{constructor({message:A="",i18n:z=""},...I){super(A,...I);we(this,"message");we(this,"i18n");console.error(A),this.i18n=z,this.message=A}}class et extends tt{}class Vt extends tt{}class Qt extends tt{}async function ke(O){const{fps:C,height:A,width:z,bitrate:I}=O,L=["avc1.640034","avc1.4d0034","avc1.640028","avc1.640C32","avc1.64001f","avc1.42001E"],K=["prefer-hardware","prefer-software"],te=[];for(const ie of L)for(const oe of K)te.push({codec:ie,hardwareAcceleration:oe,width:z,height:A,bitrate:I,framerate:C});const ne=[];for(const ie of te)(await VideoEncoder.isConfigSupported(ie)).supported&&ne.push(ie);return ne.sort(Te)}async function Ne(O){const{sampleRate:C,numberOfChannels:A,bitrate:z}=O,I=["mp4a.40.2","opus"],L=[];for(const K of I){const te={codec:K,numberOfChannels:A,bitrate:z,sampleRate:C};(await AudioEncoder.isConfigSupported(te)).supported&&L.push(te)}return L}async function Kt(O){const C=await Ne(O.audio),A=await ke(O.video);if(!C.length||!A.length)throw new Qt({message:"Encoder can't be configured with any of the tested profiles",i18n:"codecsNotSupported"});return[A[0],C[0]]}function Te(O,C){var I,L;const A=(I=O.hardwareAcceleration)!=null?I:"",z=(L=C.hardwareAcceleration)!=null?L:"";return A<z?-1:A>z?1:0}async function $t(O,C="untitled"){const A=document.createElement("a");if(document.head.appendChild(A),A.download=C,typeof O=="string"&&O.startsWith("data:image/svg+xml;base64,")){const z=O.split(",")[1],I=atob(z),L=new Array(I.length);for(let ne=0;ne<I.length;ne++)L[ne]=I.charCodeAt(ne);const K=new Uint8Array(L),te=new Blob([K],{type:"image/svg+xml"});A.href=URL.createObjectURL(te),A.download=C.split(".")[0]+".svg"}else typeof O=="string"?A.href=O:A.href=URL.createObjectURL(O);A.click(),A.remove()}function Tt(O){return`${O.hours.toString().padStart(2,"0")}:${O.minutes.toString().padStart(2,"0")}:${O.seconds.toString().padStart(2,"0")},`+O.milliseconds.toString().padStart(3,"0")}function Et(O){const C=new Date(1970,0,1);return C.setSeconds(O),C.setMilliseconds(Math.round(O%1*1e3)),{hours:C.getHours(),minutes:C.getMinutes(),seconds:C.getSeconds(),milliseconds:C.getMilliseconds()}}class j{constructor(C){we(this,"words",[]);C&&(this.words=C)}get duration(){return this.stop.subtract(this.start)}get text(){return this.words.map(({text:C})=>C).join(" ")}get start(){var C,A;return(A=(C=this.words.at(0))==null?void 0:C.start)!=null?A:new h}get stop(){var C,A;return(A=(C=this.words.at(-1))==null?void 0:C.stop)!=null?A:new h}}var mt=(O=>(O.en="en",O.de="de",O))(mt||{});class Ot{constructor(C,A,z,I){we(this,"text");we(this,"start");we(this,"stop");we(this,"confidence");this.text=C,this.start=new h(A),this.stop=new h(z),this.confidence=I}get duration(){return this.stop.subtract(this.start)}}class U{constructor(C=[],A=mt.en){we(this,"id",crypto.randomUUID());we(this,"language",mt.en);we(this,"groups",[]);this.groups=C,this.language=A}get text(){return this.groups.map(({text:C})=>C).join(" ")}*iter({count:C,duration:A,length:z}){for(const I of this.groups){let L;for(const[K,te]of I.words.entries())L&&(C&&L.words.length>=D(...C)?(yield L,L=void 0):A&&(L==null?void 0:L.duration.seconds)>=D(...A)?(yield L,L=void 0):z&&L.text.length>=D(...z)&&(yield L,L=void 0)),L?L.words.push(te):L=new j([te]),K==I.words.length-1&&(yield L)}}optimize(){const C=this.groups.flatMap(A=>A.words);for(let A=0;A<C.length-1;A++){const z=C[A],I=C[A+1];I.start.millis-z.stop.millis<0?I.start.millis=z.stop.millis+1:z.stop.millis=I.start.millis-1}return this}toSRT(C){let A=1,z="";for(const I of this.iter(C)){const L=Et(I.start.seconds),K=Et(I.stop.seconds);z+=`${A}
`+Tt(L)+" --> "+Tt(K)+`
${I.text}

`,A+=1}return{text:z,blob:new Blob([z],{type:"text/plain;charset=utf8"})}}toJSON(){return this.groups.map(C=>C.words.map(A=>({token:A.text,start:A.start.millis,stop:A.stop.millis})))}slice(C,A=!0){let z=0;const I=[];for(const L of this.groups)for(const K of L.words)if(I.length==0&&A&&(z=K.start.millis),I.push(new Ot(K.text,K.start.millis-z,K.stop.millis-z)),I.length==C)return new U([new j(I)]);return new U([new j(I)])}static fromJSON(C){const A=new U;for(const z of C){const I=new j;for(const L of z)I.words.push(new Ot(L.token,L.start,L.stop));A.groups.push(I)}return A}static async from(C,A){const z=await fetch(C,A);if(!z.ok)throw new et({i18n:"unexpectedIOError",message:"An unexpected error occurred while fetching the file"});return U.fromJSON(await z.json())}}function Q(O,C,A){return O+(C-O)*A}function Ee(O,C,A){const z=Number.parseInt(O.slice(1),16),I=Number.parseInt(C.slice(1),16),L=z>>16&255,K=z>>8&255,te=z&255,ne=I>>16&255,ie=I>>8&255,oe=I&255,ue=Math.round(Q(L,ne,A)),de=Math.round(Q(K,ie,A)),he=Math.round(Q(te,oe,A));return`#${((1<<24)+(ue<<16)+(de<<8)+he).toString(16).slice(1)}`}const Oe={linear:O=>O,easeIn:O=>O*O,easeOut:O=>O*(2-O),easeInOut:O=>O<.5?2*O*O:-1+(4-2*O)*O};class b{constructor(C,A,z={}){we(this,"input");we(this,"output");we(this,"options");if(C.length!==A.length)throw new Error("inputRange and outputRange must have the same length");this.input=C.map(I=>k(I)),this.output=A,this.options={extrapolate:"clamp",easing:"linear",type:"number",...JSON.parse(JSON.stringify(z))}}normalize(C){const{input:A}=this;if(C<A[0])return this.options.extrapolate==="clamp"?{t:0,segment:0}:{t:(C-A[0])/(A[1]-A[0]),segment:0};if(C>A[A.length-1])return this.options.extrapolate==="clamp"?{t:1,segment:A.length-2}:{t:(C-A[A.length-2])/(A[A.length-1]-A[A.length-2]),segment:A.length-2};for(let z=0;z<A.length-1;z++){const I=A[z],L=A[z+1];if(C>=I&&C<=L)return{t:(C-I)/(L-I),segment:z}}return{t:0,segment:0}}interpolate(C,A){const z=this.output[A],I=this.output[A+1],L=Oe[this.options.easing](C);if(typeof z=="number"&&typeof I=="number")return Q(z,I,L);if(typeof z=="string"&&typeof I=="string")return Ee(z,I,L);if(this.output.length==1)return this.output[0];throw new Error("Unsupported output range types")}value(C){const{t:A,segment:z}=this.normalize(typeof C=="number"?C:C.millis);return this.interpolate(A,z)}push(C,A){return this.input.push(k(C)),this.output.push(A),this}toJSON(){return this}static fromJSON(C){const A=new b([],[]);return Object.assign(A,C),A}}class w{constructor(){we(this,"id",crypto.randomUUID())}toJSON(){const C={};return(this.constructor.__serializableProperties||[]).forEach(({propertyKey:A,serializer:z})=>{const I=this[A];z&&I instanceof z?C[A]=I.toJSON():C[A]=I}),C}static fromJSON(C){const A=new this;return(this.__serializableProperties||[]).forEach(({propertyKey:z,serializer:I})=>{if(C.hasOwnProperty(z))if(I){const L=I.fromJSON(C[z]);A[z]=L}else A[z]=C[z]}),A}}function l(O){return function(C,A){C.constructor.__serializableProperties||(C.constructor.__serializableProperties=[]),C.constructor.__serializableProperties.push({propertyKey:A,serializer:O})}}function S(O){return class extends O{constructor(){super(...arguments);we(this,"_handlers",{})}on(A,z){if(typeof z!="function")throw new Error("The callback of an event listener needs to be a function.");const I=crypto.randomUUID();return this._handlers[A]?this._handlers[A][I]=z:this._handlers[A]={[I]:z},I}off(A,...z){if(A){for(const I of Object.values(this._handlers))A in I&&delete I[A];for(const I of z)this.off(I)}}trigger(A,z){var L,K,te,ne;const I=new CustomEvent(A,{detail:z});Object.defineProperty(I,"currentTarget",{writable:!1,value:this});for(const ie in(L=this._handlers[A])!=null?L:{})(K=this._handlers[A])==null||K[ie](I);for(const ie in(te=this._handlers["*"])!=null?te:{})(ne=this._handlers["*"])==null||ne[ie](I)}bubble(A,z){z.on(A,I=>this.trigger(A,I))}resolve(A){return(z,I)=>{this.on("error",I),this.on(A,z)}}}}function Rt(O,C,A=0){if(!(O instanceof Container||O instanceof Filter||A==3))for(const z in O){const I=O[z];z&&(I instanceof b&&(O[z]=I.value(C)),I!=null&&typeof I=="object"&&Object.keys(I).length&&Rt(I,C,A+1))}}var Je=Object.defineProperty,it=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Je(C,A,I),I};const Y=class Bn extends S(w){constructor(A={}){super();we(this,"_name");we(this,"_start",new h);we(this,"_stop",h.fromSeconds(16));we(this,"type","base");we(this,"source");we(this,"view",new Container);we(this,"createdAt",new Date);we(this,"disabled",!1);we(this,"state","IDLE");we(this,"track");Object.assign(this,A)}get name(){var A,z;return(z=this._name)!=null?z:(A=this.source)==null?void 0:A.name}set name(A){this._name=A}get start(){return this._start}get stop(){return this._stop}async connect(A){this.state="ATTACHED",this.track=A,this.trigger("attach",void 0)}set start(A){typeof A=="number"?this.start.frames=A:this._start=A,this.start.millis>=this.stop.millis&&(this.stop.millis=this.start.millis+1),this.trigger("frame",this.start.frames)}set stop(A){typeof A=="number"?this.stop.frames=A:this._stop=A,this.stop.millis<=this.start.millis&&(this.start.millis=this.stop.millis-1),this.trigger("frame",this.stop.frames)}offsetBy(A){return typeof A=="number"?(this.start.addFrames(A),this.stop.addFrames(A),this.trigger("offsetBy",h.fromFrames(A))):(this.start.addMillis(A.millis),this.stop.addMillis(A.millis),this.trigger("offsetBy",A)),this.trigger("frame",void 0),this}async init(){}enter(){}update(A){}exit(){}detach(){var A;return(A=this.track)==null||A.remove(this),this}async split(A){var I,L;if(A||(A=(L=(I=this.track)==null?void 0:I.composition)==null?void 0:L.frame),typeof A=="number"&&(A=h.fromFrames(A)),!A||A.millis<=this.start.millis||A.millis>=this.stop.millis)throw new Error("Cannot split clip at the specified time");if(!this.track)throw new Error("Split must be connected to a track");const z=this.copy();return this.stop=A.copy(),z.start=A.copy().addMillis(1),Rt(z,z.start.subtract(this.start)),await this.track.add(z),z}copy(){return Bn.fromJSON(JSON.parse(JSON.stringify(this)))}set(A){return A&&Object.assign(this,A),this.trigger("update",void 0),this}};it([l()],Y.prototype,"_name"),it([l(h)],Y.prototype,"_start"),it([l(h)],Y.prototype,"_stop"),it([l()],Y.prototype,"disabled");let N=Y;var Le=Object.defineProperty,F=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Le(C,A,I),I};class V extends S(w){constructor(){super(...arguments);we(this,"state","IDLE");we(this,"objectURL");we(this,"duration",h.fromSeconds(16));we(this,"added",!1);we(this,"type","base");we(this,"name","");we(this,"mimeType");we(this,"externalURL");we(this,"external",!1);we(this,"file")}async createObjectURL(){return this.objectURL?this.objectURL:(this.objectURL=URL.createObjectURL(await this.getFile()),this.objectURL)}async getFile(){if(!this.file&&this.state=="LOADING"&&await new Promise(this.resolve("load")),!this.file)throw new Vt({i18n:"fileNotAccessible",message:"The desired file cannot be accessed"});return this.file}async from(A,z){var I;try{if(this.state="LOADING",A instanceof File)this.name=A.name,this.mimeType=q(A.type),this.external=!1,this.file=A;else{const L=await fetch(A,z);if(!(L!=null&&L.ok))throw new et({i18n:"unexpectedIOError",message:"An unexpected error occurred while fetching the file"});const K=await L.blob();this.name=(I=A.toString().split("/").at(-1))!=null?I:"",this.external=!0,this.file=new File([K],this.name,{type:K.type}),this.externalURL=A,this.mimeType=q(K.type)}this.state="READY",this.trigger("load",void 0)}catch(L){throw this.state=="ERROR",this.trigger("error",new Error(String(L))),L}return this}async arrayBuffer(){return await(await this.getFile()).arrayBuffer()}async remove(){this.state="IDLE",this.objectURL&&(URL.revokeObjectURL(this.objectURL),this.objectURL=void 0),delete this.file}async export(){const A=await this.getFile();$t(A,this.name)}async thumbnail(){return new HTMLElement}static async from(A,z,I=new this){return I.from(A,z)}}F([l()],V.prototype,"objectURL"),F([l()],V.prototype,"duration"),F([l()],V.prototype,"type"),F([l()],V.prototype,"name"),F([l()],V.prototype,"mimeType"),F([l()],V.prototype,"externalURL"),F([l()],V.prototype,"external");const Ct="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E";function Ye(O){const C=new TextEncoder().encode(O);let A="";const z=C.byteLength;for(let I=0;I<z;I++)A+=String.fromCharCode(C[I]);return btoa(A)}function Jt(O){if(!O)return Ct;const C=O.body.scrollWidth,A=O.body.scrollHeight,z=O.cloneNode(!0),I=z.getElementsByTagName("style").item(0),L=z.getElementsByTagName("body").item(0);if(L==null||L.setAttribute("xmlns","http://www.w3.org/1999/xhtml"),!L)return Ct;const K=new XMLSerializer,te=I?K.serializeToString(I):"",ne=K.serializeToString(L),ie=`
  <svg xmlns="http://www.w3.org/2000/svg" width="${C}" height="${A}">
		body { padding: 0; }
    ${te}
    <foreignObject width="100%" height="100%">
      ${ne}
    </foreignObject>
  </svg>`;return"data:image/svg+xml;base64,"+Ye(ie)}class gt extends V{constructor(){super();we(this,"type","base");we(this,"iframe");const A=document.createElement("iframe");A.style.position="absolute",A.style.width="0",A.style.height="0",A.style.border="0",A.style.visibility="hidden",document.body.appendChild(A),this.iframe=A}get document(){var A;return(A=this.iframe.contentWindow)==null?void 0:A.document}async createObjectURL(){return!this.file&&this.state=="LOADING"&&await new Promise(this.resolve("load")),this.objectURL?this.objectURL:(this.objectURL=Jt(this.document),this.objectURL)}async from(A,z){var I;try{if(this.state="LOADING",A instanceof File)this.name=A.name,this.mimeType=q(A.type),this.external=!1,this.file=A;else{const L=await fetch(A,z);if(!(L!=null&&L.ok))throw new et({i18n:"unexpectedIOError",message:"An unexpected error occurred while fetching the file"});const K=await L.blob();this.name=(I=A.toString().split("/").at(-1))!=null?I:"",this.external=!0,this.file=new File([K],this.name,{type:K.type}),this.externalURL=A,this.mimeType=q(K.type)}this.iframe.setAttribute("src",URL.createObjectURL(this.file)),await new Promise((L,K)=>{this.iframe.onload=()=>L(),this.iframe.onerror=te=>K(te)}),this.state="READY",this.trigger("load",void 0)}catch(L){throw this.state="ERROR",this.trigger("error",new Error(String(L))),L}return this}update(){this.objectURL&&(this.objectURL=Jt(this.document))}async thumbnail(){const A=new Image;return A.src=await this.createObjectURL(),A.className="object-contain w-full aspect-video h-auto",A}}class J extends V{constructor(){super(...arguments);we(this,"type","base");we(this,"audioBuffer")}async decode(A=2,z=44100){const I=await this.arrayBuffer(),L=new OfflineAudioContext(A,1,z);return this.audioBuffer=await L.decodeAudioData(I),this.duration.seconds=this.audioBuffer.duration,this.trigger("update",void 0),this.audioBuffer}async samples(A=60,z=50,I=0){var ue;const L=(ue=this.audioBuffer)!=null?ue:await this.decode(1,16e3),K=Math.round(L.sampleRate/z),te=L.sampleRate*L.duration-K,ne=Math.ceil(te/A),ie=L.getChannelData(0),oe=[];for(let de=0;de<te;de+=ne){let he=0;for(let fe=de;fe<de+K;fe++)he+=Math.abs(ie[de]);oe.push(Math.log1p(he/K*100))}return oe.map(de=>Math.round(de/Math.max(...oe)*(100-I))+I)}async thumbnail(...A){const z=await this.samples(...A),I=document.createElement("div");I.className="flex flex-row absolute space-between inset-0 audio-samples";for(const L of z){const K=document.createElement("div");K.className="audio-sample-item",K.style.height=`${L}%`,I.appendChild(K)}return I}}class yt extends V{constructor(){super(...arguments);we(this,"type","base")}async thumbnail(){const A=new Image;return A.src=await this.createObjectURL(),A.className="object-cover w-full aspect-video h-auto",A}}class wt extends J{constructor(){super(...arguments);we(this,"type","video")}async thumbnail(){const A=document.createElement("video");return A.className="object-cover w-full aspect-video h-auto",A.controls=!1,A.addEventListener("loadedmetadata",()=>{this.duration.seconds=A.duration,this.trigger("update",void 0)}),A.addEventListener("mousemove",z=>{var ne;const I=z.currentTarget,L=I==null?void 0:I.getBoundingClientRect(),K=z.clientX-((ne=L==null?void 0:L.left)!=null?ne:0),te=I==null?void 0:I.duration;te&&L&&L.width>0&&(I.currentTime=Math.round(te*(K/L.width)))}),A.src=await this.createObjectURL(),A}}class Be{static fromJSON(C){return[new h(C[0]),new h(C[1])]}}var _e=Object.defineProperty,Me=Object.getOwnPropertyDescriptor,T=(O,C,A,z)=>{for(var I=z>1?void 0:z?Me(C,A):C,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=(z?K(C,A,I):K(I))||I);return z&&I&&_e(C,A,I),I};const G=class kn extends N{constructor(A={}){super();we(this,"source",new J);we(this,"_offset",new h);we(this,"playing",!1);we(this,"duration",new h);we(this,"range",[new h,this.duration]);we(this,"transcript");Object.assign(this,A)}get start(){return this.range[0].add(this.offset)}get stop(){return this.range[1].add(this.offset)}set start(A){typeof A=="number"&&(A=h.fromFrames(A));const z=A.subtract(this.offset);z.millis>=0&&z.millis<this.range[1].millis?this.range[0].millis=z.millis:z.millis<0?this.range[0].millis=0:this.range[0].millis=this.range[1].millis-1,this.trigger("frame",void 0)}set stop(A){typeof A=="number"&&(A=h.fromFrames(A));const z=A.subtract(this.offset);z.millis>this.range[0].millis&&z.millis<=this.duration.millis?this.range[1]=z:z.millis>this.duration.millis?this.range[1]=this.duration:this.range[1].millis=this.range[0].millis+1,this.trigger("frame",void 0)}get offset(){return this._offset}set offset(A){typeof A=="number"?this._offset.frames=A:this._offset=A,this.trigger("frame",this.offset.frames)}offsetBy(A){return typeof A=="number"?(this.offset.addFrames(A),this.trigger("offsetBy",h.fromFrames(A))):(this.offset.addMillis(A.millis),this.trigger("offsetBy",A)),this.trigger("frame",void 0),this}get muted(){var A,z;return(z=(A=this.element)==null?void 0:A.muted)!=null?z:!1}set muted(A){this.element&&(this.element.muted=A)}seek(A){return new Promise((z,I)=>{if(!this.element)return I(new Error("Can't seek on element becaused it's not defined"));(A.millis<this.start.millis||A.millis>this.stop.millis)&&(A=this.start),this.element.onerror=()=>{var L;return I((L=this.element)==null?void 0:L.error)},this.element.pause(),this.element.currentTime=A.subtract(this.offset).seconds,this.element.onseeked=()=>z()})}subclip(A,z){if(A||(A=this.range[0]),z||(z=this.range[1]),typeof A=="number"&&(A=h.fromFrames(A)),typeof z=="number"&&(z=h.fromFrames(z)),A.millis>=z.millis)throw new Error("Start can't lower than or equal the stop");return A.millis<0&&(this.range[0].millis=0,A=this.range[0]),z.millis>this.duration.millis&&this.duration.millis&&(z=this.duration),this.range=[A,z],this.trigger("frame",void 0),this}get volume(){var A,z;return(z=(A=this.element)==null?void 0:A.volume)!=null?z:1}set volume(A){this.element&&(this.element.volume=A)}copy(){return kn.fromJSON(JSON.parse(JSON.stringify(this)))}async split(A){var I,L;if(A||(A=(L=(I=this.track)==null?void 0:I.composition)==null?void 0:L.frame),typeof A=="number"&&(A=h.fromFrames(A)),!A||A.millis<=this.start.millis||A.millis>=this.stop.millis)throw new Error("Cannot split clip at the specified time");if(!this.track)throw new Error("Split must be connected to a track");A=A.subtract(this.offset);const z=this.copy();return this.range[1]=A.copy(),z.range[0]=A.copy().addMillis(1),Rt(z,z.start.subtract(this.start)),await this.track.add(z),z}async addCaptions(A){var z;if(!((z=this.track)!=null&&z.composition))throw new Vt({i18n:"compositionNotDefined",message:"Captions can only be generated after the clip has been added to the composition"});return await this.track.composition.createTrack("caption").from(this).generate(A)}set(A){return super.set(A)}async generateCaptions(A){return this.addCaptions(A)}};T([l(h)],G.prototype,"_offset",2),T([l(h)],G.prototype,"duration",2),T([l(Be)],G.prototype,"range",2),T([l(U)],G.prototype,"transcript",2),T([l()],G.prototype,"muted",1),T([l()],G.prototype,"volume",1);let st=G;class P{static fromJSON(C){return typeof C=="object"?b.fromJSON(C):C}}class ut{static fromJSON(C){return typeof C.x=="object"&&(C.x=b.fromJSON(C.x)),typeof C.y=="object"&&(C.y=b.fromJSON(C.y)),C}}let Ie=class{constructor(O){we(this,"target");we(this,"animation");this.target=O}init(O,C,A=0,z){if(!(O in this.target))throw new Error(`Property [${String(O)}] cannot be assigned`);const I=[A],L=[C];typeof this.target[O]==typeof C&&A!=0&&(I.unshift(0),L.unshift(this.target[O])),this.target[O]=this.animation=new b(I,L,{easing:z})}};function ze(O){const C=new Proxy(O,{get(A,z){return z=="to"?(I,L)=>{if(!A.animation)throw new Error("Cannot use 'to() before selecting a property");const K=new h(A.animation.input.at(-1)).frames+L;return A.animation.push(K,I),C}:(I,L,K)=>(A.init(z,I,L,K),C)}});return C}class je extends Ie{}var Pe=Object.defineProperty,He=Object.getOwnPropertyDescriptor,W=(O,C,A,z)=>{for(var I=z>1?void 0:z?He(C,A):C,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=(z?K(C,A,I):K(I))||I);return z&&I&&Pe(C,A,I),I};function rt(O){class C extends O{constructor(){super(...arguments);we(this,"filters");we(this,"_height");we(this,"_width");we(this,"_position",{x:this.view.position.x,y:this.view.position.y});we(this,"_scale");we(this,"rotation",this.view.angle);we(this,"alpha",1);we(this,"translate",{x:0,y:0})}get position(){return this._position}set position(I){typeof I=="string"?(this._position={x:"50%",y:"50%"},this.anchor={x:.5,y:.5}):this._position=I}get scale(){var I;return(I=this._scale)!=null?I:{x:this.view.scale.x,y:this.view.scale.y}}set scale(I){typeof I=="number"||I instanceof b||typeof I=="function"?this._scale={x:I,y:I}:this._scale=I}get x(){return this._position.x}set x(I){this._position.x=I}get y(){return this._position.y}set y(I){this._position.y=I}get translateX(){return this.translate.x}set translateX(I){this.translate.x=I}get translateY(){return this.translate.y}set translateY(I){this.translate.y=I}get height(){var I;return(I=this._height)!=null?I:this.view.height}set height(I){this._height=I}get width(){var I;return(I=this._width)!=null?I:this.view.width}set width(I){this._width=I}get anchor(){return this.view.children[0]instanceof Sprite?{x:this.view.children[0].anchor.x,y:this.view.children[0].anchor.y}:{x:0,y:0}}set anchor(I){const L=typeof I=="number"?{x:I,y:I}:I;for(const K of this.view.children)K instanceof Sprite&&K.anchor.set(L.x,L.y)}enter(){this.filters&&!this.view.filters&&(this.view.filters=this.filters)}exit(){this.filters&&this.view.filters&&(this.view.filters=null)}animate(){return ze(new je(this))}}return W([l(P)],C.prototype,"_height",2),W([l(P)],C.prototype,"_width",2),W([l(ut)],C.prototype,"_position",2),W([l(ut)],C.prototype,"_scale",2),W([l(P)],C.prototype,"rotation",2),W([l(P)],C.prototype,"alpha",2),W([l(ut)],C.prototype,"translate",2),W([l()],C.prototype,"anchor",1),C}function nt(O,C,A){const z=A.value;return A.value=function(...I){var ue,de,he,fe,be,xe;const L=I[0].subtract(this.start),K={width:(he=(de=(ue=this.track)==null?void 0:ue.composition)==null?void 0:de.width)!=null?he:1920,height:(xe=(be=(fe=this.track)==null?void 0:fe.composition)==null?void 0:be.height)!=null?xe:1080};let te;typeof this.translate.x=="number"?te=this.translate.x:typeof this.translate.x=="function"?te=this.translate.x.bind(this)(L):te=this.translate.x.value(L);let ne;typeof this.translate.y=="number"?ne=this.translate.y:typeof this.translate.y=="function"?ne=this.translate.y.bind(this)(L):ne=this.translate.y.value(L);let ie;typeof this._position.x=="number"?ie=this._position.x:typeof this._position.x=="string"?ie=Number.parseFloat(this._position.x)*K.width/100:typeof this._position.x=="function"?ie=this._position.x.bind(this)(L):ie=this._position.x.value(L);let oe;if(typeof this._position.y=="number"?oe=this._position.y:typeof this._position.y=="string"?oe=Number.parseFloat(this._position.y)*K.height/100:typeof this._position.y=="function"?oe=this._position.y.bind(this)(L):oe=this._position.y.value(L),this.view.position.set(ie+te,oe+ne),typeof this._height=="string"?this.view.height=Math.round(Number.parseFloat(this._height)*K.height/100):typeof this._height=="object"?this.view.height=this._height.value(L):typeof this._height=="function"?this.view.height=this._height.bind(this)(L):this._height&&(this.view.height=this._height),this._height&&!this._width&&this.view.scale.set(this.view.scale.y),typeof this._width=="string"?this.view.width=Math.round(Number.parseFloat(this._width)*K.width/100):typeof this._width=="object"?this.view.width=this._width.value(L):typeof this._width=="function"?this.view.width=this._width.bind(this)(L):this._width&&(this.view.width=this._width),this._width&&!this._height&&this.view.scale.set(this.view.scale.x),this._scale){let Se;typeof this._scale.x=="number"?Se=this._scale.x:typeof this._scale.x=="function"?Se=this._scale.x.bind(this)(L):Se=this._scale.x.value(L);let Fe;typeof this._scale.y=="number"?Fe=this._scale.y:typeof this._scale.y=="function"?Fe=this._scale.y.bind(this)(L):Fe=this._scale.y.value(L),(this._width||this._height)&&(Se*=this.view.scale._x,Fe*=this.view.scale._y),this.view.scale.set(Se,Fe)}return typeof this.rotation=="number"?this.view.angle=this.rotation:typeof this.rotation=="function"?this.view.angle=this.rotation.bind(this)(L):this.view.angle=this.rotation.value(L),typeof this.alpha=="number"?this.view.alpha=this.alpha:typeof this.alpha=="function"?this.view.alpha=this.alpha.bind(this)(L):this.view.alpha=this.alpha.value(L),z.apply(this,I)},A}var Ae=Object.defineProperty,De=Object.getOwnPropertyDescriptor,Qe=(O,C,A,z)=>{for(var I=De(C,A),L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Ae(C,A,I),I};const ee=class In extends rt(N){constructor(A,z={}){super();we(this,"type","image");we(this,"element",new Image);we(this,"source",new yt);we(this,"sprite",new Sprite);this.view.addChild(this.sprite),A instanceof yt&&(this.source=A),A instanceof File&&this.source.from(A),Object.assign(this,z)}async init(){this.element.setAttribute("src",await this.source.createObjectURL()),await new Promise((A,z)=>{this.element.onload=()=>{this.sprite.texture=Texture.from(this.element),this.state="READY",A()},this.element.onerror=I=>{console.error(I),this.state="ERROR",z(new Error("An error occurred while processing the input medium."))}})}update(A){}copy(){const A=In.fromJSON(JSON.parse(JSON.stringify(this)));return A.filters=this.filters,A.source=this.source,A}};Qe([nt],ee.prototype,"update");const H={"The Bold Font":{weights:["500"],url:"https://diffusion-studio-public.s3.eu-central-1.amazonaws.com/fonts/the-bold-font.ttf"},"Komika Axis":{weights:["400"],url:"https://diffusion-studio-public.s3.eu-central-1.amazonaws.com/fonts/komika-axis.ttf"},Geologica:{weights:["100","200","300","400","500","600","700","800","900"],url:"https://fonts.gstatic.com/s/geologica/v1/oY1l8evIr7j9P3TN9YwNAdyjzUyDKkKdAGOJh1UlCDUIhAIdhCZOn1fLsig7jfvCCPHZckUWE1lELWNN-w.woff2"},Figtree:{weights:["300","400","500","600","700","800","900"],url:"https://fonts.gstatic.com/s/figtree/v5/_Xms-HUzqDCFdgfMm4S9DaRvzig.woff2"},Urbanist:{weights:["100","200","300","400","500","600","700","800","900"],url:"https://fonts.gstatic.com/s/urbanist/v15/L0x-DF02iFML4hGCyMqlbS1miXK2.woff2"},Montserrat:{weights:["100","200","300","400","500","600","700","800","900"],url:"https://fonts.gstatic.com/s/montserrat/v26/JTUSjIg1_i6t8kCHKm459WlhyyTh89Y.woff2"},Bangers:{weights:["400"],url:"https://fonts.gstatic.com/s/bangers/v20/FeVQS0BTqb0h60ACH55Q2J5hm24.woff2"},Chewy:{weights:["400"],url:"https://fonts.gstatic.com/s/chewy/v18/uK_94ruUb-k-wn52KjI9OPec.woff2"},"Source Code Pro":{weights:["200","300","400","500","600","700","800","900"],url:"https://fonts.gstatic.com/s/sourcecodepro/v22/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevWnsUnxg.woff2"}};var Ke=Object.defineProperty,ot=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Ke(C,A,I),I};const B=class Vr extends S(w){constructor(A){var z;super();we(this,"loaded",!1);we(this,"family");we(this,"weight");we(this,"source");we(this,"style");A!=null&&A.source.startsWith("https://")&&(A.source=`url(${A.source})`),this.family=(z=A==null?void 0:A.family)!=null?z:"Arial",this.source=A==null?void 0:A.source,this.style=A==null?void 0:A.style,this.weight=A==null?void 0:A.weight}get name(){var A;return this.family+" "+((A=this.style)!=null?A:this.weight)}async load(){if(this.loaded||!this.source||!this.family)return this;const A=new FontFace(this.name,this.source);return this.weight&&(A.weight=this.weight),await new Promise(z=>{A.load().then(I=>{document.fonts.add(I),z(null)})}),this.loaded=!0,this.trigger("load",void 0),this}copy(){const A=Vr.fromJSON(JSON.parse(JSON.stringify(this)));return A.loaded=this.loaded,A}static async localFonts(){const A={};"queryLocalFonts"in window||Object.assign(window,{queryLocalFonts:()=>[]});for(const z of await window.queryLocalFonts()){if(z.family in A){A[z.family].push(z);continue}A[z.family]=[z]}return Object.keys(A).map(z=>({family:z,variants:A[z].map(I=>({family:z,style:I.style,source:`local('${I.fullName}'), local('${I.postscriptName}')`}))}))}static webFonts(){return Object.keys(H).map(A=>({family:A,variants:H[A].weights.map(z=>({family:A,source:`url(${H[A].url})`,weight:z}))}))}static fromFamily({family:A,weight:z}){return new Vr({family:A,source:`url(${H[A].url})`,weight:z})}};ot([l()],B.prototype,"family"),ot([l()],B.prototype,"weight"),ot([l()],B.prototype,"source"),ot([l()],B.prototype,"style");let R=B;const Z=4,se={center:.5,justify:.5,left:0,right:1},re={alphabetic:0,top:0,middle:.5,hanging:1,bottom:1,ideographic:1};var $e=Object.defineProperty,qe=Object.getOwnPropertyDescriptor,y=(O,C,A,z)=>{for(var I=qe(C,A),L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&$e(C,A,I),I};const g=class Un extends rt(N){constructor(A){super();we(this,"type","text");we(this,"_text","");we(this,"_textCase");we(this,"_anchor",{x:0,y:0});we(this,"_font",new R);we(this,"style",new TextStyle({fill:"#FFFFFF",fontFamily:this._font.family,fontSize:16}));this.style.padding=20,typeof A=="string"?(this.text=A,this.reflectUpdate()):A&&(Object.assign(this,A),this.reflectUpdate()),this.on("update",this.reflectUpdate.bind(this))}get text(){return this._text}set text(A){if(this._text=A,!this.view.children.length){const z=new Text({text:this.transformedText,style:this.style,resolution:Z,scale:Z});this.view.addChild(z)}this.view.children[0]instanceof Text&&this.transformedText&&(this.view.children[0].text=this.transformedText)}get name(){return this._text}get font(){return this._font}set font(A){if(this._font=A,A.loaded){this.style.fontFamily=A.name;return}this._font.load().then(()=>{this.style.fontFamily=A.name,this.trigger("update",void 0)})}get maxWidth(){if(this.style.wordWrap)return this.style.wordWrapWidth*Z}set maxWidth(A){A?(this.style.wordWrap=!0,this.style.wordWrapWidth=A/Z):this.style.wordWrap=!1}get textAlign(){return this.style.align}set textAlign(A){this.style.align=A,this.anchor.x=se[A]}get padding(){return this.style.padding}set padding(A){this.style.padding=A}get textBaseline(){return this.style.textBaseline}set textBaseline(A){this.style.textBaseline=A,this.anchor.y=re[A]}get fillStyle(){const{fill:A}=this.style;return new Color(A.toString()).toHex().toUpperCase()}set fillStyle(A){this.style.fill=A}get anchor(){return this._anchor}set anchor(A){typeof A=="number"?this._anchor={x:A,y:A}:this._anchor=A}get stroke(){if(!this.style.stroke)return;let{color:A="#000000",alpha:z=1,width:I=3,join:L="round",miterLimit:K}=this.style.stroke;return A=new Color(A).toHex().toUpperCase(),{color:A,alpha:z,width:I,join:L,miterLimit:K}}set stroke(A){if(!A){this.style.stroke=void 0;return}const{color:z="#000000",alpha:I=1,width:L=3,join:K="round",miterLimit:te}=A;this.style.stroke={color:z,alpha:I,width:L,join:K,miterLimit:te}}get textCase(){return this._textCase}set textCase(A){this._textCase=A,this.view.children[0]instanceof Text&&this.transformedText&&(this.view.children[0].text=this.transformedText)}get shadow(){if(!this.style.dropShadow)return;const{alpha:A,angle:z,blur:I,color:L,distance:K}=this.style.dropShadow,te=new Color(L).toHex().toUpperCase();return{alpha:A,angle:z,blur:I,color:te,distance:K}}set shadow(A){A?this.style.dropShadow=A:this.style.dropShadow=!1}get fontFamily(){return Array.isArray(this.style.fontFamily)?this.style.fontFamily[0]:this.style.fontFamily}get fontSize(){return this.style.fontSize}set fontSize(A){this.style.fontSize=A}get leading(){return this.style.leading}set leading(A){this.style.leading=A}update(A){}copy(){const A=Un.fromJSON(JSON.parse(JSON.stringify(this)));return A.filters=this.filters,A.font=this.font,A}get transformedText(){return this.textCase=="lower"?this._text.toLocaleLowerCase():this.textCase=="upper"?this._text.toUpperCase():this._text}reflectUpdate(){var L,K,te,ne,ie,oe;const A=(K=(L=this.view.children[0])==null?void 0:L.width)!=null?K:0,z=(ne=(te=this.view.children[0])==null?void 0:te.height)!=null?ne:0,I=((oe=(ie=this.style.dropShadow)==null?void 0:ie.distance)!=null?oe:0)*Z;this.view.pivot={x:(A-I)*this._anchor.x,y:(z-I)*this._anchor.y}}set(A){return super.set(A)}};y([l()],g.prototype,"text"),y([l(R)],g.prototype,"font"),y([l()],g.prototype,"maxWidth"),y([l()],g.prototype,"textAlign"),y([l()],g.prototype,"padding"),y([l()],g.prototype,"textBaseline"),y([l()],g.prototype,"fillStyle"),y([l()],g.prototype,"anchor"),y([l()],g.prototype,"stroke"),y([l()],g.prototype,"textCase"),y([l()],g.prototype,"shadow"),y([l()],g.prototype,"fontSize"),y([l()],g.prototype,"leading"),y([nt],g.prototype,"update");let _=g;function ft(O){const C=O.split(" ").map(A=>`${A} `);return C[C.length-1]=C[C.length-1].replace(/ $/,""),C}const ti={get(O,C){const A=O[C];return typeof A=="number"?A*Z:Array.isArray(A)&&typeof A[0]=="number"?A.map(z=>z*Z):A}};function ei(O){return new Proxy(O,ti)}class ii{constructor(){we(this,"tokens",[])}get width(){return this.tokens.reduce((C,A)=>C+A.metrics.lineWidths[0],0)}get height(){return Math.max(...this.tokens.map(C=>C.metrics.lineHeight))}}class Yt{constructor(){we(this,"lines",[])}get width(){return Math.max(...this.lines.map(C=>C.width))}get height(){return this.lines.reduce((C,A)=>C+A.height,0)}}class si{static fromJSON(C){return C.map(A=>(A.font&&(A.font=R.fromJSON(A.font)),A))}}var ri=Object.defineProperty,ni=Object.getOwnPropertyDescriptor,E=(O,C,A,z)=>{for(var I=z>1?void 0:z?ni(C,A):C,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=(z?K(C,A,I):K(I))||I);return z&&I&&ri(C,A,I),I};const X=class Gn extends _{constructor(A){super();we(this,"type","complex_text");we(this,"_maxWidth");we(this,"_textAlign","left");we(this,"_textBaseline","top");we(this,"model",new Container);we(this,"segments",[]);we(this,"metrics",new Yt);we(this,"background");we(this,"styles");this.view.addChild(this.model),typeof A=="string"?(this.text=A,this.reflectUpdate()):A&&(Object.assign(this,A),this.reflectUpdate())}get text(){return this._text}set text(A){this._text=A}get maxWidth(){return this._maxWidth}set maxWidth(A){this._maxWidth=A}get textAlign(){return this._textAlign}set textAlign(A){this._textAlign=A,this._anchor.x=se[A];const z=this.metrics.width;for(const I of this.metrics.lines){let L=0;(A=="center"||A=="justify")&&(L=(z-I.width)/2),A=="right"&&(L=z-I.width);for(const K of I.tokens)this.model.children[K.index].x=L,L+=K.metrics.lineWidths[0]}}get textBaseline(){return this._textBaseline}set textBaseline(A){this._textBaseline=A,this._anchor.y=re[A];let z=0;for(const I of this.metrics.lines){const L=I.height;for(const K of I.tokens){let te=0;A=="middle"&&(te=(L-K.metrics.lineHeight)/2),A=="bottom"&&(te=L-K.metrics.lineHeight),this.model.children[K.index].y=z+te}z+=L}}copy(){const A=Gn.fromJSON(JSON.parse(JSON.stringify(this)));return A.filters=this.filters,A.font=this.font,A}createRenderSplits(A=[]){var L,K,te,ne;const z=(L=this.transformedText)!=null?L:"",I=[{index:void 0,tokens:ft(z.substring(0,(K=A==null?void 0:A.at(0))==null?void 0:K.start))}];for(let ie=0;ie<A.length;ie++)I.push({index:A[ie].index,tokens:ft(z.substring(A[ie].start,A[ie].stop))}),!(((te=A[ie].stop)!=null?te:z.length)>=z.length)&&I.push({index:void 0,tokens:ft(z.substring(A[ie].stop,(ne=A.at(ie+1))==null?void 0:ne.start))});return I.filter(ie=>ie.tokens.join("").trim().length)}createTextMetrics(A,z){var L,K,te,ne,ie;const I=new Yt;for(const oe of A){const ue=oe.index!=null?z[oe.index]:this.style;for(let de=0;de<oe.tokens.length;de++){const he=ei(CanvasTextMetrics.measureText(oe.tokens[de],ue)),fe=((K=(L=I.lines.at(-1))==null?void 0:L.width)!=null?K:0)+he.lineWidths[0],be=(te=this.maxWidth)!=null?te:Number.POSITIVE_INFINITY,xe=(ne=oe.tokens.at(de-1))==null?void 0:ne.match(/(\n|\\n).$/gim);(fe>be||xe||!I.lines.length)&&I.lines.push(new ii),this.model.addChild(new Text({text:oe.tokens[de],style:ue,resolution:Z,scale:Z})),(ie=I.lines.at(-1))==null||ie.tokens.push({metrics:he,index:this.model.children.length-1})}}return I}createTextStyles(){var A,z;return(z=(A=this.styles)==null?void 0:A.map(I=>{var K,te,ne,ie,oe;const L=this.style.clone();return L.fill=(K=I.fillStyle)!=null?K:this.style.fill,L.fontSize=(te=I.fontSize)!=null?te:this.style.fontSize,L.stroke=(ne=I.stroke)!=null?ne:this.style.stroke,L.fontFamily=(oe=(ie=I.font)==null?void 0:ie.name)!=null?oe:this.style.fontFamily,L}))!=null?z:[]}drawBackground(){var te,ne,ie,oe,ue,de,he;if(this.view.children.length>1&&this.view.removeChildAt(0),!this.background)return;const A=this.model.width,z=this.model.height,I=(ne=(te=this.background.padding)==null?void 0:te.x)!=null?ne:40,L=(oe=(ie=this.background.padding)==null?void 0:ie.y)!=null?oe:10,K=new Graphics;K.roundRect(0-I/2,2-L/2,A+I,z+L,(ue=this.background.borderRadius)!=null?ue:20),K.fill((de=this.background.fill)!=null?de:"#000000"),K.alpha=(he=this.background.alpha)!=null?he:1,this.view.addChildAt(K,0)}reflectUpdate(){var te,ne;if(!this.transformedText)return;this.model.removeChildren();const A=this.createRenderSplits(this.segments),z=this.createTextStyles();this.metrics=this.createTextMetrics(A,z),this.textAlign=this.textAlign,this.textBaseline=this.textBaseline;const I=this.view.width,L=this.view.height,K=((ne=(te=this.style.dropShadow)==null?void 0:te.distance)!=null?ne:0)*Z;this.view.pivot={x:(I-K)*this._anchor.x,y:(L-K)*this._anchor.y},this.drawBackground()}};E([l()],X.prototype,"background",2),E([l(si)],X.prototype,"styles",2),E([l()],X.prototype,"text",1),E([l()],X.prototype,"maxWidth",1),E([l()],X.prototype,"textAlign",1),E([l()],X.prototype,"textBaseline",1);let M=X;const ae="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBtPSh0PT4odFt0LkFWTUVESUFfVFlQRV9VTktOT1dOPS0xXT0iQVZNRURJQV9UWVBFX1VOS05PV04iLHRbdC5BVk1FRElBX1RZUEVfVklERU89MF09IkFWTUVESUFfVFlQRV9WSURFTyIsdFt0LkFWTUVESUFfVFlQRV9BVURJTz0xXT0iQVZNRURJQV9UWVBFX0FVRElPIix0W3QuQVZNRURJQV9UWVBFX0RBVEE9Ml09IkFWTUVESUFfVFlQRV9EQVRBIix0W3QuQVZNRURJQV9UWVBFX1NVQlRJVExFPTNdPSJBVk1FRElBX1RZUEVfU1VCVElUTEUiLHRbdC5BVk1FRElBX1RZUEVfQVRUQUNITUVOVD00XT0iQVZNRURJQV9UWVBFX0FUVEFDSE1FTlQiLHRbdC5BVk1FRElBX1RZUEVfTkI9NV09IkFWTUVESUFfVFlQRV9OQiIsdCkpKG18fHt9KSxvPSh0PT4odC5GRm1wZWdXb3JrZXJMb2FkZWQ9IkZGbXBlZ1dvcmtlckxvYWRlZCIsdC5XQVNNUnVudGltZUluaXRpYWxpemVkPSJXQVNNUnVudGltZUluaXRpYWxpemVkIix0LkxvYWRXQVNNPSJMb2FkV0FTTSIsdC5HZXRBVlBhY2tldD0iR2V0QVZQYWNrZXQiLHQuR2V0QVZQYWNrZXRzPSJHZXRBVlBhY2tldHMiLHQuR2V0QVZTdHJlYW09IkdldEFWU3RyZWFtIix0LkdldEFWU3RyZWFtcz0iR2V0QVZTdHJlYW1zIix0LlJlYWRBVlBhY2tldD0iUmVhZEFWUGFja2V0Iix0LkFWUGFja2V0U3RyZWFtPSJBVlBhY2tldFN0cmVhbSIsdC5SZWFkTmV4dEFWUGFja2V0PSJSZWFkTmV4dEFWUGFja2V0Iix0LlN0b3BSZWFkQVZQYWNrZXQ9IlN0b3BSZWFkQVZQYWNrZXQiLHQpKShvfHx7fSk7Y29uc3QgQT0iS0daMWJtTjBhVzl1S0NsN0luVnpaU0J6ZEhKcFkzUWlPMnhsZENCbU8zTmxiR1l1Y0c5emRFMWxjM05oWjJVb2UzUjVjR1U2SWtaR2JYQmxaMWR2Y210bGNreHZZV1JsWkNKOUtTeHpaV3htTG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvSW0xbGMzTmhaMlVpTEdGemVXNWpJR1oxYm1OMGFXOXVLR3dwZTJOdmJuTjBlM1I1Y0dVNmRDeGtZWFJoT21NOWUzMHNiWE5uU1dRNmIzMDliQzVrWVhSaE8zUnllWHRwWmloMFBUMDlJa3h2WVdSWFFWTk5JaWw3WTI5dWMzUjdkMkZ6YlV4dllXUmxjbEJoZEdnNlpYMDlZM3g4ZTMwN1pqMWhkMkZwZENoaGQyRnBkQ0JwYlhCdmNuUW9aU2twTG1SbFptRjFiSFFvS1gxbGJITmxJR2xtS0hROVBUMGlSMlYwUVZaVGRISmxZVzBpS1h0amIyNXpkSHRtYVd4bE9tVXNjM1J5WldGdFZIbHdaVHB6TEhOMGNtVmhiVWx1WkdWNE9tRjlQV01zY2oxbUxtZGxkRUZXVTNSeVpXRnRLR1VzY3l4aEtUdHpaV3htTG5CdmMzUk5aWE56WVdkbEtIdDBlWEJsT25Rc2JYTm5TV1E2Ynl4eVpYTjFiSFE2Y24wc1czSXVZMjlrWldOd1lYSXVaWGgwY21Ga1lYUmhMbUoxWm1abGNsMHBmV1ZzYzJVZ2FXWW9kRDA5UFNKSFpYUkJWbE4wY21WaGJYTWlLWHRqYjI1emRIdG1hV3hsT21WOVBXTXNjejFtTG1kbGRFRldVM1J5WldGdGN5aGxLVHR6Wld4bUxuQnZjM1JOWlhOellXZGxLSHQwZVhCbE9uUXNiWE5uU1dRNmJ5eHlaWE4xYkhRNmMzMHNjeTV0WVhBb1lUMCtZUzVqYjJSbFkzQmhjaTVsZUhSeVlXUmhkR0V1WW5WbVptVnlLU2w5Wld4elpTQnBaaWgwUFQwOUlrZGxkRUZXVUdGamEyVjBJaWw3WTI5dWMzUjdabWxzWlRwbExIUnBiV1U2Y3l4emRISmxZVzFVZVhCbE9tRXNjM1J5WldGdFNXNWtaWGc2Y24wOVl5eHVQV1l1WjJWMFFWWlFZV05yWlhRb1pTeHpMR0VzY2lrN2MyVnNaaTV3YjNOMFRXVnpjMkZuWlNoN2RIbHdaVHAwTEcxelowbGtPbThzY21WemRXeDBPbTU5TEZ0dUxtUmhkR0V1WW5WbVptVnlYU2w5Wld4elpTQnBaaWgwUFQwOUlrZGxkRUZXVUdGamEyVjBjeUlwZTJOdmJuTjBlMlpwYkdVNlpTeDBhVzFsT25OOVBXTXNZVDFtTG1kbGRFRldVR0ZqYTJWMGN5aGxMSE1wTzNObGJHWXVjRzl6ZEUxbGMzTmhaMlVvZTNSNWNHVTZkQ3h0YzJkSlpEcHZMSEpsYzNWc2REcGhmU3hoTG0xaGNDaHlQVDV5TG1SaGRHRXVZblZtWm1WeUtTbDlaV3h6WlNCcFppaDBQVDA5SWxKbFlXUkJWbEJoWTJ0bGRDSXBlMk52Ym5OMGUyWnBiR1U2WlN4emRHRnlkRHB6TEdWdVpEcGhMSE4wY21WaGJWUjVjR1U2Y2l4emRISmxZVzFKYm1SbGVEcHVmVDFqTEdROVppNXlaV0ZrUVZaUVlXTnJaWFFvYnl4bExITXNZU3h5TEc0cE8zTmxiR1l1Y0c5emRFMWxjM05oWjJVb2UzUjVjR1U2ZEN4dGMyZEpaRHB2TEhKbGMzVnNkRHBrZlNsOWZXTmhkR05vS0dVcGUzTmxiR1l1Y0c5emRFMWxjM05oWjJVb2UzUjVjR1U2ZEN4dGMyZEpaRHB2TEdWeWNrMXpaenBsSUdsdWMzUmhibU5sYjJZZ1JYSnliM0kvWlM1dFpYTnpZV2RsT2lKVmJtdHViM2R1SUVWeWNtOXlJbjBwZlgwcGZTa29LVHNLIixnPXQ9PlVpbnQ4QXJyYXkuZnJvbShhdG9iKHQpLGU9PmUuY2hhckNvZGVBdCgwKSksVj10eXBlb2Ygc2VsZjwidSImJnNlbGYuQmxvYiYmbmV3IEJsb2IoW2coQSldLHt0eXBlOiJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOCJ9KTtmdW5jdGlvbiBFKHQpe2xldCBlO3RyeXtpZihlPVYmJihzZWxmLlVSTHx8c2VsZi53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChWKSwhZSl0aHJvdyIiO2NvbnN0IHM9bmV3IFdvcmtlcihlLHtuYW1lOnQ/Lm5hbWV9KTtyZXR1cm4gcy5hZGRFdmVudExpc3RlbmVyKCJlcnJvciIsKCk9Pnsoc2VsZi5VUkx8fHNlbGYud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwoZSl9KSxzfWNhdGNoe3JldHVybiBuZXcgV29ya2VyKCJkYXRhOnRleHQvamF2YXNjcmlwdDtiYXNlNjQsIitBLHtuYW1lOnQ/Lm5hbWV9KX1maW5hbGx5e2UmJihzZWxmLlVSTHx8c2VsZi53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChlKX19Y29uc3QgdT0xZTY7Y2xhc3MgcHtmZm1wZWdXb3JrZXI7ZmZtcGVnV29ya2VyTG9hZFN0YXR1czttc2dJZDtmaWxlO2NvbnN0cnVjdG9yKGUpe3RoaXMuZmZtcGVnV29ya2VyPW5ldyBFLHRoaXMuZmZtcGVnV29ya2VyTG9hZFN0YXR1cz1uZXcgUHJvbWlzZSgocyxhKT0+e3RoaXMuZmZtcGVnV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGk9Pntjb25zdHt0eXBlOnIsZXJyTXNnOmR9PWkuZGF0YTtyPT09by5GRm1wZWdXb3JrZXJMb2FkZWQmJnRoaXMucG9zdChvLkxvYWRXQVNNLHt3YXNtTG9hZGVyUGF0aDplLndhc21Mb2FkZXJQYXRofSkscj09PW8uV0FTTVJ1bnRpbWVJbml0aWFsaXplZCYmcyghMCkscj09PW8uTG9hZFdBU00mJmQmJmEoZCl9KX0pLHRoaXMubXNnSWQ9MH1wb3N0KGUscyxhKXt0aGlzLmZmbXBlZ1dvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTplLG1zZ0lkOmE/P3RoaXMubXNnSWQrKyxkYXRhOnN9KX1hc3luYyBsb2FkKGUpe2NvbnN0IHM9YXdhaXQgdGhpcy5mZm1wZWdXb3JrZXJMb2FkU3RhdHVzO3JldHVybiB0aGlzLmZpbGU9ZSxzfWRlc3Ryb3koKXt0aGlzLmZpbGU9dm9pZCAwLHRoaXMuZmZtcGVnV29ya2VyLnRlcm1pbmF0ZSgpfWdldEFWU3RyZWFtKGU9bS5BVk1FRElBX1RZUEVfVklERU8scz0tMSl7cmV0dXJuIG5ldyBQcm9taXNlKChhLGkpPT57aWYoIXRoaXMuZmlsZSl7aSgiZmlsZSBpcyBub3QgbG9hZGVkIik7cmV0dXJufWNvbnN0IHI9dGhpcy5tc2dJZCxkPSh7ZGF0YTpufSk9PntuLnR5cGU9PT1vLkdldEFWU3RyZWFtJiZuLm1zZ0lkPT09ciYmKG4uZXJyTXNnP2kobi5lcnJNc2cpOmEobi5yZXN1bHQpLHRoaXMuZmZtcGVnV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGQpKX07dGhpcy5mZm1wZWdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsZCksdGhpcy5wb3N0KG8uR2V0QVZTdHJlYW0se2ZpbGU6dGhpcy5maWxlLHN0cmVhbVR5cGU6ZSxzdHJlYW1JbmRleDpzfSl9KX1nZXRBVlN0cmVhbXMoKXtyZXR1cm4gbmV3IFByb21pc2UoKGUscyk9PntpZighdGhpcy5maWxlKXtzKCJmaWxlIGlzIG5vdCBsb2FkZWQiKTtyZXR1cm59Y29uc3QgYT10aGlzLm1zZ0lkLGk9KHtkYXRhOnJ9KT0+e3IudHlwZT09PW8uR2V0QVZTdHJlYW1zJiZyLm1zZ0lkPT09YSYmKHIuZXJyTXNnP3Moci5lcnJNc2cpOmUoci5yZXN1bHQpLHRoaXMuZmZtcGVnV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGkpKX07dGhpcy5mZm1wZWdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsaSksdGhpcy5wb3N0KG8uR2V0QVZTdHJlYW1zLHtmaWxlOnRoaXMuZmlsZX0pfSl9Z2V0QVZQYWNrZXQoZSxzPW0uQVZNRURJQV9UWVBFX1ZJREVPLGE9LTEpe3JldHVybiBuZXcgUHJvbWlzZSgoaSxyKT0+e2lmKCF0aGlzLmZpbGUpe3IoImZpbGUgaXMgbm90IGxvYWRlZCIpO3JldHVybn1jb25zdCBkPXRoaXMubXNnSWQsbj1oPT57Y29uc3QgbD1oLmRhdGE7bC50eXBlPT09by5HZXRBVlBhY2tldCYmbC5tc2dJZD09PWQmJihsLmVyck1zZz9yKGwuZXJyTXNnKTppKGwucmVzdWx0KSx0aGlzLmZmbXBlZ1dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIixuKSl9O3RoaXMuZmZtcGVnV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLG4pLHRoaXMucG9zdChvLkdldEFWUGFja2V0LHtmaWxlOnRoaXMuZmlsZSx0aW1lOmUsc3RyZWFtVHlwZTpzLHN0cmVhbUluZGV4OmF9KX0pfWdldEFWUGFja2V0cyhlKXtyZXR1cm4gbmV3IFByb21pc2UoKHMsYSk9PntpZighdGhpcy5maWxlKXthKCJmaWxlIGlzIG5vdCBsb2FkZWQiKTtyZXR1cm59Y29uc3QgaT10aGlzLm1zZ0lkLHI9ZD0+e2NvbnN0IG49ZC5kYXRhO24udHlwZT09PW8uR2V0QVZQYWNrZXRzJiZuLm1zZ0lkPT09aSYmKG4uZXJyTXNnP2Eobi5lcnJNc2cpOnMobi5yZXN1bHQpLHRoaXMuZmZtcGVnV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLHIpKX07dGhpcy5mZm1wZWdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsciksdGhpcy5wb3N0KG8uR2V0QVZQYWNrZXRzLHtmaWxlOnRoaXMuZmlsZSx0aW1lOmV9KX0pfXJlYWRBVlBhY2tldChlPTAscz0wLGE9bS5BVk1FRElBX1RZUEVfVklERU8saT0tMSl7Y29uc3Qgcj1uZXcgQ291bnRRdWV1aW5nU3RyYXRlZ3koe2hpZ2hXYXRlck1hcms6MX0pLGQ9dGhpcy5tc2dJZDtsZXQgbj0wO3JldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0Omg9PntpZighdGhpcy5maWxlKXtoLmVycm9yKCJmaWxlIGlzIG5vdCBsb2FkZWQiKTtyZXR1cm59Y29uc3QgbD1mPT57Y29uc3QgYz1mLmRhdGE7Yy50eXBlPT09by5SZWFkQVZQYWNrZXQmJmMubXNnSWQ9PT1kJiZjLmVyck1zZyYmKGguZXJyb3IoYy5lcnJNc2cpLHRoaXMuZmZtcGVnV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGwpKSxjLnR5cGU9PT1vLkFWUGFja2V0U3RyZWFtJiZjLm1zZ0lkPT09ZCYmKGMucmVzdWx0P2guZW5xdWV1ZShjLnJlc3VsdCk6aC5jbG9zZSgpKX07dGhpcy5mZm1wZWdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsbCksdGhpcy5wb3N0KG8uUmVhZEFWUGFja2V0LHtmaWxlOnRoaXMuZmlsZSxzdGFydDplLGVuZDpzLHN0cmVhbVR5cGU6YSxzdHJlYW1JbmRleDppfSl9LHB1bGw6KCk9PntuPjAmJnRoaXMucG9zdChvLlJlYWROZXh0QVZQYWNrZXQsdm9pZCAwLGQpLG4rK30sY2FuY2VsOigpPT57dGhpcy5wb3N0KG8uU3RvcFJlYWRBVlBhY2tldCx2b2lkIDAsZCl9fSxyKX1nZXRWaWRlb1N0cmVhbShlKXtyZXR1cm4gdGhpcy5nZXRBVlN0cmVhbShtLkFWTUVESUFfVFlQRV9WSURFTyxlKX1nZXRBdWRpb1N0cmVhbShlKXtyZXR1cm4gdGhpcy5nZXRBVlN0cmVhbShtLkFWTUVESUFfVFlQRV9BVURJTyxlKX1zZWVrVmlkZW9QYWNrZXQoZSl7cmV0dXJuIHRoaXMuZ2V0QVZQYWNrZXQoZSxtLkFWTUVESUFfVFlQRV9WSURFTyl9c2Vla0F1ZGlvUGFja2V0KGUpe3JldHVybiB0aGlzLmdldEFWUGFja2V0KGUsbS5BVk1FRElBX1RZUEVfQVVESU8pfXJlYWRWaWRlb1BhY2tldChlLHMpe3JldHVybiB0aGlzLnJlYWRBVlBhY2tldChlLHMsbS5BVk1FRElBX1RZUEVfVklERU8pfXJlYWRBdWRpb1BhY2tldChlLHMpe3JldHVybiB0aGlzLnJlYWRBVlBhY2tldChlLHMsbS5BVk1FRElBX1RZUEVfQVVESU8pfWdlblZpZGVvRGVjb2RlckNvbmZpZyhlKXtyZXR1cm57Y29kZWM6ZS5jb2RlY3Bhci5jb2RlY19zdHJpbmcsY29kZWRXaWR0aDplLmNvZGVjcGFyLndpZHRoLGNvZGVkSGVpZ2h0OmUuY29kZWNwYXIuaGVpZ2h0LGRlc2NyaXB0aW9uOmUuY29kZWNwYXIuZXh0cmFkYXRhPy5sZW5ndGg+MD9lLmNvZGVjcGFyLmV4dHJhZGF0YTp2b2lkIDB9fWdlbkVuY29kZWRWaWRlb0NodW5rKGUpe3JldHVybiBuZXcgRW5jb2RlZFZpZGVvQ2h1bmsoe3R5cGU6ZS5rZXlmcmFtZT09PTE/ImtleSI6ImRlbHRhIix0aW1lc3RhbXA6ZS50aW1lc3RhbXAqdSxkdXJhdGlvbjplLmR1cmF0aW9uKnUsZGF0YTplLmRhdGF9KX1nZW5BdWRpb0RlY29kZXJDb25maWcoZSl7cmV0dXJue2NvZGVjOmUuY29kZWNwYXIuY29kZWNfc3RyaW5nfHwiIixzYW1wbGVSYXRlOmUuY29kZWNwYXIuc2FtcGxlX3JhdGUsbnVtYmVyT2ZDaGFubmVsczplLmNvZGVjcGFyLmNoYW5uZWxzLGRlc2NyaXB0aW9uOmUuY29kZWNwYXIuZXh0cmFkYXRhPy5sZW5ndGg+MD9lLmNvZGVjcGFyLmV4dHJhZGF0YTp2b2lkIDB9fWdlbkVuY29kZWRBdWRpb0NodW5rKGUpe3JldHVybiBuZXcgRW5jb2RlZEF1ZGlvQ2h1bmsoe3R5cGU6ZS5rZXlmcmFtZT09PTE/ImtleSI6ImRlbHRhIix0aW1lc3RhbXA6ZS50aW1lc3RhbXAqdSxkdXJhdGlvbjplLmR1cmF0aW9uKnUsZGF0YTplLmRhdGF9KX1hc3luYyBnZXRWaWRlb0RlY29kZXJDb25maWcoKXtjb25zdCBlPWF3YWl0IHRoaXMuZ2V0VmlkZW9TdHJlYW0oKTtyZXR1cm4gdGhpcy5nZW5WaWRlb0RlY29kZXJDb25maWcoZSl9YXN5bmMgc2Vla0VuY29kZWRWaWRlb0NodW5rKGUpe2NvbnN0IHM9YXdhaXQgdGhpcy5zZWVrVmlkZW9QYWNrZXQoZSk7cmV0dXJuIHRoaXMuZ2VuRW5jb2RlZFZpZGVvQ2h1bmsocyl9YXN5bmMgZ2V0QXVkaW9EZWNvZGVyQ29uZmlnKCl7Y29uc3QgZT1hd2FpdCB0aGlzLmdldEF1ZGlvU3RyZWFtKCk7cmV0dXJuIHRoaXMuZ2VuQXVkaW9EZWNvZGVyQ29uZmlnKGUpfWFzeW5jIHNlZWtFbmNvZGVkQXVkaW9DaHVuayhlKXtjb25zdCBzPWF3YWl0IHRoaXMuc2Vla0F1ZGlvUGFja2V0KGUpO3JldHVybiB0aGlzLmdlbkVuY29kZWRBdWRpb0NodW5rKHMpfX1jbGFzcyBre3ZpZGVvO2N1cnJlbnRGcmFtZXM9MDt0b3RhbEZyYW1lcztjdXJyZW50VGltZTtmcHM7Zmlyc3RUaW1lc3RhbXA7Y29uc3RydWN0b3IoZSxzKXt0aGlzLmN1cnJlbnRUaW1lPWVbMF0qMWU2LHRoaXMuZmlyc3RUaW1lc3RhbXA9ZVswXSoxZTYsdGhpcy50b3RhbEZyYW1lcz0oZVsxXS1lWzBdKSpzKzEsdGhpcy5mcHM9cyx0aGlzLnZpZGVvPW5ldyBWaWRlb0RlY29kZXIoe291dHB1dDp0aGlzLmhhbmRsZUZyYW1lT3V0cHV0LmJpbmQodGhpcyksZXJyb3I6dGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpfSl9cG9zdEZyYW1lKGUpe3NlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6ImZyYW1lIixmcmFtZTplfSksdGhpcy5jdXJyZW50VGltZSs9TWF0aC5mbG9vcigxL3RoaXMuZnBzKjFlNiksdGhpcy5jdXJyZW50RnJhbWVzKz0xfWhhbmRsZUZyYW1lT3V0cHV0KGUpe2NvbnN0IHM9ZS50aW1lc3RhbXAsYT1lLmR1cmF0aW9uPz8wLGk9cythO2lmKCF0aGlzLmlzRnJhbWVJblJhbmdlKHMpKXtlLmNsb3NlKCk7cmV0dXJufWZvcig7aT50aGlzLmN1cnJlbnRUaW1lJiZ0aGlzLmN1cnJlbnRGcmFtZXM8PXRoaXMudG90YWxGcmFtZXM7KXRoaXMucG9zdEZyYW1lKGUpO2UuY2xvc2UoKX1pc0ZyYW1lSW5SYW5nZShlKXtyZXR1cm4gZT49dGhpcy5maXJzdFRpbWVzdGFtcH1oYW5kbGVFcnJvcihlKXtjb25zb2xlLmVycm9yKCJlcnJvciBpbiB3b3JrZXIiLGUpLHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6ImVycm9yIixtZXNzYWdlOmUubWVzc2FnZT8/IkFuIHVua25vd24gd29ya2VyIGVycm9yIG9jY3VycmVkIn0pLHNlbGYuY2xvc2UoKX19ZnVuY3Rpb24gSSh0KXtyZXR1cm4gYXN5bmMgZT0+e3RyeXthd2FpdCB0KGUpfWNhdGNoKHMpe3NlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6ImVycm9yIixtZXNzYWdlOnM/Lm1lc3NhZ2U/PyJBbiB1bmtvd24gd29ya2VyIGVycm9yIG9jY3VyZWQifSl9fX1mdW5jdGlvbiBXKHQpe3JldHVybiB0LmNvZGVjPT0idnAwOSImJih0LmNvZGVjPSJ2cDA5LjAwLjEwLjA4IiksdH1jb25zdCBaPTMwO2FzeW5jIGZ1bmN0aW9uIFAodCl7aWYodC5kYXRhPy50eXBlIT0iaW5pdCIpcmV0dXJuO2NvbnN0e2ZpbGU6ZSxyYW5nZTpzLGZwczphfT10LmRhdGEsaT1uZXcgcCh7d2FzbUxvYWRlclBhdGg6Imh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQGRpZmZ1c2lvbnN0dWRpby9mZm1wZWctd2FzbUAxLjAuMC9kaXN0L2ZmbXBlZy5qcyJ9KTthd2FpdCBpLmxvYWQoZSk7Y29uc3Qgcj1hd2FpdCBpLmdldFZpZGVvRGVjb2RlckNvbmZpZygpO1cocik7Y29uc3QgZD1uZXcgayhzLGEpO2QudmlkZW8uY29uZmlndXJlKHIpO2NvbnN0IG49aS5yZWFkQVZQYWNrZXQoc1swXSxzWzFdKS5nZXRSZWFkZXIoKTtuLnJlYWQoKS50aGVuKGFzeW5jIGZ1bmN0aW9uIGgoe2RvbmU6bCx2YWx1ZTpmfSl7aWYobCl7YXdhaXQgZC52aWRlby5mbHVzaCgpLHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6ImRvbmUifSksc2VsZi5jbG9zZSgpO3JldHVybn1jb25zdCBjPWkuZ2VuRW5jb2RlZFZpZGVvQ2h1bmsoZik7cmV0dXJuIGQudmlkZW8uZGVjb2RlUXVldWVTaXplPlomJmF3YWl0IG5ldyBQcm9taXNlKEw9PntkLnZpZGVvLm9uZGVxdWV1ZT0oKT0+TCgpfSksYy50aW1lc3RhbXA8PXNbMV0qMWU2JiZkLnZpZGVvLmRlY29kZShjKSxuLnJlYWQoKS50aGVuKGgpfSl9c2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixJKFApKX0pKCk7Cg==",oi=O=>Uint8Array.from(atob(O),C=>C.charCodeAt(0)),Bt=typeof self<"u"&&self.Blob&&new Blob([oi(ae)],{type:"text/javascript;charset=utf-8"});function ai(O){let C;try{if(C=Bt&&(self.URL||self.webkitURL).createObjectURL(Bt),!C)throw"";const A=new Worker(C,{name:O==null?void 0:O.name});return A.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(C)}),A}catch{return new Worker("data:text/javascript;base64,"+ae,{name:O==null?void 0:O.name})}finally{C&&(self.URL||self.webkitURL).revokeObjectURL(C)}}class li{constructor(){we(this,"buffer",[]);we(this,"state","active");we(this,"onenqueue");we(this,"onclose")}enqueue(C){var A;this.buffer.unshift(C),(A=this.onenqueue)==null||A.call(this)}async dequeue(){if(this.buffer.length==0&&this.state=="active"&&await this.waitFor(2e4),!(this.buffer.length==0&&this.state=="closed"))return this.buffer.pop()}close(){var C;this.state="closed",(C=this.onclose)==null||C.call(this)}terminate(){for(const C of this.buffer)C.close()}async waitFor(C){await new Promise((A,z)=>{const I=setTimeout(()=>{z(`Promise timed out after ${C} ms`)},C);this.onenqueue=()=>{clearTimeout(I),A()},this.onclose=()=>{clearTimeout(I),A()}})}}function hi(O,C,A){const z=A.value;return A.value=function(...I){var L,K,te,ne;return((K=(L=this.track)==null?void 0:L.composition)==null?void 0:K.rendering)&&this.sprite.texture.source.uid!=this.textrues.canvas.source.uid&&(this.sprite.texture=this.textrues.canvas),!((ne=(te=this.track)==null?void 0:te.composition)!=null&&ne.rendering)&&this.sprite.texture.source.uid!=this.textrues.html5.source.uid&&(this.sprite.texture=this.textrues.html5),z.apply(this,I)},A}var ci=Object.defineProperty,di=Object.getOwnPropertyDescriptor,ui=(O,C,A,z)=>{for(var I=di(C,A),L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&ci(C,A,I),I};const le=class Dn extends rt(st){constructor(A,z={}){super();we(this,"source",new wt);we(this,"type","video");we(this,"worker");we(this,"buffer");we(this,"canvas",document.createElement("canvas"));we(this,"context",this.canvas.getContext("2d"));we(this,"element",document.createElement("video"));we(this,"textrues",{html5:Texture.from(this.element),canvas:Texture.from(this.canvas)});we(this,"sprite",new Sprite);this.textrues.html5.source.playsInline=!0,this.textrues.html5.source.autoPlay=!1,this.textrues.html5.source.loop=!1,this.sprite.texture=this.textrues.html5,this.view.addChild(this.sprite),A instanceof wt&&(this.source=A),A instanceof File&&this.source.from(A),this.element.addEventListener("play",()=>{this.playing=!0}),this.element.addEventListener("pause",()=>{this.playing=!1}),Object.assign(this,z)}async init(){const A=await this.source.createObjectURL();this.element.setAttribute("src",A),await new Promise((z,I)=>{this.element.oncanplay=()=>{this.duration.seconds=this.element.duration,this.state="READY",z()},this.element.onerror=()=>{var K;this.state="ERROR";const L=new Error("An error occurred while processing the input medium.");this.trigger("error",L),I((K=this.element.error)!=null?K:L)}})}async connect(A){var I,L;const z=(L=(I=A.composition)==null?void 0:I.frame)!=null?L:0;await this.seek(h.fromFrames(z)),super.connect(A)}update(A){var z,I,L,K,te,ne;if(((I=(z=this.track)==null?void 0:z.composition)==null?void 0:I.playing)&&!this.playing)this.element.play();else if(!((K=(L=this.track)==null?void 0:L.composition)!=null&&K.playing)&&this.playing)this.element.pause();else if((ne=(te=this.track)==null?void 0:te.composition)!=null&&ne.rendering)return this.nextFrame()}exit(){this.playing&&this.element.pause(),this.filters&&this.view.filters&&(this.view.filters=null)}copy(){const A=Dn.fromJSON(JSON.parse(JSON.stringify(this)));return A.filters=this.filters,A.source=this.source,A}async seek(A){var z,I;if((I=(z=this.track)==null?void 0:z.composition)!=null&&I.rendering){const L=this.decodeVideo();return new Promise(K=>{L.onenqueue=()=>K()})}return super.seek(A)}decodeVideo(){var A,z,I;return this.buffer=new li,this.worker=new ai,this.worker.addEventListener("message",L=>{var K,te;L.data.type=="frame"?(K=this.buffer)==null||K.enqueue(L.data.frame):L.data.type=="error"?this.cancelDecoding():L.data.type=="done"&&((te=this.buffer)==null||te.close())}),this.worker.postMessage({type:"init",file:this.source.file,range:this.demuxRange,fps:(I=(z=(A=this.track)==null?void 0:A.composition)==null?void 0:z.fps)!=null?I:v}),this.buffer}async nextFrame(){if(!this.buffer)return;const A=await this.buffer.dequeue();A&&(this.canvas.width=A.displayWidth,this.canvas.height=A.displayHeight,this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.context.drawImage(A,0,0),this.textrues.canvas.source.update(),A.close())}get demuxRange(){var L;const A=(L=this.track)==null?void 0:L.composition;let z;this.start.millis<0?z=Math.abs(this.offset.seconds):z=this.range[0].seconds;let I;return A&&this.stop.millis>A.duration.millis?I=A.duration.subtract(this.offset).seconds:I=this.range[1].seconds,[z,I]}cancelDecoding(){var A,z;(A=this.worker)==null||A.terminate(),this.worker=void 0,(z=this.buffer)==null||z.terminate(),this.buffer=void 0}};ui([nt,hi],le.prototype,"update");const fi={IMAGE:{"image/jpeg":"jpg","image/png":"png","image/webp":"webp","image/svg+xml":"svg"},VIDEO:{"video/mp4":"mp4","video/webm":"webm","video/quicktime":"mov"},AUDIO:{"audio/mp3":"mp3","audio/mpeg":"mp3","audio/aac":"aac","audio/wav":"wav","audio/x-wav":"wav"},DOCUMENT:{"text/html":"html"},get MIXED(){return{...this.IMAGE,...this.VIDEO,...this.AUDIO,...this.DOCUMENT}}};function q(O){if(!Object.keys(fi.MIXED).includes(O))throw new Vt({message:`${O} is not an accepted mime type`,i18n:"invalid_mimetype"});return O}var pi=Object.defineProperty,mi=Object.getOwnPropertyDescriptor,gi=(O,C,A,z)=>{for(var I=mi(C,A),L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&pi(C,A,I),I};const ce=class Ln extends rt(N){constructor(A,z={}){super();we(this,"type","html");we(this,"source",new gt);we(this,"element",new Image);we(this,"canvas",document.createElement("canvas"));we(this,"context",this.canvas.getContext("2d"));we(this,"sprite",new Sprite);this.view.addChild(this.sprite),Object.assign(this,z),A instanceof gt&&(this.source=A),A instanceof File&&this.source.from(A),this.element.addEventListener("load",()=>{var K,te,ne,ie;const I=(te=(K=this.source.document)==null?void 0:K.body)==null?void 0:te.scrollWidth,L=(ie=(ne=this.source.document)==null?void 0:ne.body)==null?void 0:ie.scrollHeight;!I||!L||(this.canvas.width=I,this.canvas.height=L,this.context.imageSmoothingEnabled=!1,this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.context.drawImage(this.element,0,0),this.sprite.texture=Texture.from(this.canvas,!0),this.trigger("load",void 0))}),this.element.addEventListener("error",I=>{console.error(I),this.state="ERROR",this.track&&this.detach(),this.trigger("error",new Error("An error occurred while processing the input medium."))}),this.on("update",async()=>{this.source.update(),this.element.setAttribute("src",await this.source.createObjectURL())})}async init(){this.element.setAttribute("src",await this.source.createObjectURL()),await new Promise((A,z)=>{this.element.onload=()=>{var K,te,ne,ie;const I=(te=(K=this.source.document)==null?void 0:K.body)==null?void 0:te.scrollWidth,L=(ie=(ne=this.source.document)==null?void 0:ne.body)==null?void 0:ie.scrollHeight;if(!I||!L)return z(new Error("This html document cannot be displayed!"));this.state="READY",A()},this.element.onerror=I=>{console.error(I),z(new Error("An error occurred while processing the input medium."))}})}update(A){}copy(){const A=Ln.fromJSON(JSON.parse(JSON.stringify(this)));return A.filters=this.filters,A.source=this.source,A}};gi([nt],ce.prototype,"update");var Ri=Object.defineProperty,pe=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Ri(C,A,I),I};class at extends w{constructor(A={}){var z;super();we(this,"generatorOptions");we(this,"type","CLASSIC");this.generatorOptions=(z=A.generatorOptions)!=null?z:{duration:[.2]}}async applyTo(A){var L,K,te,ne;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"Figtree",weight:"700"}).load();for(const ie of A.clip.transcript.iter(this.generatorOptions))await A.add(new _({text:ie.words.map(oe=>oe.text).join(" "),textAlign:"center",textBaseline:"middle",fontSize:21,fillStyle:"#FFFFFF",font:I,stroke:{color:"#000000",width:4,join:"round"},maxWidth:A.composition.width*.85,shadow:{color:"#000000",blur:0,distance:1.1,angle:Math.PI*.4,alpha:1},position:"center",stop:ie.stop.add(z),start:ie.start.add(z),scale:new b([0,8],[.96,1],{easing:"easeOut"}),alpha:new b([0,4],[0,1],{easing:"easeOut"})}))}}pe([l()],at.prototype,"generatorOptions"),pe([l()],at.prototype,"type");var vi=Object.defineProperty,Wt=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&vi(C,A,I),I};class lt extends w{constructor(A={}){var z,I;super();we(this,"generatorOptions");we(this,"type","SPOTLIGHT");we(this,"color");this.generatorOptions=(z=A.generatorOptions)!=null?z:{duration:[.2]},this.color=(I=A.color)!=null?I:"#00FF4C"}async applyTo(A){var L,K,te,ne;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"The Bold Font",weight:"500"}).load();for(const ie of A.clip.transcript.iter(this.generatorOptions))for(let oe=0;oe<ie.words.length;oe++){const ue=ie.words.map(de=>de.text);await A.add(new M({text:ue.join(" "),textAlign:"center",textBaseline:"middle",fillStyle:"#FFFFFF",fontSize:22,maxWidth:A.composition.width*.8,font:I,stroke:{width:5,color:"#000000"},shadow:{color:"#000000",blur:12,alpha:.7,angle:Math.PI/4,distance:2},position:"center",styles:[{fillStyle:this.color}],segments:ie.words.length>1?[{index:0,start:ue.slice(0,oe).join(" ").length,stop:ue.slice(0,oe+1).join(" ").length}]:void 0,stop:ie.words[oe].stop.add(z),start:ie.words[oe].start.add(z)}))}}}Wt([l()],lt.prototype,"generatorOptions"),Wt([l()],lt.prototype,"type"),Wt([l()],lt.prototype,"color");var Si=Object.defineProperty,me=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Si(C,A,I),I};class vt extends w{constructor(A={}){var z;super();we(this,"type","GUINEA");we(this,"colors");this.colors=(z=A.colors)!=null?z:["#1BD724","#FFEE0C","#FF2E17"]}async applyTo(A){var L,K,te,ne,ie,oe,ue,de;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"The Bold Font",weight:"500"}).load();for(const he of A.clip.transcript.iter({length:[18]})){const{segments:fe,words:be}=this.splitSequence(he);for(let xe=0;xe<he.words.length;xe++){const Se=(oe=(ie=be[xe])==null?void 0:ie.at(0))==null?void 0:oe.start,Fe=(de=(ue=be[xe])==null?void 0:ue.at(-1))==null?void 0:de.stop;!Se||!Fe||await A.add(new M({text:fe.join(`
 `),textAlign:"center",textBaseline:"middle",fontSize:20,fillStyle:"#FFFFFF",shadow:{color:"#000000",blur:16,alpha:.8,angle:Math.PI/4,distance:1},stroke:{width:4,color:"#000000"},maxWidth:A.composition.width*.8,leading:1.3,font:I,textCase:"upper",position:"center",stop:Fe.add(z),start:Se.add(z),styles:[{fillStyle:this.colors[0],fontSize:23},{fillStyle:this.colors[1],fontSize:23},{fillStyle:this.colors[2],fontSize:23}],segments:[{index:D(0,2),start:fe.slice(0,xe).join(" ").length,stop:fe.slice(0,xe+1).join(" ").length+xe*2}]}))}}}splitSequence(A){const z=A.text,I=Math.ceil(z.length/2);let L=z.length;for(let ne=I,ie=I;ne>0&&ie<A.text.length-1;ne--,ie++){if(z[ne].match(/ /)){L=ne;break}if(z[ie].match(/ /)){L=ie;break}}const K=[...kt(z,L).map(ne=>ne.trim())],te=kt(A.words,K[0].split(/ /).length);return{segments:K,words:te}}}me([l()],vt.prototype,"type"),me([l()],vt.prototype,"colors");var Fi=Object.defineProperty,ge=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Fi(C,A,I),I};class St extends w{constructor(A={}){var z;super();we(this,"generatorOptions");we(this,"type","CASCADE");this.generatorOptions=(z=A.generatorOptions)!=null?z:{duration:[1.4]}}async applyTo(A){var L,K,te,ne;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"Geologica",weight:"400"}).load();for(const ie of A.clip.transcript.iter(this.generatorOptions))for(let oe=0;oe<ie.words.length;oe++){const ue=()=>ie.words.length==1?ie.text:ie.words.map(de=>de.text).slice(0,oe+1).join(" ");await A.add(new _({text:ue(),textAlign:"left",textBaseline:"top",fillStyle:"#FFFFFF",fontSize:16,font:I,maxWidth:A.composition.width*.7,stroke:{color:"#000000",width:4,join:"round"},shadow:{color:"#000000",blur:8,alpha:.4,angle:Math.PI/4,distance:2},position:{x:"12%",y:"44%"},stop:ie.words[oe].stop.add(z),start:ie.words[oe].start.add(z)}))}}}ge([l()],St.prototype,"generatorOptions"),ge([l()],St.prototype,"type");var Gi=Object.defineProperty,ye=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Gi(C,A,I),I};class Ft extends w{constructor(A={}){var z;super();we(this,"generatorOptions");we(this,"type","SOLAR");this.generatorOptions=(z=A.generatorOptions)!=null?z:{duration:[.2]}}async applyTo(A){var K,te,ne,ie;if(!((K=A.clip)!=null&&K.transcript)||!((te=A.composition)!=null&&te.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=await R.fromFamily({family:"Urbanist",weight:"800"}).load(),I=(ie=(ne=A.clip)==null?void 0:ne.offset)!=null?ie:new h,L=new GlowFilter({color:"#fffe41",alpha:.25,distance:90,quality:.05});for(const oe of A.clip.transcript.iter(this.generatorOptions))await A.add(new _({text:oe.words.map(ue=>ue.text).join(" "),textAlign:"center",textBaseline:"middle",fontSize:19,fillStyle:"#fffe41",font:z,maxWidth:A.composition.width*.85,textCase:"upper",shadow:{color:"#ab7a00",blur:0,distance:2.1,angle:Math.PI/2.5,alpha:1},position:"center",stop:oe.stop.add(I),start:oe.start.add(I),scale:new b([0,8],[.96,1],{easing:"easeOut"}),alpha:new b([0,4],[0,1],{easing:"easeOut"}),filters:L}))}}ye([l()],Ft.prototype,"generatorOptions"),ye([l()],Ft.prototype,"type");var Xi=Object.defineProperty,Gt=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Xi(C,A,I),I};class ht extends w{constructor(A={}){var z,I;super();we(this,"generatorOptions");we(this,"type","WHISPER");we(this,"color");this.generatorOptions=(z=A.generatorOptions)!=null?z:{length:[20]},this.color=(I=A.color)!=null?I:"#8c8c8c"}async applyTo(A){var L,K,te,ne;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"Montserrat",weight:"300"}).load();for(const ie of A.clip.transcript.iter(this.generatorOptions))for(let oe=0;oe<ie.words.length;oe++){const ue=ie.words.map(de=>de.text);await A.add(new M({text:ue.join(" "),textAlign:"center",textBaseline:"middle",fillStyle:"#FFFFFF",fontSize:13,background:{alpha:.3,padding:{x:50,y:30}},maxWidth:A.composition.width*.8,font:I,position:"center",styles:[{fillStyle:this.color}],stop:ie.words[oe].stop.add(z),start:ie.words[oe].start.add(z),segments:ue.length>1?[{index:0,start:ue.slice(0,oe+1).join(" ").length}]:void 0}))}}}Gt([l()],ht.prototype,"generatorOptions"),Gt([l()],ht.prototype,"type"),Gt([l()],ht.prototype,"color");var Ui=Object.defineProperty,Xt=(O,C,A,z)=>{for(var I=void 0,L=O.length-1,K;L>=0;L--)(K=O[L])&&(I=K(C,A,I)||I);return I&&Ui(C,A,I),I};class Ut extends w{constructor(A={}){var z,I;super();we(this,"type","VERDANT");we(this,"generatorOptions");we(this,"color");this.generatorOptions=(z=A.generatorOptions)!=null?z:{duration:[1]},this.color=(I=A.color)!=null?I:"#69E34C"}async applyTo(A){var L,K,te,ne;if(!((L=A.clip)!=null&&L.transcript)||!((K=A.composition)!=null&&K.width))throw new Error("Captions need to be applied with a defined transcript and composition");const z=(ne=(te=A.clip)==null?void 0:te.offset)!=null?ne:new h,I=await R.fromFamily({family:"Montserrat",weight:"800"}).load();for(const ie of A.clip.transcript.iter(this.generatorOptions))for(let oe=0;oe<ie.words.length;oe++){const ue=ie.words.map(de=>de.text);await A.add(new M({text:ue.join(" "),textAlign:"center",textBaseline:"middle",fontSize:15,fillStyle:"#FFFFFF",shadow:{color:"#000000",blur:4,alpha:.7,angle:Math.PI/4,distance:2},stroke:{width:3,color:"#000000"},maxWidth:A.composition.width*.5,leading:1.1,font:I,textCase:"upper",styles:[{fillStyle:this.color,fontSize:19}],position:"center",stop:ie.words[oe].stop.add(z),start:ie.words[oe].start.add(z),segments:[{index:0,start:ue.slice(0,oe).join(" ").length,stop:ue.slice(0,oe+1).join(" ").length}]}))}}}Xt([l()],Ut.prototype,"type"),Xt([l()],Ut.prototype,"generatorOptions"),Xt([l()],Ut.prototype,"color");class as{constructor(C,A){we(this,"canvas");we(this,"muxer");we(this,"videoEncoder");we(this,"audioEncoder");we(this,"onready");we(this,"frame",0);we(this,"sampleRate");we(this,"numberOfChannels");we(this,"videoBitrate");we(this,"gpuBatchSize");we(this,"fps");we(this,"height");we(this,"width");we(this,"encodedAudio",!1);var z,I,L,K,te;this.canvas=C,this.width=C.width,this.height=C.height,this.fps=(z=A==null?void 0:A.fps)!=null?z:30,this.sampleRate=(I=A==null?void 0:A.sampleRate)!=null?I:44100,this.numberOfChannels=(L=A==null?void 0:A.numberOfChannels)!=null?L:2,this.videoBitrate=(K=A==null?void 0:A.videoBitrate)!=null?K:1e7,this.gpuBatchSize=(te=A==null?void 0:A.gpuBatchSize)!=null?te:5,this.init()}async init(){var I;const[C,A]=await Kt({video:{height:Math.round(this.height),width:Math.round(this.width),bitrate:this.videoBitrate,fps:this.fps},audio:{sampleRate:this.sampleRate,numberOfChannels:this.numberOfChannels,bitrate:128e3}});this.muxer=new Muxer({target:new ArrayBufferTarget,video:{...C,codec:"avc"},firstTimestampBehavior:"offset",fastStart:"in-memory",audio:{...A,codec:A.codec=="opus"?"opus":"aac"}});const z={output:(L,K)=>{K&&this.muxer.addVideoChunk(L,K)},error:console.error};this.videoEncoder=new VideoEncoder(z),this.videoEncoder.configure(C),this.audioEncoder=new AudioEncoder({output:(L,K)=>{var te;K&&((te=this.muxer)==null||te.addAudioChunk(L,K))},error:console.error}),this.audioEncoder.configure(A),(I=this.onready)==null||I.call(this)}async encodeVideo(C){var z;this.videoEncoder||await this.ready(),this.videoEncoder.encodeQueueSize>this.gpuBatchSize&&await new Promise(I=>{this.videoEncoder.ondequeue=()=>I(null)});const A=new VideoFrame(C!=null?C:this.canvas,{timestamp:Math.floor(this.frame/this.fps*1e6),duration:Math.floor(1e6/this.fps)});(z=this.videoEncoder)==null||z.encode(A,{keyFrame:this.frame%(3*this.fps)==0}),A.close(),this.frame++}async encodeAudio(C){var A;this.audioEncoder||await this.ready(),(C.sampleRate!=this.sampleRate||C.numberOfChannels!=this.numberOfChannels)&&(C=Ue(C,this.sampleRate,this.numberOfChannels)),(A=this.audioEncoder)==null||A.encode(new AudioData({format:"f32-planar",sampleRate:C.sampleRate,numberOfChannels:C.numberOfChannels,numberOfFrames:C.length,timestamp:0,data:Dt(C)})),this.encodedAudio=!0}async export(){var A,z,I,L;if(!this.encodedAudio){const K=[this.numberOfChannels,1,this.sampleRate],te=new OfflineAudioContext(...K);await this.encodeAudio(te.createBuffer(...K))}await((A=this.videoEncoder)==null?void 0:A.flush()),await((z=this.audioEncoder)==null?void 0:z.flush()),(I=this.muxer)==null||I.finalize();const C=(L=this.muxer)==null?void 0:L.target.buffer;if(!C)throw new Qt({i18n:"unexpectedEncoderError",message:"Muxer could not be finalized because the target buffer is not defined"});return new Blob([C],{type:"video/mp4"})}async ready(){await new Promise(C=>{this.onready=()=>C()})}}function autoBufferSize(O,C){let A=O,z=C,I=1,L=1;for(;O*C>16e5;)O>C?O=A/++I:C=z/++L;return{x:O,y:C}}function humanReadableTime(O){const C=Math.floor(O%1e3),A=Math.floor(O/1e3%60),z=Math.floor(A/60%60),I=Math.floor(z/60);return`${I>0?`${I}h `:""}${z>0?`${z}m `:""}${A>0?`${A}s `:""}${C>0?`${C%1e3}ms`:""}`}class PathTracer{constructor(C=new __SDF("cube()"),A=new ColorBackground(new THREE__namespace.Color("white"))){we(this,"textures",[]);we(this,"shader");we(this,"_background");we(this,"_sdf");we(this,"pixelDivisions",1);we(this,"roughness",1);we(this,"sunDirection",new THREE__namespace.Vector3(-.5,-2,-1));we(this,"sunStrength",1);we(this,"backgroundMultiplier",1);we(this,"rayDepth",5);we(this,"epsilon",1e-6);we(this,"bufferSize");we(this,"lastImage",null);we(this,"color",new THREE__namespace.Color(1,1,1));we(this,"step");const z=new THREE__namespace.Vector2;renderer.getSize(z),this.textures=[new THREE__namespace.WebGLRenderTarget(z.x,z.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),new THREE__namespace.WebGLRenderTarget(z.x,z.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})],this._sdf=C,this._background=A,this.step=this._sdf.stepCount,this.shader=this.initShader()}set sdf(C){this._sdf=C,this.step=C.stepCount,this.shader.fragmentShader=core+pathTracer+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}set background(C){this.shader.fragmentShader=core+pathTracer+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0,this._background=C}get sdf(){return this._sdf}get background(){return this._background}initShader(){return createShader(core+pathTracer+this._sdf.glsl+this._background.glsl,{previousFrame:{value:this.textures[0].texture},sampleIndex:{value:0},offset:{value:new THREE__namespace.Vector2(0,0)},size:{value:new THREE__namespace.Vector2(0,0)},adaptiveEpsilon:{value:!1},time:{value:0},...Utils.createUniformsFromVariables(this,"sunDirection","sunStrength","roughness","rayDepth","pixelDivisions","color","epsilon","backgroundMultiplier","step"),...Utils.objectToUniforms(this._background,"bg_")})}renderImage(C,A,z=0){const I=this.bufferSize?{x:this.bufferSize,y:this.bufferSize}:autoBufferSize(C,A),L=performance.now();return new Promise((K,te)=>{setAutoResize(!1),setResolution(C,A);const ne=new THREE__namespace.Vector2(C,A),ie=new THREE__namespace.Vector2(this.textures[0].texture.image.width,this.textures[0].texture.image.height);ne.equals(ie)||(this.textures[0].dispose(),this.textures[1].dispose(),this.textures=[new THREE__namespace.WebGLRenderTarget(ne.x,ne.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),new THREE__namespace.WebGLRenderTarget(ne.x,ne.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})]),renderer.setRenderTarget(this.textures[0]),renderer.clear(),renderer.setRenderTarget(this.textures[1]),renderer.clear(),Utils.setUniformsFromObject(this.shader,this.background,"bg_");const oe=Math.ceil(C/I.x),ue=Math.ceil(A/I.y);let de=0,he=0,fe=0;const be=()=>{document.visibilityState==="hidden"?console.log("Render task paused"):console.log("Render task resumed")},xe=setInterval(()=>{document.addEventListener("visibilitychange",be),document.visibilityState==="visible"&&console.log(`Render task: ${Math.floor(fe/(this.pixelDivisions*this.pixelDivisions)*100)}%`)},1e3);Queue.loop(()=>{if(this.shader.uniforms.adaptiveEpsilon.value=!1,this.shader.uniforms.previousFrame.value=this.textures[1].texture,this.shader.uniforms.sampleIndex.value=fe,this.shader.uniforms.offset.value=new THREE__namespace.Vector2(de*I.x,he*I.y),this.shader.uniforms.size.value=new THREE__namespace.Vector2(I.x,I.y),this.shader.uniforms.time.value=z,Utils.setUniformsFromVariables(this.shader,this,"sunDirection","sunStrength","roughness","rayDepth","pixelDivisions","color","epsilon","backgroundMultiplier","step"),render(this.shader,this.textures[0]),new TemporaryImage(this.textures[0]).postprocess("sRGB").show(),this.textures=[this.textures[1],this.textures[0]],++de,de>=oe&&(de=0,++he),he>=ue&&(he=0,fe+=1),fe>=this.pixelDivisions*this.pixelDivisions){const Se=performance.now()-L;console.log("Render task: 100%"),console.log(`Rendering done in ${humanReadableTime(Se)}`),console.log(`Render Size: ${Math.floor(this.pixelDivisions*this.pixelDivisions*C*A/1e5)/10} megapixels`),console.log(`Render Speed: ${Math.floor(this.pixelDivisions*this.pixelDivisions*C*A/Se/10)/100} megapixels per second`),Queue.cancel()}},()=>{clearInterval(xe),document.removeEventListener("visibilitychange",be),this.lastImage=new TemporaryImage(this.textures[1]).postprocess("sRGB"),fe>=this.pixelDivisions*this.pixelDivisions?K(this.lastImage):te(new Error("Render task cancelled"))})})}async renderAnimationDiffusion(C,A,z,I=[]){const L=new OffscreenCanvas(C,A),K=new as(L,{fps:30});await K.encodeAudio(new AudioBuffer({length:44100,numberOfChannels:2,sampleRate:44100}));for(let oe=0;oe<z.length;oe++){const ue=z[oe];camera.position.copy(ue.position),camera.lookAt(ue.position.clone().add(ue.direction)),(await this.renderImage(C,A,ue.time)).postprocess(...I).show(),L.getContext("2d").drawImage(renderer.domElement,0,0,C,A),await K.encodeVideo(L),console.log(`Frame ${oe+1}/${z.length} done`)}const te=await K.export();console.log("encoded");const ne=URL.createObjectURL(te),ie=document.createElement("a");ie.href=ne,ie.download="video.mp4",ie.click(),URL.revokeObjectURL(ne)}async renderAnimation(C,A,z,I){const L=[],K=[];function te(){const ie=`${ne}-${ne+L.length-1}.json`;downloadJSON(L,ie),K.push(ie),ne+=L.length,L.length=0}let ne=1;for(let ie=0;ie<z.length;ie++){L.length===50&&te();const oe=z[ie];camera.position.copy(oe.position),camera.lookAt(oe.position.clone().add(oe.direction)),(await this.renderImage(C,A,oe.time)).postprocess(...I).show(),L.push(renderer.domElement.toDataURL()),console.log(`Frame ${ie+1}/${z.length} done`)}te(),downloadJSON({files:K,totalFrames:z.length},"header.json")}}class Menger extends __SDF{constructor(C){super(`
      cube();
      for (let i = 0; i < ${C}; i++) {
          scale(1 / 3);
          translate(0, 0, -1 / 3);
          mirror(0, 0, 1);
          translate(0, 0, 1 / 3);

          translate(-2 / 3, 2 / 3, 0);

          mirror(0, -1, 1);
          mirror(1, 0, 1);
          mirror(0, 0, -1);
          mirror(1, 0, 0);
          mirror(0, -1, 0);
      }
    `),this.iterations=C}}class Sierpinski extends __SDF{constructor(C){super(`
        tetrahedron();

        for (let i = 0; i < ${C}; i++) {
            translate(-1, -1, -1);
            
            scale(1 / 2);
            
            translate(1, 1, 1);
        }
    `),this.iterations=C}}var position=`vec3 shading() {\r
    return pixelRaycast().position;\r
}`,normal=`vec3 shading() {\r
    return pixelRaycast().normal;\r
}`,edges=`uniform sampler2D positionTexture;\r
uniform sampler2D normalTexture;

uniform vec3 backgroundColor;\r
uniform vec3 lineColor;

struct Pixel {\r
    vec3 position;\r
    vec3 normal;\r
};

Pixel pixel(int x, int y) {\r
    vec2 uv = (gl_FragCoord.xy + vec2(x, y)) / resolution;

    Pixel pixel;\r
    pixel.position = texture2D(positionTexture, uv).xyz;\r
    pixel.normal = texture2D(normalTexture, uv).xyz;

    return pixel;\r
}

vec3 shading() {\r
    

    Pixel center = pixel(0, 0);

    float distanceFromCamera = length(center.position - cameraPos);

    if(distanceFromCamera < 2.0 * epsilon) return backgroundColor; 

    bool edge = false;

    for(int x = 0; x <= 1; ++x) {\r
        for(int y = 0; y <= 1; ++y) {\r
            Pixel nearby = pixel(x, y);

            float dist = length(nearby.position - center.position);\r
            vec3 towards = normalize(nearby.position - center.position);

            if(\r
                dot(center.normal, nearby.normal) < 0.5 && center.normal != vec3(0)||\r
                abs(dot(center.normal, towards)) > max(distanceFromCamera * 0.3, 0.1) && dist > 2.0 * epsilon ||\r
                center.normal == vec3(0) && nearby.normal != vec3(0)\r
            )\r
                edge = true;\r
        }\r
    }

    \r
    return edge ? lineColor : backgroundColor;\r
}`,expandLines=`uniform float lineWidth;\r
uniform vec3 lineColor;\r
uniform vec3 backgroundColor;\r
uniform sampler2D linesTexture;

vec3 pixel(int x, int y) {\r
    return texture2D(linesTexture, (gl_FragCoord.xy + vec2(x, y)) / resolution).xyz;\r
}

vec3 shading() {\r
    float radius = max(0.0, (min(lineWidth, 10.0) - 1.0) * 0.5);\r
    int grid = int(ceil(radius));

    for(int x = -grid; x <= grid; ++x) {\r
        for(int y = -grid; y <= grid; ++y) {\r
            if(sqrt(float(x * x + y * y)) <= radius && pixel(x, y) == lineColor) {\r
                return lineColor;\r
            } \r
        }\r
    }\r
    return backgroundColor;\r
}`;class EdgeRenderer{constructor(C=new __SDF("cube()")){we(this,"positionShader");we(this,"normalShader");we(this,"edgesShader");we(this,"expandShader");we(this,"position");we(this,"normal");we(this,"edges");we(this,"expanded");we(this,"_sdf");we(this,"step");we(this,"epsilon",1e-5);we(this,"backgroundColor",new THREE__namespace.Color(1,1,1));we(this,"lineColor",new THREE__namespace.Color(0,0,0));we(this,"lineWidth",1);const A=new THREE__namespace.Vector2;renderer.getSize(A),this.position=new THREE__namespace.WebGLRenderTarget(A.x,A.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(A.x,A.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(A.x,A.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(A.x,A.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this._sdf=C,this.step=C.stepCount;const z={epsilon:{value:this.epsilon},step:{value:this.step}};this.positionShader=createShader(core+position+C.glsl,z),this.normalShader=createShader(core+normal+C.glsl,z),this.edgesShader=createShader(core+edges+C.glsl,{...Utils.createUniformsFromVariables(this,"backgroundColor","lineColor"),positionTexture:{value:this.position.texture},normalTexture:{value:this.normal.texture}}),this.expandShader=createShader(core+expandLines+C.glsl,{...Utils.createUniformsFromVariables(this,"backgroundColor","lineColor","lineWidth"),linesTexture:{value:this.edges.texture}})}set sdf(C){this._sdf=C,this.step=C.stepCount,this.positionShader.fragmentShader=core+position+this._sdf.glsl,this.normalShader.fragmentShader=core+normal+this._sdf.glsl,this.positionShader.needsUpdate=!0,this.normalShader.needsUpdate=!0}setUniforms(C){C.uniforms.epsilon.value=this.epsilon,C.uniforms.step.value=this.step}renderImage(C,A){return new Promise(z=>{Queue.once(()=>{setAutoResize(!1),setResolution(C,A);const I=new THREE__namespace.Vector2(C,A),L=new THREE__namespace.Vector2(this.position.texture.image.width,this.position.texture.image.height);I.equals(L)||(this.position.dispose(),this.normal.dispose(),this.edges.dispose(),this.expanded.dispose(),this.position=new THREE__namespace.WebGLRenderTarget(I.x,I.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(I.x,I.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(I.x,I.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(I.x,I.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),this.setUniforms(this.positionShader),render(this.positionShader,this.position),this.setUniforms(this.normalShader),render(this.normalShader,this.normal),this.edgesShader.uniforms.positionTexture.value=this.position.texture,this.edgesShader.uniforms.normalTexture.value=this.normal.texture,Utils.setUniformsFromVariables(this.edgesShader,this,"backgroundColor","lineColor"),render(this.edgesShader,this.edges),this.expandShader.uniforms.linesTexture.value=this.edges.texture,Utils.setUniformsFromVariables(this.expandShader,this,"backgroundColor","lineColor","lineWidth"),render(this.expandShader,this.expanded),copyAA(this.expanded,null),z()})})}start(){setAutoResize(!0),Queue.loop(()=>{const C=new THREE__namespace.Vector2;renderer.getSize(C);const A=new THREE__namespace.Vector2(this.position.texture.image.width,this.position.texture.image.height);if(!C.equals(A)){this.position.dispose(),this.normal.dispose(),this.edges.dispose(),this.expanded.dispose();const z=Math.floor(C.x),I=Math.floor(C.y);this.position=new THREE__namespace.WebGLRenderTarget(z,I,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(z,I,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(z,I,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(z,I,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})}this.setUniforms(this.positionShader),render(this.positionShader,this.position),this.setUniforms(this.normalShader),render(this.normalShader,this.normal),this.edgesShader.uniforms.positionTexture.value=this.position.texture,this.edgesShader.uniforms.normalTexture.value=this.normal.texture,Utils.setUniformsFromVariables(this.edgesShader,this,"backgroundColor","lineColor"),render(this.edgesShader,this.edges),this.expandShader.uniforms.linesTexture.value=this.edges.texture,Utils.setUniformsFromVariables(this.expandShader,this,"backgroundColor","lineColor","lineWidth"),render(this.expandShader,this.expanded),copyAA(this.expanded,null)})}}extensions.add(AccessibilitySystem),Container.mixin(accessibilityTarget),extensions.add(ResizePlugin),extensions.add(TickerPlugin),extensions.add(EventSystem),Container.mixin(FederatedContainer),extensions.add(GraphicsPipe),extensions.add(GraphicsContextSystem),extensions.add(MeshPipe),extensions.add(CanvasTextSystem),extensions.add(CanvasTextPipe),extensions.add(BitmapTextPipe),extensions.add(HTMLTextSystem),extensions.add(HTMLTextPipe),extensions.add(TilingSpritePipe),extensions.add(NineSliceSpritePipe),extensions.add(FilterSystem),extensions.add(FilterPipe);var browserAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"})),webworkerAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));exports.ColorBackground=ColorBackground,exports.EdgeRenderer=EdgeRenderer,exports.HemisphereBackground=HemisphereBackground,exports.ImageBackground=ImageBackground,exports.Menger=Menger,exports.PathTracer=PathTracer,exports.Queue=Queue,exports.RealtimeRenderer=RealtimeRenderer,exports.SDF=__SDF,exports.Sierpinski=Sierpinski,exports.camera=camera,exports.controls=controls,exports.fullscreen=fullscreen,exports.init=init$1,Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
