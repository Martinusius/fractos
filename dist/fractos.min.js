var ye=Object.defineProperty,Se=Object.defineProperties;var we=Object.getOwnPropertyDescriptors;var ie=Object.getOwnPropertySymbols;var Ae=Object.prototype.hasOwnProperty,Re=Object.prototype.propertyIsEnumerable;var U=(f,o,e)=>o in f?ye(f,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[o]=e,R=(f,o)=>{for(var e in o||(o={}))Ae.call(o,e)&&U(f,e,o[e]);if(ie)for(var e of ie(o))Re.call(o,e)&&U(f,e,o[e]);return f},W=(f,o)=>Se(f,we(o));var i=(f,o,e)=>(U(f,typeof o!="symbol"?o+"":o,e),e);(function(f,o){typeof exports=="object"&&typeof module!="undefined"?o(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],o):(f=typeof globalThis!="undefined"?globalThis:f||self,o(f.Fractos={},f.THREE))})(this,function(exports,THREE){"use strict";function _interopNamespace(o){if(o&&o.__esModule)return o;var e={__proto__:null,[Symbol.toStringTag]:"Module"};return o&&Object.keys(o).forEach(function(r){if(r!=="default"){var t=Object.getOwnPropertyDescriptor(o,r);Object.defineProperty(e,r,t.get?t:{enumerable:!0,get:function(){return o[r]}})}}),e.default=o,Object.freeze(e)}var THREE__namespace=_interopNamespace(THREE),colorBackground=`uniform vec3 bg_color;

vec3 background(vec3 direction) {
    return bg_color;
}`,hemisphereBackground=`uniform vec3 bg_top;
uniform vec3 bg_bottom;
uniform float bg_blendAngle;

vec3 background(vec3 direction) {
    float angle = atan(direction.y / length(direction.xz));
    return mix(bg_bottom, bg_top, clamp((angle + bg_blendAngle) / 2.0 / bg_blendAngle, 0.0, 1.0));
}`,imageBackground=`uniform samplerCube bg_image;

vec3 background(vec3 direction) {
    return texture(bg_image, direction).xyz;
}`;class Background{}class ColorBackground extends Background{constructor(e){super();i(this,"glsl",colorBackground);i(this,"color");this.color=e}}class HemisphereBackground extends Background{constructor(e,r,t=.1){super();i(this,"glsl",hemisphereBackground);i(this,"top");i(this,"bottom");i(this,"blendAngle");this.top=e,this.bottom=r,this.blendAngle=t}}class ImageBackground extends Background{constructor(e){super();i(this,"glsl",imageBackground);i(this,"image");this.image=e}}const _changeEvent={type:"change"},_startEvent={type:"start"},_endEvent={type:"end"};class OrbitControls extends THREE.EventDispatcher{constructor(e,r){super();r===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),r===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=r,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(n){n.addEventListener("keydown",te),this._domElementKeyEvents=n},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(_changeEvent),t.update(),s=a.NONE},this.update=function(){const n=new THREE.Vector3,l=new THREE.Quaternion().setFromUnitVectors(e.up,new THREE.Vector3(0,1,0)),m=l.clone().invert(),x=new THREE.Vector3,D=new THREE.Quaternion,O=2*Math.PI;return function(){const se=t.object.position;n.copy(se).sub(t.target),n.applyQuaternion(l),c.setFromVector3(n),t.autoRotate&&s===a.NONE&&F(ce()),t.enableDamping?(c.theta+=h.theta*t.dampingFactor,c.phi+=h.phi*t.dampingFactor):(c.theta+=h.theta,c.phi+=h.phi);let w=t.minAzimuthAngle,A=t.maxAzimuthAngle;return isFinite(w)&&isFinite(A)&&(w<-Math.PI?w+=O:w>Math.PI&&(w-=O),A<-Math.PI?A+=O:A>Math.PI&&(A-=O),w<=A?c.theta=Math.max(w,Math.min(A,c.theta)):c.theta=c.theta>(w+A)/2?Math.max(w,c.theta):Math.min(A,c.theta)),c.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=u,c.radius=Math.max(t.minDistance,Math.min(t.maxDistance,c.radius)),t.enableDamping===!0?t.target.addScaledVector(p,t.dampingFactor):t.target.add(p),n.setFromSpherical(c),n.applyQuaternion(m),se.copy(t.target).add(n),t.object.lookAt(t.target),t.enableDamping===!0?(h.theta*=1-t.dampingFactor,h.phi*=1-t.dampingFactor,p.multiplyScalar(1-t.dampingFactor)):(h.set(0,0,0),p.set(0,0,0)),u=1,v||x.distanceToSquared(t.object.position)>d||8*(1-D.dot(t.object.quaternion))>d?(t.dispatchEvent(_changeEvent),x.copy(t.object.position),D.copy(t.object.quaternion),v=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",ae),t.domElement.removeEventListener("pointerdown",$),t.domElement.removeEventListener("wheel",ee),t.domElement.removeEventListener("touchstart",ne),t.domElement.removeEventListener("touchend",oe),t.domElement.removeEventListener("touchmove",re),t.domElement.ownerDocument.removeEventListener("pointermove",N),t.domElement.ownerDocument.removeEventListener("pointerup",B),t._domElementKeyEvents!==null&&t._domElementKeyEvents.removeEventListener("keydown",te)};const t=this,a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=a.NONE;const d=1e-6,c=new THREE.Spherical,h=new THREE.Spherical;let u=1;const p=new THREE.Vector3;let v=!1;const g=new THREE.Vector2,b=new THREE.Vector2,E=new THREE.Vector2,T=new THREE.Vector2,y=new THREE.Vector2,S=new THREE.Vector2,z=new THREE.Vector2,H=new THREE.Vector2,L=new THREE.Vector2;function ce(){return 2*Math.PI/60/60*t.autoRotateSpeed}function C(){return Math.pow(.95,t.zoomSpeed)}function F(n){h.theta-=n}function k(n){h.phi-=n}const I=function(){const n=new THREE.Vector3;return function(m,x){n.setFromMatrixColumn(x,0),n.multiplyScalar(-m),p.add(n)}}(),G=function(){const n=new THREE.Vector3;return function(m,x){t.screenSpacePanning===!0?n.setFromMatrixColumn(x,1):(n.setFromMatrixColumn(x,0),n.crossVectors(t.object.up,n)),n.multiplyScalar(m),p.add(n)}}(),M=function(){const n=new THREE.Vector3;return function(m,x){const D=t.domElement;if(t.object.isPerspectiveCamera){const O=t.object.position;n.copy(O).sub(t.target);let P=n.length();P*=Math.tan(t.object.fov/2*Math.PI/180),I(2*m*P/D.clientHeight,t.object.matrix),G(2*x*P/D.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(I(m*(t.object.right-t.object.left)/t.object.zoom/D.clientWidth,t.object.matrix),G(x*(t.object.top-t.object.bottom)/t.object.zoom/D.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function j(n){t.object.isPerspectiveCamera?u/=n:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom*n)),t.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function X(n){t.object.isPerspectiveCamera?u*=n:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/n)),t.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function V(n){g.set(n.clientX,n.clientY)}function le(n){z.set(n.clientX,n.clientY)}function q(n){T.set(n.clientX,n.clientY)}function de(n){b.set(n.clientX,n.clientY),E.subVectors(b,g).multiplyScalar(t.rotateSpeed);const l=t.domElement;F(2*Math.PI*E.x/l.clientHeight),k(2*Math.PI*E.y/l.clientHeight),g.copy(b),t.update()}function ue(n){H.set(n.clientX,n.clientY),L.subVectors(H,z),L.y>0?j(C()):L.y<0&&X(C()),z.copy(H),t.update()}function fe(n){y.set(n.clientX,n.clientY),S.subVectors(y,T).multiplyScalar(t.panSpeed),M(S.x,S.y),T.copy(y),t.update()}function he(n){n.deltaY<0?X(C()):n.deltaY>0&&j(C()),t.update()}function me(n){let l=!1;switch(n.code){case t.keys.UP:M(0,t.keyPanSpeed),l=!0;break;case t.keys.BOTTOM:M(0,-t.keyPanSpeed),l=!0;break;case t.keys.LEFT:M(t.keyPanSpeed,0),l=!0;break;case t.keys.RIGHT:M(-t.keyPanSpeed,0),l=!0;break}l&&(n.preventDefault(),t.update())}function Y(n){if(n.touches.length==1)g.set(n.touches[0].pageX,n.touches[0].pageY);else{const l=.5*(n.touches[0].pageX+n.touches[1].pageX),m=.5*(n.touches[0].pageY+n.touches[1].pageY);g.set(l,m)}}function K(n){if(n.touches.length==1)T.set(n.touches[0].pageX,n.touches[0].pageY);else{const l=.5*(n.touches[0].pageX+n.touches[1].pageX),m=.5*(n.touches[0].pageY+n.touches[1].pageY);T.set(l,m)}}function Z(n){const l=n.touches[0].pageX-n.touches[1].pageX,m=n.touches[0].pageY-n.touches[1].pageY,x=Math.sqrt(l*l+m*m);z.set(0,x)}function pe(n){t.enableZoom&&Z(n),t.enablePan&&K(n)}function xe(n){t.enableZoom&&Z(n),t.enableRotate&&Y(n)}function Q(n){if(n.touches.length==1)b.set(n.touches[0].pageX,n.touches[0].pageY);else{const m=.5*(n.touches[0].pageX+n.touches[1].pageX),x=.5*(n.touches[0].pageY+n.touches[1].pageY);b.set(m,x)}E.subVectors(b,g).multiplyScalar(t.rotateSpeed);const l=t.domElement;F(2*Math.PI*E.x/l.clientHeight),k(2*Math.PI*E.y/l.clientHeight),g.copy(b)}function J(n){if(n.touches.length==1)y.set(n.touches[0].pageX,n.touches[0].pageY);else{const l=.5*(n.touches[0].pageX+n.touches[1].pageX),m=.5*(n.touches[0].pageY+n.touches[1].pageY);y.set(l,m)}S.subVectors(y,T).multiplyScalar(t.panSpeed),M(S.x,S.y),T.copy(y)}function _(n){const l=n.touches[0].pageX-n.touches[1].pageX,m=n.touches[0].pageY-n.touches[1].pageY,x=Math.sqrt(l*l+m*m);H.set(0,x),L.set(0,Math.pow(H.y/z.y,t.zoomSpeed)),j(L.y),z.copy(H)}function ge(n){t.enableZoom&&_(n),t.enablePan&&J(n)}function ve(n){t.enableZoom&&_(n),t.enableRotate&&Q(n)}function $(n){if(t.enabled!==!1)switch(n.pointerType){case"mouse":case"pen":be(n);break}}function N(n){if(t.enabled!==!1)switch(n.pointerType){case"mouse":case"pen":Ee(n);break}}function B(n){switch(n.pointerType){case"mouse":case"pen":Te();break}}function be(n){n.preventDefault(),t.domElement.focus?t.domElement.focus():window.focus();let l;switch(n.button){case 0:l=t.mouseButtons.LEFT;break;case 1:l=t.mouseButtons.MIDDLE;break;case 2:l=t.mouseButtons.RIGHT;break;default:l=-1}switch(l){case THREE.MOUSE.DOLLY:if(t.enableZoom===!1)return;le(n),s=a.DOLLY;break;case THREE.MOUSE.ROTATE:if(n.ctrlKey||n.metaKey||n.shiftKey){if(t.enablePan===!1)return;q(n),s=a.PAN}else{if(t.enableRotate===!1)return;V(n),s=a.ROTATE}break;case THREE.MOUSE.PAN:if(n.ctrlKey||n.metaKey||n.shiftKey){if(t.enableRotate===!1)return;V(n),s=a.ROTATE}else{if(t.enablePan===!1)return;q(n),s=a.PAN}break;default:s=a.NONE}s!==a.NONE&&(t.domElement.ownerDocument.addEventListener("pointermove",N),t.domElement.ownerDocument.addEventListener("pointerup",B),t.dispatchEvent(_startEvent))}function Ee(n){if(t.enabled!==!1)switch(n.preventDefault(),s){case a.ROTATE:if(t.enableRotate===!1)return;de(n);break;case a.DOLLY:if(t.enableZoom===!1)return;ue(n);break;case a.PAN:if(t.enablePan===!1)return;fe(n);break}}function Te(n){t.domElement.ownerDocument.removeEventListener("pointermove",N),t.domElement.ownerDocument.removeEventListener("pointerup",B),t.enabled!==!1&&(t.dispatchEvent(_endEvent),s=a.NONE)}function ee(n){t.enabled===!1||t.enableZoom===!1||s!==a.NONE&&s!==a.ROTATE||(n.preventDefault(),t.dispatchEvent(_startEvent),he(n),t.dispatchEvent(_endEvent))}function te(n){t.enabled===!1||t.enablePan===!1||me(n)}function ne(n){if(t.enabled!==!1){switch(n.preventDefault(),n.touches.length){case 1:switch(t.touches.ONE){case THREE.TOUCH.ROTATE:if(t.enableRotate===!1)return;Y(n),s=a.TOUCH_ROTATE;break;case THREE.TOUCH.PAN:if(t.enablePan===!1)return;K(n),s=a.TOUCH_PAN;break;default:s=a.NONE}break;case 2:switch(t.touches.TWO){case THREE.TOUCH.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;pe(n),s=a.TOUCH_DOLLY_PAN;break;case THREE.TOUCH.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;xe(n),s=a.TOUCH_DOLLY_ROTATE;break;default:s=a.NONE}break;default:s=a.NONE}s!==a.NONE&&t.dispatchEvent(_startEvent)}}function re(n){if(t.enabled!==!1)switch(n.preventDefault(),s){case a.TOUCH_ROTATE:if(t.enableRotate===!1)return;Q(n),t.update();break;case a.TOUCH_PAN:if(t.enablePan===!1)return;J(n),t.update();break;case a.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;ge(n),t.update();break;case a.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ve(n),t.update();break;default:s=a.NONE}}function oe(n){t.enabled!==!1&&(t.dispatchEvent(_endEvent),s=a.NONE)}function ae(n){t.enabled!==!1&&n.preventDefault()}t.domElement.addEventListener("contextmenu",ae),t.domElement.addEventListener("pointerdown",$),t.domElement.addEventListener("wheel",ee,{passive:!1}),t.domElement.addEventListener("touchstart",ne,{passive:!1}),t.domElement.addEventListener("touchend",oe),t.domElement.addEventListener("touchmove",re,{passive:!1}),this.update()}}var CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`};class Pass{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const _camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),_geometry$1=new THREE.BufferGeometry;_geometry$1.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),_geometry$1.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2));class FullScreenQuad{constructor(e){this._mesh=new THREE.Mesh(_geometry$1,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,_camera)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class ShaderPass extends Pass{constructor(e,r){super();this.textureID=r!==void 0?r:"tDiffuse",e instanceof THREE.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=THREE.UniformsUtils.clone(e.uniforms),this.material=new THREE.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new FullScreenQuad(this.material)}render(e,r,t){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=t.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}class MaskPass extends Pass{constructor(e,r){super();this.scene=e,this.camera=r,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,r,t){const a=e.getContext(),s=e.state;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0);let d,c;this.inverse?(d=0,c=1):(d=1,c=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),s.buffers.stencil.setFunc(a.ALWAYS,d,4294967295),s.buffers.stencil.setClear(c),s.buffers.stencil.setLocked(!0),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(a.EQUAL,1,4294967295),s.buffers.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),s.buffers.stencil.setLocked(!0)}}class ClearMaskPass extends Pass{constructor(){super();this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class EffectComposer{constructor(e,r){if(this.renderer=e,r===void 0){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},a=e.getSize(new THREE.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=a.width,this._height=a.height,r=new THREE.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,t),r.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=r.width,this._height=r.height;this.renderTarget1=r,this.renderTarget2=r.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],CopyShader===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),ShaderPass===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new ShaderPass(CopyShader),this.clock=new THREE.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,r){this.passes.splice(r,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const r=this.passes.indexOf(e);r!==-1&&this.passes.splice(r,1)}isLastEnabledPass(e){for(let r=e+1;r<this.passes.length;r++)if(this.passes[r].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const r=this.renderer.getRenderTarget();let t=!1;for(let a=0,s=this.passes.length;a<s;a++){const d=this.passes[a];if(d.enabled!==!1){if(d.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(a),d.render(this.renderer,this.writeBuffer,this.readBuffer,e,t),d.needsSwap){if(t){const c=this.renderer.getContext(),h=this.renderer.state.buffers.stencil;h.setFunc(c.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),h.setFunc(c.EQUAL,1,4294967295)}this.swapBuffers()}MaskPass!==void 0&&(d instanceof MaskPass?t=!0:d instanceof ClearMaskPass&&(t=!1))}}this.renderer.setRenderTarget(r)}reset(e){if(e===void 0){const r=this.renderer.getSize(new THREE.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=r.width,this._height=r.height,e=this.renderTarget1.clone(),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,r){this._width=e,this._height=r;const t=this._width*this._pixelRatio,a=this._height*this._pixelRatio;this.renderTarget1.setSize(t,a),this.renderTarget2.setSize(t,a);for(let s=0;s<this.passes.length;s++)this.passes[s].setSize(t,a)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new THREE.OrthographicCamera(-1,1,1,-1,0,1);const _geometry=new THREE.BufferGeometry;_geometry.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),_geometry.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2));class RenderPass extends Pass{constructor(e,r,t,a,s){super();this.scene=e,this.camera=r,this.overrideMaterial=t,this.clearColor=a,this.clearAlpha=s!==void 0?s:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new THREE.Color}render(e,r,t){const a=e.autoClear;e.autoClear=!1;let s,d;this.overrideMaterial!==void 0&&(d=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),s=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,s),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=d),e.autoClear=a}}const SMAAEdgesShader={defines:{SMAA_THRESHOLD:"0.1"},uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`},SMAAWeightsShader={defines:{SMAA_MAX_SEARCH_STEPS:"8",SMAA_AREATEX_MAX_DISTANCE:"16",SMAA_AREATEX_PIXEL_SIZE:"( 1.0 / vec2( 160.0, 560.0 ) )",SMAA_AREATEX_SUBTEX_SIZE:"( 1.0 / 7.0 )"},uniforms:{tDiffuse:{value:null},tArea:{value:null},tSearch:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`},SMAABlendShader={uniforms:{tDiffuse:{value:null},tColor:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:`

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`};class SMAAPass extends Pass{constructor(e,r){super();this.edgesRT=new THREE.WebGLRenderTarget(e,r,{depthBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBFormat}),this.edgesRT.texture.name="SMAAPass.edges",this.weightsRT=new THREE.WebGLRenderTarget(e,r,{depthBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.weightsRT.texture.name="SMAAPass.weights";const t=this,a=new Image;a.src=this.getAreaTexture(),a.onload=function(){t.areaTexture.needsUpdate=!0},this.areaTexture=new THREE.Texture,this.areaTexture.name="SMAAPass.area",this.areaTexture.image=a,this.areaTexture.format=THREE.RGBFormat,this.areaTexture.minFilter=THREE.LinearFilter,this.areaTexture.generateMipmaps=!1,this.areaTexture.flipY=!1;const s=new Image;s.src=this.getSearchTexture(),s.onload=function(){t.searchTexture.needsUpdate=!0},this.searchTexture=new THREE.Texture,this.searchTexture.name="SMAAPass.search",this.searchTexture.image=s,this.searchTexture.magFilter=THREE.NearestFilter,this.searchTexture.minFilter=THREE.NearestFilter,this.searchTexture.generateMipmaps=!1,this.searchTexture.flipY=!1,SMAAEdgesShader===void 0&&console.error("THREE.SMAAPass relies on SMAAShader"),this.uniformsEdges=THREE.UniformsUtils.clone(SMAAEdgesShader.uniforms),this.uniformsEdges.resolution.value.set(1/e,1/r),this.materialEdges=new THREE.ShaderMaterial({defines:Object.assign({},SMAAEdgesShader.defines),uniforms:this.uniformsEdges,vertexShader:SMAAEdgesShader.vertexShader,fragmentShader:SMAAEdgesShader.fragmentShader}),this.uniformsWeights=THREE.UniformsUtils.clone(SMAAWeightsShader.uniforms),this.uniformsWeights.resolution.value.set(1/e,1/r),this.uniformsWeights.tDiffuse.value=this.edgesRT.texture,this.uniformsWeights.tArea.value=this.areaTexture,this.uniformsWeights.tSearch.value=this.searchTexture,this.materialWeights=new THREE.ShaderMaterial({defines:Object.assign({},SMAAWeightsShader.defines),uniforms:this.uniformsWeights,vertexShader:SMAAWeightsShader.vertexShader,fragmentShader:SMAAWeightsShader.fragmentShader}),this.uniformsBlend=THREE.UniformsUtils.clone(SMAABlendShader.uniforms),this.uniformsBlend.resolution.value.set(1/e,1/r),this.uniformsBlend.tDiffuse.value=this.weightsRT.texture,this.materialBlend=new THREE.ShaderMaterial({uniforms:this.uniformsBlend,vertexShader:SMAABlendShader.vertexShader,fragmentShader:SMAABlendShader.fragmentShader}),this.needsSwap=!1,this.fsQuad=new FullScreenQuad(null)}render(e,r,t){this.uniformsEdges.tDiffuse.value=t.texture,this.fsQuad.material=this.materialEdges,e.setRenderTarget(this.edgesRT),this.clear&&e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialWeights,e.setRenderTarget(this.weightsRT),this.clear&&e.clear(),this.fsQuad.render(e),this.uniformsBlend.tColor.value=t.texture,this.fsQuad.material=this.materialBlend,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(r),this.clear&&e.clear(),this.fsQuad.render(e))}setSize(e,r){this.edgesRT.setSize(e,r),this.weightsRT.setSize(e,r),this.materialEdges.uniforms.resolution.value.set(1/e,1/r),this.materialWeights.uniforms.resolution.value.set(1/e,1/r),this.materialBlend.uniforms.resolution.value.set(1/e,1/r)}getAreaTexture(){return"data:image/png;base64,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"}getSearchTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="}}const renderer=new THREE__namespace.WebGLRenderer({antialias:!1,preserveDrawingBuffer:!0,powerPreference:"high-performance"}),screenSize=new THREE__namespace.Vector2;renderer.extensions.get("EXT_color_buffer_float");let element;function init(o){return element=document.querySelector(o),element?(renderer.setSize(element.clientWidth,element.clientHeight),element.appendChild(renderer.domElement),renderer.domElement.style.position="absolute",new ResizeObserver(()=>{if(!element)return;screenSize.set(element.clientWidth-1,element.clientHeight-1);const r=new THREE__namespace.Vector2;renderer.getSize(r);const t=Math.max(r.x/screenSize.x,r.y/screenSize.y);renderer.domElement.style.width=r.x/t+"px",renderer.domElement.style.height=r.y/t+"px"}).observe(element),renderer.domElement):void 0}function fullscreen(){init("body"),document.body.style.width="100%",document.body.style.height="100%",document.body.style.margin="0",document.body.style.overflow="hidden",document.documentElement.style.width="100%",document.documentElement.style.height="100%",document.documentElement.style.margin="0",document.documentElement.style.overflow="hidden"}function setResolution(o,e,r=!0){if(renderer.setSize(o,e),effectsComposer.setSize(o,e),camera.aspect=o/e,camera.updateProjectionMatrix(),!r)return;const t=Math.max(o/screenSize.x,e/screenSize.y);renderer.domElement.style.width=o/t+"px",renderer.domElement.style.height=e/t+"px"}const quadScene=new THREE__namespace.Scene,ortho=new THREE__namespace.OrthographicCamera(-1,1,1,-1,0,1),camera=new THREE__namespace.PerspectiveCamera(90,document.body.clientWidth/document.body.clientHeight,.01,10);camera.position.set(2,2,2),camera.lookAt(new THREE__namespace.Vector3(0,0,0));const controls=new OrbitControls(camera,renderer.domElement),quad=new THREE__namespace.Mesh(new THREE__namespace.PlaneBufferGeometry(2,2,1,1));quadScene.add(quad);function setShader(o){quad.material=o}function createShader(o,e={}){const r=new THREE__namespace.ShaderMaterial({uniforms:R({resolution:{value:new THREE__namespace.Vector2},cameraPos:{value:new THREE__namespace.Vector3},cameraDirection:{value:new THREE__namespace.Vector3},fov:{value:0},modelView:{value:new THREE__namespace.Matrix4},projection:{value:new THREE__namespace.Matrix4}},e),vertexShader:`void main(){
gl_Position = vec4(position, 1.0);
}
`,fragmentShader:o});return setShader(r),r}const effectsComposer=new EffectComposer(renderer);effectsComposer.addPass(new RenderPass(quadScene,ortho)),effectsComposer.addPass(new SMAAPass(document.body.clientWidth,document.body.clientHeight));function render(o,e=null){quad.material=o,renderer.setRenderTarget(e),renderer.getSize(quad.material.uniforms.resolution.value),quad.material.uniforms.cameraPos.value.copy(camera.position),camera.getWorldDirection(quad.material.uniforms.cameraDirection.value),quad.material.uniforms.fov.value=camera.fov/180*Math.PI,quad.material.uniforms.projection.value=camera.projectionMatrix,renderer.render(quadScene,ortho)}function renderAA(o,e=null){quad.material=o,renderer.setRenderTarget(e),renderer.getSize(quad.material.uniforms.resolution.value),quad.material.uniforms.cameraPos.value.copy(camera.position),camera.getWorldDirection(quad.material.uniforms.cameraDirection.value),quad.material.uniforms.fov.value=camera.fov/180*Math.PI,quad.material.uniforms.projection.value=camera.projectionMatrix,effectsComposer.render()}class Utils{static objectToUniforms(e,r=""){const t={};for(const[a,s]of Object.entries(e))s instanceof Array||(t[r+a]={value:s});return t}static setUniformsFromObject(e,r,t=""){for(const[a,s]of Object.entries(r))s instanceof Array||(e.uniforms[t+a]={value:s})}static createUniformsFromVariables(e,...r){const t={};return r.forEach(a=>{t[a]={value:e[a]}}),t}static setUniformsFromVariables(e,r,...t){t.forEach(a=>{e.uniforms[a].value=r[a]})}}new THREE__namespace.Scene;var functions=`const _ANIMATION = "clamp(step - (steps -= 1.0), 0.0, 1.0)";\r
const _STEPS = [];

function float(arg) {\r
  return String(arg).replace(/(?<![a-zA-Z\\.\\d])(\\d+)(?![\\.\\d])/g, "$1.0");\r
}

function isNumber(n) {\r
  return !isNaN(parseFloat(n)) && isFinite(n);\r
}

/*function union(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Union: Radius must be a number");\r
  if (radius < 0) throw new Error("Union: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length === 1) throw new Error("Intersection requires at least 2 objects");\r
  if (objects.length === 2) return radius > 0 ? \`smoothUnion(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`_union(\${objects[0]}, \${objects[1]})\`;

  const [firstObject, ...otherObjects] = objects;

  if (otherObjects.length === 0) return firstObject;

  return _VERIFY + (radius > 0 ? \`smoothUnion(\${firstObject}, \${union(otherObjects)}, \${float(radius)} / data.s)\` : \`_union(\${firstObject}, \${union(otherObjects)})\`);\r
}

function intersection(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Intersection: Radius must be a number");\r
  if (radius < 0) throw new Error("Intersection: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length === 1) throw new Error("Intersection requires at least 2 objects");\r
  if (objects.length === 2) return radius > 0 ? \`smoothIntersection(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`intersection(\${objects[0]}, \${objects[1]})\`;

  const [firstObject, ...otherObjects] = objkects;

  if (otherObjects.length === 0) return firstObject;

  return _VERIFY + (radius > 0 ? \`smoothIntersection(\${firstObject}, \${intersection(otherObjects)}, \${float(radius)} / data.s)\` : \`intersection(\${firstObject}, \${intersection(otherObjects)})\`);\r
}

function difference(objects, radius = 0) {\r
  if (!isNumber(radius)) throw new Error("Difference: Radius must be a number");\r
  if (radius < 0) throw new Error("Difference: Radius must be greater than or equal to 0");

  const invalid = objects.findIndex((object) => typeof object !== "string" || !object.startsWith(_VERIFY));

  if (invalid !== -1) {\r
    throw new Error("Union: Invalid object at index \${invalid}");\r
  }

  if (objects.length !== 2) throw new Error("Difference requires exactly 2 objects");

  return _VERIFY + (radius > 0 ? \`smoothDifference(\${objects[0]}, \${objects[1]}, \${float(radius)} / data.s)\` : \`difference(\${objects[0]}, \${objects[1]})\`);\r
}*/

function shape(u) {\r
  _STEPS.push(\`dist = min(dist, \${u})\`);\r
}

function sphere(properties = {}) {\r
  properties.radius = properties.radius ?? 1;

  shape(\`sphere(data.z, \${float(properties.radius)}) * data.s\`);\r
}

function tetrahedron(properties = {}) {\r
  properties.radius = properties.radius ?? 1;

  shape(\`tetrahedron(data.z, \${float(properties.radius)}) * data.s\`);\r
}

function box(properties = {}) {\r
  properties.size = properties.size ?? [1, 1, 1];

  shape(\`box(data.z, vec3(\${properties.size\r
    .map((coord) => \`\${float(coord)}\`)\r
    .join(", ")})) * data.s\`);\r
}

function cube(properties = {}) {\r
  properties.center = properties.center ?? [0, 0, 0];\r
  properties.size = properties.size ?? 1;

  box({ center: properties.center, size: [properties.size, properties.size, properties.size] });\r
}

function torus(properties = {}) {\r
  properties.center = properties.center ?? [0, 0, 0];\r
  properties.radius = properties.radius ?? 1;\r
  properties.tube = properties.tube ?? 0.25;

  shape(\`torus(data.z, vec2(\${float(properties.radius)}, \${float(properties.tube)})) * data.s\`);\r
}

function scale(value) {\r
  if(arguments.length !== 1) throw new Error("Scale: Requires 1 argument");

  _STEPS.push(\`scale(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translate(x, y, z) {\r
  if(arguments.length !== 3) throw new Error("Translate: Requires 3 arguments");

  _STEPS.push(\`translate(data, \${float(x)}, \${float(y)}, \${float(z)}, \${_ANIMATION})\`);\r
}

function translateX(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateX: Requires 1 argument");

  _STEPS.push(\`translateX(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translateY(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateY: Requires 1 argument");

  _STEPS.push(\`translateY(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function translateZ(value) {\r
  if(arguments.length !== 1) throw new Error("TranslateZ: Requires 1 argument");

  _STEPS.push(\`translateZ(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateX(value) {\r
  if(arguments.length !== 1) throw new Error("RotateX: Requires 1 argument");

  _STEPS.push(\`rotateX(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateY(value) {\r
  if(arguments.length !== 1) throw new Error("RotateY: Requires 1 argument");

  _STEPS.push(\`rotateY(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function rotateZ(value) {\r
  if(arguments.length !== 1) throw new Error("RotateZ: Requires 1 argument");

  _STEPS.push(\`rotateZ(data, \${float(value)}, \${_ANIMATION})\`);\r
}

function mirror(nx, ny, nz) {\r
  if(arguments.length !== 3) throw new Error("Mirror: Requires 3 arguments");

  const s = Math.sqrt(nx * nx + ny * ny + nz * nz);

  _STEPS.push(\`mirror(data, \${float(nx / s)}, \${float(ny / s)}, \${float(nz / s)}, \${_ANIMATION})\`);\r
}

function mirrorUp() {\r
  mirror(0, 1, 0);\r
}

function mirrorDown() {\r
  mirror(0, -1, 0);\r
}

function mirrorLeft() {\r
  mirror(-1, 0, 0);\r
}

function mirrorRight() {\r
  mirror(1, 0, 0);\r
}

function mirrorFront() {\r
  mirror(0, 0, 1);\r
}

function mirrorBack() {\r
  mirror(0, 0, -1);\r
}`;let getRandomValues;const rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto!="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}const byteToHex=[];for(let o=0;o<256;++o)byteToHex.push((o+256).toString(16).slice(1));function unsafeStringify(o,e=0){return(byteToHex[o[e+0]]+byteToHex[o[e+1]]+byteToHex[o[e+2]]+byteToHex[o[e+3]]+"-"+byteToHex[o[e+4]]+byteToHex[o[e+5]]+"-"+byteToHex[o[e+6]]+byteToHex[o[e+7]]+"-"+byteToHex[o[e+8]]+byteToHex[o[e+9]]+"-"+byteToHex[o[e+10]]+byteToHex[o[e+11]]+byteToHex[o[e+12]]+byteToHex[o[e+13]]+byteToHex[o[e+14]]+byteToHex[o[e+15]]).toLowerCase()}const randomUUID=typeof crypto!="undefined"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var native={randomUUID};function v4(o,e,r){if(native.randomUUID&&!e&&!o)return native.randomUUID();o=o||{};const t=o.random||(o.rng||rng)();if(t[6]=t[6]&15|64,t[8]=t[8]&63|128,e){r=r||0;for(let a=0;a<16;++a)e[r+a]=t[a];return e}return unsafeStringify(t)}function limitEval(o,e,r){let t=Math.random()+1,a=new Blob(["onmessage=function(a){a=a.data;postMessage({i:a.i+1});postMessage({r:eval.call(this,a.c),i:a.i});};"],{type:"text/javascript"}),s=new Worker(URL.createObjectURL(a));function d(c){URL.revokeObjectURL(a),e(c)}s.onmessage=function(c){c=c.data,c&&(c.i===t?(t=0,d(c.r)):c.i===t+1&&setTimeout(function(){t&&(s.terminate(),d(void 0))},r||1e3))},s.postMessage({c:o,i:t})}function iteratize(o){const e={},r=[];let t=0,a="";o.forEach(u=>{e[u]===void 0&&(e[u]=t++,r.push(u)),a+=String.fromCharCode(e[u]+65)});function s(u){let p="";for(let v=0;v<u.length;v++)u[v]==="@"?p+="@":p+=r[u.charCodeAt(v)-65]+`
`;return p}let d;for(let u=32;u>1;u--){const p=a.match(new RegExp(`(.+)(?=\\1{${u}})`,"g"));if(p){const v=s(a.replace(new RegExp(`(${p[0]}){${u+1}}`,"g"),"@")),g=v4();d=v.replace("@",`/* BEGIN ITERATION ${g} */ for(int i = 0; i < ${u+1}; i++) {
${s(p[0])}
} /* END ITERATION ${g} */
`);break}}const c=d!==void 0;d||(d=s(a));const h=d.split(`
`);return{success:c,steps:h.slice(0,h.length-1)}}class UncompiledSDF{constructor(e){this.instructions=e}}class __SDF{constructor(code=""){i(this,"glsl");i(this,"stepCount");code instanceof Function&&(code=__SDF.stripFunction(code));const steps=code instanceof UncompiledSDF?code.instructions.reverse():eval(`${functions} ;; ${code} ;;  _STEPS`).reverse();let iteratization={success:!0,steps};for(;(iteratization=iteratize(iteratization.steps)).success;);this.stepCount=iteratization.steps.length,this.glsl=`
    
    uniform int iterations;
    uniform float step;

    float sdf(vec3 z) {
      SDF data = SDF(z, 1.0);

      float dist = 1000.0;

      float steps = ${iteratization.steps.length}.0;
      
      ${iteratization.steps.join(`;
`)+`;
`}

      return dist;
    }`}static stripFunction(o){const e=o.toString();return e.slice(e.indexOf("{")+1,e.lastIndexOf("}"))}static createInSandbox(o){return o instanceof Function&&(o=__SDF.stripFunction(o)),new Promise(e=>{limitEval(`${functions} ;; ${o} ;;  _STEPS`,r=>{e(new __SDF(new UncompiledSDF(r)))},100)})}}var simple=`uniform vec3 sunDirection;\r
uniform vec3 sunColor;\r
uniform float aoStrength;\r
uniform bool enableShadows;\r
uniform float roughness;

uniform vec3 color;

float calculateDirectLight(vec3 position, vec3 normal, float epsilon) {\r
    if(enableShadows) {\r
        Ray shadowRay = raycastEpsilon(position + normal * 2.0 * epsilon, -sunDirection, epsilon);\r
        return shadowRay.hit ? 0.0 : max(dot(normal, -sunDirection), 0.0);\r
    }\r
    else {\r
        return max(dot(normal, -sunDirection), 0.0);\r
    }\r
}\r

float statixAO(vec3 p, vec3 n, float k, float delta) {\r
    float sum = 0.0;\r
    for(int i = 1; i <= 5; ++i) {\r
        float fi = float(i);\r
        sum += pow(2.0, -fi) * (fi * delta - sdf(p + n * fi * delta));\r
    }\r
    return 1.0 - k * sum;\r
}

/*float tracerAO(vec3 position, vec3 normal, float epsilon) {

    float luminance = 1.0;

    for(int i = 0; i < 5; ++i) {\r
        Ray tracer = raycastEpsilon(position + normal * 2.0 * epsilon, normal, epsilon);

        if(!tracer.hit) break;

        luminance *= 0.5;\r
        position = tracer.position;\r
        normal = normalize(tracer.normal);\r
    }

    return luminance;\r
    

}*/

uniform int pixelDivisions;

vec3 shading() {\r
    vec3 total = vec3(0);

    for(int x = 0; x < pixelDivisions; x++) {\r
        for(int y = 0; y < pixelDivisions; y++) {\r
            seed = subpixelCoord(x, y, pixelDivisions);\r
            vec3 rayDirection = subpixelDirection(x, x, pixelDivisions);

            Ray ray = raycast(cameraPos, rayDirection);

            if(ray.hit) {\r
                if(ray.steps == 0.0) {\r
                    return vec3(0);\r
                }

                const int samples = 4;\r
                vec3 backgroundAverage = vec3(0);\r
                float lerpFactor = roughness * roughness;

                vec3 reflected = reflect(ray.direction, ray.normal);

                for(int i = 0; i < samples; ++i)  {\r
                    vec3 random = normalize(rand3() * 2.0 - 1.0); 
                    backgroundAverage += linear(background(normalize(mix(reflected, random, lerpFactor)))) * mix(max(dot(reflected, ray.normal), 0.0), 1.0, lerpFactor);\r
                }

                vec3 scolor = linear(color);\r

                vec3 indirect = (backgroundAverage / float(samples)) * scolor * pow(ray.steps, -0.6);\r
                vec3 direct = calculateDirectLight(ray.position, ray.normal, ray.epsilon) * scolor;\r
            \r
                total += indirect + direct;\r
            }\r
            else {\r
                total += background(ray.direction);\r
            }\r
        }\r
    }

    return total / float(pixelDivisions * pixelDivisions);\r
    \r
    
    \r
    \r
}`;let autoResize=!1;function setAutoResize(o){autoResize=o}const f=class{static loop(e,r=()=>{}){f.cleanup(),f.callback=e,f.cleanup=r}static cancel(){f.callback=()=>{},f.cleanup(),f.cleanup=()=>{}}static once(e){f.callback=()=>{e(),this.callback=()=>{}}}};let Queue=f;i(Queue,"callback",()=>{}),i(Queue,"cleanup",()=>{});function animator(){requestAnimationFrame(animator);const o=new THREE__namespace.Vector2;renderer.getSize(o),autoResize&&!screenSize.equals(o)&&setResolution(screenSize.x,screenSize.y,!1),Queue.callback()}animator();var _core=`uniform vec2 resolution;\r
uniform vec3 cameraPos;\r
uniform vec3 cameraDirection;\r
uniform float fov;\r
uniform float time;

uniform bool adaptiveEpsilon;\r
uniform float epsilonScale;\r
uniform float epsilon;

const float PI = 3.1415926535897932384626433832795;\r
const float DEG_TO_RAD = PI / 180.0;\r

const int maximumRaySteps = 16536;

float sdf(vec3 position);\r
vec3 background(vec3 direction);

vec3 calculateNormal(vec3 position, float minDist) {\r
    vec2 h = vec2(minDist, 0.0);\r
    return normalize(vec3(sdf(position + h.xyy) - sdf(position - h.xyy),\r
                           sdf(position + h.yxy) - sdf(position - h.yxy),\r
                           sdf(position + h.yyx) - sdf(position - h.yyx)));\r
}

vec3 trap;

vec2 seed = vec2(0);\r
float rand() { \r
    seed += vec2(-0.1, 0.1);\r
    return fract(sin(dot(seed, vec2(12.9898, 4.1414))) * 43758.5453);\r
}

vec2 rand2() {\r
    return vec2(rand(), rand());\r
}

vec3 rand3() {\r
    return vec3(rand(), rand(), rand());\r
}

vec3 sphericalRand() {\r
    float z = rand() * 2.0 - 1.0;\r
    float rxy = sqrt(1.0 - z * z);\r
    float phi = rand() * 2.0 * PI;\r
    float x = rxy * cos(phi);\r
    float y = rxy * sin(phi);

    return vec3(x, y, z);\r
}\r

struct Ray {\r
    vec3 origin;\r
    vec3 direction;

    float closest;

    vec3 closestPoint;

    bool hit;\r
    vec3 position;\r
    vec3 normal;\r
    float steps;

    float epsilon;\r
};

mat3 cameraMatrix(vec3 direction) {\r
    vec3 cw = direction;\r
    vec3 cp = vec3(0.0, 1.0, 0.0);\r
    vec3 cu = normalize(cross(cw, cp));\r
    vec3 cv = cross(cu, cw);\r
    return mat3(cu, cv, cw);\r
}

vec2 subpixelCoord(int x, int y, int divisions) {\r
    float subpixelSize = 1.0 / float(divisions);\r
    vec2 offset = vec2(subpixelSize * (float(x) + 0.5) - 0.5, subpixelSize * (float(y) + 0.5) - 0.5);\r
    return gl_FragCoord.xy + offset;\r
}

vec3 subpixelDirection(int x, int y, int divisions) {\r
    mat3 view = cameraMatrix(cameraDirection);\r
    vec2 uv = (subpixelCoord(x, y, divisions) / resolution) * 2.0 - 1.0;\r
    uv.x *= resolution.x / resolution.y;\r
    return view * normalize(vec3(uv, 1.0 / tan(fov / 2.0)));\r
}\r

vec3 pixelDirection() {\r
    mat3 view = cameraMatrix(cameraDirection);\r
    vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;\r
    uv.x *= resolution.x / resolution.y;\r
    return view * normalize(vec3(uv, 1.0 / tan(fov / 2.0)));\r
}

vec2 directionPixel(vec3 position, vec3 cameraPos, vec3 cameraDir) {\r
    mat3 inverseView = inverse(cameraMatrix(cameraDir));\r
    vec3 toPos = normalize(position - cameraPos);\r
    vec3 fromCameraDir = inverseView * toPos;

    float zDistance = 1.0 / tan(fov / 2.0);\r
    vec2 uv = (fromCameraDir * zDistance / fromCameraDir.z).xy;\r
    uv /= resolution.x / resolution.y;\r
    return (uv + 1.0) / 2.0;\r
}\r

/*uniform int orbitSampler;\r
uniform int orbitMapping;

vec3 sampleOrbit(vec3 a, vec3 b) {\r
    switch (orbitSampler) {\r
    case 0:\r
        return min(a, b);\r
    case 1:\r
        return max(a, b);\r
    case 2:\r
        return a + b;\r
    case 3:\r
        return min(abs(a), abs(b));\r
    case 4:\r
        return max(abs(a), abs(b));\r
    case 5:\r
        return abs(a) + abs(b);\r
    }\r
}

float mapOrbit(float x) {\r
    switch (orbitMapping) {\r
    case 0:\r
        return 1.0 / 3.0;\r
    case 1:\r
        return x;\r
    case 2:\r
        return 1.0 / (1.0 + pow(2.71828182846, -x));\r
    case 3:\r
        return x / (x + 1.0);\r
    }\r
}

vec3 mapToChannels(vec3 color1, vec3 color2, vec3 color3, vec3 map) {\r
    return (mapOrbit(map.x) * color1 + mapOrbit(map.y) * color2 + mapOrbit(map.z) * color3);\r
}*/\r

Ray raycast(vec3 origin, vec3 direction) {\r
    Ray data;\r
    data.origin = origin;\r
    data.direction = direction;

    if(!adaptiveEpsilon)\r
        data.epsilon = epsilon;

    float totalDistance = 0.0;\r
    float closest = 100.0;\r
    float closestT = 0.0;

    for (int steps = 0; steps < maximumRaySteps; ++steps) {\r
        vec3 currentPosition = origin + totalDistance * direction;

        if(totalDistance > 100.0)\r
            break;

        float currentDistance = sdf(currentPosition);

        if(currentDistance < closest) {\r
            closest = currentDistance;\r
            closestT = totalDistance;\r
        }

        
        totalDistance += max(0.0, (steps < 1 ? rand() * currentDistance : currentDistance));

        if(steps == 0) {\r
            if(currentDistance < 0.0) {\r
                data.hit = true;\r
                data.position = origin;\r
                data.normal = vec3(0);\r
                data.steps = 0.0;\r
                data.closest = 0.0;\r
                data.closestPoint = data.position;

                return data;\r
            }

            if(adaptiveEpsilon)\r
                data.epsilon = currentDistance * epsilonScale;\r
        }\r
        else if(currentDistance < data.epsilon) {\r
            data.hit = true;\r
            data.position = origin + totalDistance * direction;\r
            data.normal = calculateNormal(data.position, data.epsilon);\r
            data.steps = float(steps) + currentDistance / data.epsilon;\r
            data.closest = 0.0;\r
            data.closestPoint = data.position;

            return data;\r
        }\r
    }

    float l = closestT - closest;\r
    float r = closestT + closest;

    for(int i = 0; i < 10; i++) {\r
        float ld = sdf(origin + l * direction);\r
        float rd = sdf(origin + r * direction);

        if(ld < rd) {\r
            r = (l + r) / 2.0;\r
        }\r
        else {\r
            l = (l + r) / 2.0;\r
        }\r
    }

    data.closestPoint = origin + (l + r) / 2.0 * direction;

    data.closest = sdf(origin + (l + r) / 2.0 * direction);\r
    data.hit = false;\r
    return data;\r
}

float linear(float x) {\r
    if (x <= 0.04045)\r
        return x / 12.92;\r
    else\r
        return pow((x + 0.055) / 1.055, 2.4);\r
}

vec3 linear(vec3 color) {\r
    return vec3(linear(color.r), linear(color.g), linear(color.b));\r
}

Ray raycastEpsilon(vec3 origin, vec3 direction, float epsilon) {\r
    Ray data;\r
    data.origin = origin;\r
    data.direction = direction;\r
    data.epsilon = epsilon;

    float totalDistance = 0.0;\r
      float closest = 100.0;\r
    for (int steps = 0; steps < maximumRaySteps; ++steps) {\r
        vec3 currentPosition = origin + totalDistance * direction;

        if(totalDistance > 100.0)\r
            break;

        float currentDistance = sdf(currentPosition);\r
        closest = min(closest, currentDistance);

        
        totalDistance += max(0.0, (steps < 1 ? rand() * currentDistance : currentDistance));

        if(steps == 0) {\r
            if(currentDistance < 0.0) {\r
                data.hit = true;\r
                data.position = origin;\r
                data.normal = vec3(0);\r
                data.steps = 0.0;

                return data;\r
            }

        }\r
        else if(currentDistance < data.epsilon) {\r
            data.hit = true;\r
            data.position = origin + totalDistance * direction;\r
            data.normal = calculateNormal(data.position, data.epsilon);\r
            data.steps = float(steps) + currentDistance / data.epsilon;

            return data;\r
        }\r
    }

    data.closest = closest;\r
    data.hit = false;\r
    return data;\r
}

Ray pixelRaycast() {\r
    return raycast(cameraPos, pixelDirection());\r
}\r

vec3 shading();

void main() {        \r
    gl_FragColor = vec4(shading(), 1);\r
}`,primitives=`float smoothUnion( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r
    return mix( d2, d1, h ) - k*h*(1.0-h); }

float smoothDifference( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\r
    return mix( d1, -d2, h ) + k*h*(1.0-h);\r
}

float smoothIntersection( float d1, float d2, float k ) {\r
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\r
    return mix( d2, d1, h ) + k*h*(1.0-h);\r
}

float _union(float a, float b) {\r
    return min(a, b);\r
}

float difference(float a, float b) {\r
    return max(a, -b);\r
}

float intersection(float a, float b) {\r
    return max(a, b);\r
}

mat4 rotationMatrix(vec3 axis, float angle) {\r
    axis = normalize(axis);\r
    float s = sin(angle);\r
    float c = cos(angle);\r
    float oc = 1.0 - c;\r
    \r
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r
                0.0,                                0.0,                                0.0,                                1.0);\r
}\r

float between(float a, float b) {\r
    return mix(a, b, mod(time, 1.0));\r
}

vec3 between(vec3 a, vec3 b) {\r
    return mix(a, b, mod(time, 1.0));\r
}\r

float sphere(vec3 p, float r) {\r
    return length(p) - r;\r
}

float box(vec3 p, vec3 b) {\r
    vec3 q = abs(p) - b;\r
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\r
}

float cube(vec3 p, float b) {\r
    return box(p, vec3(b));\r
}

float torus(vec3 p, vec2 t){\r
  vec2 q = vec2(length(p.xz)-t.x,p.y);\r
  return length(q)-t.y;\r
}\r

float tetrahedron(vec3 p, float r) {\r
    float md = max(max(-p.x + p.y - p.z, p.x - p.y - p.z),\r
              max(-p.x - p.y + p.z, p.x + p.y + p.z));\r
    return (md - r) / sqrt(3.0);\r
}

float octahedron(vec3 p, float s) {\r
    p = abs(p);\r
    float m = p.x + p.y + p.z - s;\r
    vec3 q;\r
        if(3.0 * p.x < m) q = p.xyz;\r
    else if(3.0 * p.y < m) q = p.yzx;\r
    else if(3.0 * p.z < m) q = p.zxy;\r
    else return m*0.57735027;\r
        \r
    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s); \r
    return length(vec3(q.x, q.y - s + k, q.z - k)); \r
}\r

struct SDF {\r
    vec3 z;\r
    float s;\r
};

void translate(inout SDF sdf, float x, float y, float z, float animation) {\r
    sdf.z += animation * vec3(x, -y, z);\r
}

void translateX(inout SDF sdf, float x, float animation) {\r
    sdf.z.x += animation * x;\r
}

void translateY(inout SDF sdf, float y, float animation) {\r
    sdf.z.y -= animation * y;\r
}

void translateZ(inout SDF sdf, float z, float animation) {\r
    sdf.z.z += animation * z;\r
}

void scale(inout SDF sdf, float v, float animation) {\r
    sdf.z /= mix(1.0, v, animation);\r
    sdf.s *= mix(1.0, v, animation);\r
}

void mirror(inout SDF sdf, float x, float y, float z, float animation) {\r
    vec3 n = vec3(x, -y, z);

    float d = min(0.0, dot(sdf.z, n));\r
    sdf.z = sdf.z - animation * 2.0 * d * n;\r
}

void rotateX(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(1, 0, 0), angle * DEG_TO_RAD * animation)).xyz;\r
}\r
void rotateY(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(0, 1, 0), angle * DEG_TO_RAD * animation)).xyz;\r
}\r
void rotateZ(inout SDF sdf, float angle, float animation) {\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(vec3(0, 0, 1), angle * DEG_TO_RAD * animation)).xyz;\r
}

void rotate(inout SDF sdf, float ax, float ay, float az, float angle, float animation) {\r
    vec3 a = normalize(vec3(ax, ay, az));\r
    sdf.z = (vec4(sdf.z, 1) * rotationMatrix(a, angle * DEG_TO_RAD * animation)).xyz;\r
}`;const core=_core+primitives;var postprocess=`uniform vec2 resolution;
uniform sampler2D data;

vec3 reinhard(vec3 x) {
    return x / (1.0 + x);
}

vec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {
    float l0 = ((P - m) * l) / a;
    float L0 = m - m / a;
    float L1 = m + (1.0 - m) / a;
    float S0 = m + l0;
    float S1 = m + a * l0;
    float C2 = (a * P) / (P - S1);
    float CP = -C2 / P;

    vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));
    vec3 w2 = vec3(step(m + l0, x));
    vec3 w1 = vec3(1.0 - w0 - w2);

    vec3 T = vec3(m * pow(x / m, vec3(c)) + b);
    vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));
    vec3 L = vec3(m + a * (x - m));

    return T * w0 + L * w1 + S * w2;
}

vec3 uchimura(vec3 x) {
    const float P = 1.0;  
    const float a = 1.0;  
    const float m = 0.22; 
    const float l = 0.4;  
    const float c = 1.33; 
    const float b = 0.0;  

    return uchimura(x, P, a, m, l, c, b);
}

vec3 aces(vec3 x) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

vec3 contrast(vec3 color, float contrast) {
    return (color - 0.5) * max(contrast, 0.0) + 0.5;
}

vec3 brightness(vec3 color, float brightness) {
    return color * max(brightness, 0.0);
}

vec3 add(vec3 color, float r, float g, float b) {
    return color + vec3(r, g, b);
}

vec3 add(vec3 color, float l) {
    return color + l;
}

vec3 filmic(vec3 x) {
    vec3 X = max(vec3(0.0), x - 0.004);
    vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
    return pow(result, vec3(2.2));
}

vec3 vignette(vec3 color, float radius, float smoothness) {
    vec2 uv = gl_FragCoord.xy / resolution.xy;

    float diff = radius - distance(uv, vec2(0.5, 0.5));
    return color * smoothstep(-smoothness, smoothness, diff);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 saturation(vec3 color, float saturation) {
    if(color.r == color.g && color.r == color.b) return color;
    vec3 hsv = rgb2hsv(color);
    hsv.y *= saturation;
    return hsv2rgb(hsv); 
}

float sRGB(float x) {
    if (x <= 0.00031308)
        return 12.92 * x;
    else
        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;
}

vec3 sRGB(vec3 c) {
    return vec3(sRGB(c.x), sRGB(c.y), sRGB(c.z));
}

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 color = texture2D(data, uv).xyz;

    POSTPROCESS

    gl_FragColor = vec4(color, 1);
}`,copyGLSL=`uniform vec2 resolution;
uniform sampler2D data;

void main() {
    gl_FragColor = texture(data, gl_FragCoord.xy / resolution);
}`;const copyShader=createShader(copyGLSL,{data:{value:null}});function copyAA(o,e){o instanceof THREE__namespace.WebGLRenderTarget&&(o=o.texture),copyShader.uniforms.data.value=o,renderAA(copyShader,e)}function downloadCanvas(o){const e=document.createElement("a");e.download=o,e.href=renderer.domElement.toDataURL(),e.click(),e.remove()}function downloadJSON(o,e){const r=document.createElement("a");r.href="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(o)),r.download=e,r.click(),r.remove()}class TemporaryImage{constructor(e){i(this,"texture");i(this,"postprocessing",[]);e instanceof THREE__namespace.WebGLRenderTarget&&(e=e.texture),this.texture=e}postprocess(...e){return this.postprocessing.push(...e),this}renderToScreen(){const e=["reinhard","filmic","aces","uchimura","contrast","brightness","saturation","vignette","add","sRGB"],r=this.postprocessing.map(a=>{if(!a.trim())return"// Empty postprocessing step";const s=a.match(/(.*)\((.*)\)/),d=s?s[1]:a;if(!e.includes(d))throw new Error(`Invalid postprocessing step: ${a}`);return a=a.replace(/([^a-zA-Z\.\d])(\d+)([^\.\d])/g,"$1$2.0$3"),s?s[2].trim()===""?"color = "+a.replace(/\(/,"(color")+";":"color = "+a.replace(/\(/,"(color, ")+";":`color = ${a}(color);`}),t=createShader(postprocess.replace(/POSTPROCESS/,r.join(`
`)),{data:{value:this.texture}});render(t,null)}download(){return this.renderToScreen(),downloadCanvas("image.png"),this}show(){return this.renderToScreen(),this}}class Timer{constructor(){i(this,"startTime",this.time());i(this,"running",!0);i(this,"stoppedTime",0)}time(){return performance.now()/1e3}stop(){!this.running||(this.stoppedTime=this.get(),this.running=!1)}start(){this.running||(this.running=!0,this.set(this.stoppedTime))}toggle(){this.running?this.stop():this.start()}reset(){this.running?this.startTime=this.time():this.stoppedTime=0}set(e){this.running?this.startTime=this.time()-e:this.stoppedTime=e}get(){return this.running?this.time()-this.startTime:this.stoppedTime}}function normalize(o){return o.normalize(),o}class RealtimeRenderer{constructor(e=new __SDF("cube()"),r=new ColorBackground(new THREE__namespace.Color("white"))){i(this,"shader");i(this,"target");i(this,"_background");i(this,"_sdf");i(this,"enableShadows",!0);i(this,"aoStrength",1);i(this,"sunDirection",new THREE__namespace.Vector3(-.5,-2,-1));i(this,"sunColor",new THREE__namespace.Vector3(1,1,1));i(this,"roughness",1);i(this,"epsilon",1e-4);i(this,"adaptiveEpsilon",!0);i(this,"epsilonScale",5e-4);i(this,"color",new THREE__namespace.Color(1,1,1));i(this,"pixelDivisions",1);i(this,"timer",new Timer);i(this,"animationDuration",1);i(this,"lastImage",null);i(this,"postprocess",[]);i(this,"step");const t=new THREE__namespace.Vector2;renderer.getSize(t),this.target=new THREE__namespace.WebGLRenderTarget(t.x,t.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this._sdf=e,this._background=r,this.step=this._sdf.stepCount,this.shader=this.initShader()}set sdf(e){this._sdf=e,this.step=e.stepCount,this.shader.fragmentShader=core+simple+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}set background(e){this._background=e,this.shader.fragmentShader=core+simple+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}get sdf(){return this._sdf}get background(){return this._background}get time(){return this.timer.get()}set time(e){this.timer.set(e)}initShader(){return createShader(core+simple+this._sdf.glsl+this._background.glsl,R(R({rasterizerColor:{value:null},rasterizerDepth:{value:null},sunDirection:{value:normalize(this.sunDirection)},time:{value:0}},Utils.createUniformsFromVariables(this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions")),Utils.objectToUniforms(this._background,"bg_")))}renderImage(e,r,t=0){Queue.cancel(),setAutoResize(!1),setResolution(e,r);const a=new THREE__namespace.Vector2(e,r),s=new THREE__namespace.Vector2(this.target.texture.image.width,this.target.texture.image.height);return a.equals(s)||(this.target.dispose(),this.target=new THREE__namespace.WebGLRenderTarget(a.x,a.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),Utils.setUniformsFromObject(this.shader,this.background,"bg_"),this.shader.uniforms.time.value=t,this.shader.uniforms.sunDirection.value=normalize(this.sunDirection),Utils.setUniformsFromVariables(this.shader,this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions"),render(this.shader,this.target),this.lastImage=new TemporaryImage(this.target),this.lastImage}start(e=()=>{}){setAutoResize(!0),Queue.loop(()=>{e();const r=new THREE__namespace.Vector2;renderer.getSize(r);const t=new THREE__namespace.Vector2(this.target.texture.image.width,this.target.texture.image.height);r.equals(t)||(this.target.dispose(),this.target=new THREE__namespace.WebGLRenderTarget(r.x,r.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),Utils.setUniformsFromObject(this.shader,this.background,"bg_"),this.shader.uniforms.time.value=this.time/this.animationDuration,this.shader.uniforms.rasterizerColor.value=this.target.texture,this.shader.uniforms.sunDirection.value=normalize(this.sunDirection),Utils.setUniformsFromVariables(this.shader,this,"enableShadows","aoStrength","sunColor","sunDirection","epsilon","adaptiveEpsilon","epsilonScale","roughness","color","step","pixelDivisions"),render(this.shader,this.target),this.lastImage=new TemporaryImage(this.target),this.lastImage.postprocess("sRGB",...this.postprocess).show()})}}var pathTracer=`uniform vec2 offset;
uniform vec2 size;

uniform sampler2D previousFrame;
uniform int sampleIndex;
uniform int pixelDivisions;

uniform int rayDepth;
uniform float roughness;
uniform vec3 sunDirection;
uniform float sunStrength;
uniform float backgroundMultiplier;

uniform vec3 color;

uniform vec3 emissionR;
uniform vec3 emissionG;
uniform vec3 emissionB;

#define PI 3.141592653589
#define E 2.718281828459

vec3 ortho(vec3 v) {
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);
}

vec3 getSampleBiased(vec3 dir, float power) {
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));
    vec2 r = rand2();
    r.x = r.x * 2.0 * PI;
    r.y = pow(r.y, 1.0 / (power + 1.0));
    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
} 

vec3 getCosineWeightedSample(vec3 dir) {
    return getSampleBiased(dir, 1.0);
}

vec3 sampleBiased(vec3 normal) {
    return normalize(normal + sphericalRand());
}

vec3 sampleUnbiased(vec3 normal) {
    while(true) {
        vec3 dir = sphericalRand();
        if(dot(normal, dir) > 0.0) return dir;
    }

    return vec3(0);
}

vec3 raytrace(vec3 from, vec3 direction) {
    vec3 direct = vec3(0.0);
    vec3 luminance = vec3(1.0);

    for (int i = 0; i < rayDepth; i++) {
        Ray ray = raycast(from, direction);

        if(ray.hit) {
            
            vec3 reflected = reflect(direction, ray.normal);
            vec3 sampleDir = sampleBiased(ray.normal);
            float lerpFactor = roughness * roughness;

            vec3 c = linear(color);

            direction = normalize(mix(reflected, sampleDir, lerpFactor)); 
            luminance *= clamp(c, 0.0, 1.0) * mix(max(dot(ray.normal, direction), 0.0), 1.0, lerpFactor);

            from = ray.position + ray.normal * epsilon;

            
            vec3 sunSampleDir = normalize(-sunDirection);
            float sunLight = dot(ray.normal, sunSampleDir);

            Ray directLightRay = raycast(from, sunSampleDir);

            if (sunLight > 0.0 && !directLightRay.hit) {
                direct += luminance * sunLight * sunStrength;
            }
        }

        else {
            return direct + luminance * linear(background(direction));
        }
    }
    return direct;
}

vec3 shading() {
    vec3 previousColor = texture2D(previousFrame, gl_FragCoord.xy / resolution).xyz;

    if(
        gl_FragCoord.x < offset.x ||
        gl_FragCoord.y < offset.y ||
        gl_FragCoord.x > offset.x + size.x ||
        gl_FragCoord.y > offset.y + size.y
    ) {
        return previousColor;
    }

   

    int subpixelIndex = sampleIndex % (pixelDivisions * pixelDivisions);
    int subX = subpixelIndex % pixelDivisions;
    int subY = subpixelIndex / pixelDivisions;

    seed = (subpixelCoord(subX, subY, pixelDivisions)) * (1.0 + float(sampleIndex) * 0.001);

    vec3 rayDirection = subpixelDirection(subX, subY, pixelDivisions);

    vec3 pixelColor = raytrace(cameraPos, rayDirection);

    return previousColor * float(sampleIndex) / float(sampleIndex + 1) + pixelColor / float(sampleIndex + 1);

    /*vec3 rayDirection = pixelDirection();

    
    vec3 pixelColor = vec3(0);

    for(int i = 0; i < samplesPerDrawCall; ++i) {
        seed = (1.0 * gl_FragCoord.xy) * (1.0 + float(sampleIndex) * 0.1);
        pixelColor += raytrace(cameraPos, rayDirection);
    }

    
    return previousColor * float(sampleIndex) / float(sampleIndex + samplesPerDrawCall) + pixelColor / float(sampleIndex + samplesPerDrawCall);*/
}`;function autoBufferSize(o,e){let r=o,t=e,a=1,s=1;for(;o*e>16e5;)o>e?o=r/++a:e=t/++s;return{x:o,y:e}}function humanReadableTime(o){const e=Math.floor(o%1e3),r=Math.floor(o/1e3%60),t=Math.floor(r/60%60),a=Math.floor(t/60);return`${a>0?`${a}h `:""}${t>0?`${t}m `:""}${r>0?`${r}s `:""}${e>0?`${e%1e3}ms`:""}`}class PathTracer{constructor(e=new __SDF("cube()"),r=new ColorBackground(new THREE__namespace.Color("white"))){i(this,"textures",[]);i(this,"shader");i(this,"_background");i(this,"_sdf");i(this,"pixelDivisions",1);i(this,"roughness",1);i(this,"sunDirection",new THREE__namespace.Vector3(-.5,-2,-1));i(this,"sunStrength",1);i(this,"backgroundMultiplier",1);i(this,"rayDepth",5);i(this,"epsilon",1e-6);i(this,"bufferSize");i(this,"lastImage",null);i(this,"color",new THREE__namespace.Color(1,1,1));i(this,"step");const t=new THREE__namespace.Vector2;renderer.getSize(t),this.textures=[new THREE__namespace.WebGLRenderTarget(t.x,t.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),new THREE__namespace.WebGLRenderTarget(t.x,t.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})],this._sdf=e,this._background=r,this.step=this._sdf.stepCount,this.shader=this.initShader()}set sdf(e){this._sdf=e,this.step=e.stepCount,this.shader.fragmentShader=core+pathTracer+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0}set background(e){this.shader.fragmentShader=core+pathTracer+this._sdf.glsl+this._background.glsl,this.shader.needsUpdate=!0,this._background=e}get sdf(){return this._sdf}get background(){return this._background}initShader(){return createShader(core+pathTracer+this._sdf.glsl+this._background.glsl,R(R({previousFrame:{value:this.textures[0].texture},sampleIndex:{value:0},offset:{value:new THREE__namespace.Vector2(0,0)},size:{value:new THREE__namespace.Vector2(0,0)},adaptiveEpsilon:{value:!1},time:{value:0}},Utils.createUniformsFromVariables(this,"sunDirection","sunStrength","roughness","rayDepth","pixelDivisions","color","epsilon","backgroundMultiplier","step")),Utils.objectToUniforms(this._background,"bg_")))}renderImage(e,r,t=0){const a=this.bufferSize?{x:this.bufferSize,y:this.bufferSize}:autoBufferSize(e,r),s=performance.now();return new Promise((d,c)=>{setAutoResize(!1),setResolution(e,r);const h=new THREE__namespace.Vector2(e,r),u=new THREE__namespace.Vector2(this.textures[0].texture.image.width,this.textures[0].texture.image.height);h.equals(u)||(this.textures[0].dispose(),this.textures[1].dispose(),this.textures=[new THREE__namespace.WebGLRenderTarget(h.x,h.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),new THREE__namespace.WebGLRenderTarget(h.x,h.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})]),renderer.setRenderTarget(this.textures[0]),renderer.clear(),renderer.setRenderTarget(this.textures[1]),renderer.clear(),Utils.setUniformsFromObject(this.shader,this.background,"bg_");const p=Math.ceil(e/a.x),v=Math.ceil(r/a.y);let g=0,b=0,E=0;const T=()=>{document.visibilityState==="hidden"?console.log("Render task paused"):console.log("Render task resumed")},y=setInterval(()=>{document.addEventListener("visibilitychange",T),document.visibilityState==="visible"&&console.log(`Render task: ${Math.floor(E/(this.pixelDivisions*this.pixelDivisions)*100)}%`)},1e3);Queue.loop(()=>{if(this.shader.uniforms.adaptiveEpsilon.value=!1,this.shader.uniforms.previousFrame.value=this.textures[1].texture,this.shader.uniforms.sampleIndex.value=E,this.shader.uniforms.offset.value=new THREE__namespace.Vector2(g*a.x,b*a.y),this.shader.uniforms.size.value=new THREE__namespace.Vector2(a.x,a.y),this.shader.uniforms.time.value=t,Utils.setUniformsFromVariables(this.shader,this,"sunDirection","sunStrength","roughness","rayDepth","pixelDivisions","color","epsilon","backgroundMultiplier","step"),render(this.shader,this.textures[0]),new TemporaryImage(this.textures[0]).postprocess("sRGB").show(),this.textures=[this.textures[1],this.textures[0]],++g,g>=p&&(g=0,++b),b>=v&&(b=0,E+=1),E>=this.pixelDivisions*this.pixelDivisions){const S=performance.now()-s;console.log("Render task: 100%"),console.log(`Rendering done in ${humanReadableTime(S)}`),console.log(`Render Size: ${Math.floor(this.pixelDivisions*this.pixelDivisions*e*r/1e5)/10} megapixels`),console.log(`Render Speed: ${Math.floor(this.pixelDivisions*this.pixelDivisions*e*r/S/10)/100} megapixels per second`),Queue.cancel()}},()=>{clearInterval(y),document.removeEventListener("visibilitychange",T),this.lastImage=new TemporaryImage(this.textures[1]).postprocess("sRGB"),E>=this.pixelDivisions*this.pixelDivisions?d(this.lastImage):c(new Error("Render task cancelled"))})})}async renderAnimation(e,r,t,a){const s=[],d=[];function c(){const u=`${h}-${h+s.length-1}.json`;downloadJSON(s,u),d.push(u),h+=s.length,s.length=0}let h=1;for(let u=0;u<t.length;u++){s.length===50&&c();const p=t[u];camera.position.copy(p.position),camera.lookAt(p.position.clone().add(p.direction)),(await this.renderImage(e,r,p.time)).postprocess(...a).show(),s.push(renderer.domElement.toDataURL()),console.log(`Frame ${u+1}/${t.length} done`)}c(),downloadJSON({files:d,totalFrames:t.length},"header.json")}}class Menger extends __SDF{constructor(e){super(`
      cube();
      for (let i = 0; i < ${e}; i++) {
          scale(1 / 3);
          translate(0, 0, -1 / 3);
          mirror(0, 0, 1);
          translate(0, 0, 1 / 3);

          translate(-2 / 3, 2 / 3, 0);

          mirror(0, -1, 1);
          mirror(1, 0, 1);
          mirror(0, 0, -1);
          mirror(1, 0, 0);
          mirror(0, -1, 0);
      }
    `);this.iterations=e}}class Sierpinski extends __SDF{constructor(e){super(`
        tetrahedron();

        for (let i = 0; i < ${e}; i++) {
            translate(-1, -1, -1);
            
            scale(1 / 2);
            
            translate(1, 1, 1);
        }
    `);this.iterations=e}}var position=`vec3 shading() {
    return pixelRaycast().position;
}`,normal=`vec3 shading() {
    return pixelRaycast().normal;
}`,edges=`uniform sampler2D positionTexture;
uniform sampler2D normalTexture;

uniform vec3 backgroundColor;
uniform vec3 lineColor;

struct Pixel {
    vec3 position;
    vec3 normal;
};

Pixel pixel(int x, int y) {
    vec2 uv = (gl_FragCoord.xy + vec2(x, y)) / resolution;

    Pixel pixel;
    pixel.position = texture2D(positionTexture, uv).xyz;
    pixel.normal = texture2D(normalTexture, uv).xyz;

    return pixel;
}

vec3 shading() {
    

    Pixel center = pixel(0, 0);

    float distanceFromCamera = length(center.position - cameraPos);

    if(distanceFromCamera < 2.0 * epsilon) return backgroundColor; 

    bool edge = false;

    for(int x = 0; x <= 1; ++x) {
        for(int y = 0; y <= 1; ++y) {
            Pixel nearby = pixel(x, y);

            float dist = length(nearby.position - center.position);
            vec3 towards = normalize(nearby.position - center.position);

            if(
                dot(center.normal, nearby.normal) < 0.5 && center.normal != vec3(0)||
                abs(dot(center.normal, towards)) > max(distanceFromCamera * 0.3, 0.1) && dist > 2.0 * epsilon ||
                center.normal == vec3(0) && nearby.normal != vec3(0)
            )
                edge = true;
        }
    }

    
    return edge ? lineColor : backgroundColor;
}`,expandLines=`uniform float lineWidth;
uniform vec3 lineColor;
uniform vec3 backgroundColor;
uniform sampler2D linesTexture;

vec3 pixel(int x, int y) {
    return texture2D(linesTexture, (gl_FragCoord.xy + vec2(x, y)) / resolution).xyz;
}

vec3 shading() {
    float radius = max(0.0, (min(lineWidth, 10.0) - 1.0) * 0.5);
    int grid = int(ceil(radius));

    for(int x = -grid; x <= grid; ++x) {
        for(int y = -grid; y <= grid; ++y) {
            if(sqrt(float(x * x + y * y)) <= radius && pixel(x, y) == lineColor) {
                return lineColor;
            } 
        }
    }
    return backgroundColor;
}`;class EdgeRenderer{constructor(e=new __SDF("cube()")){i(this,"positionShader");i(this,"normalShader");i(this,"edgesShader");i(this,"expandShader");i(this,"position");i(this,"normal");i(this,"edges");i(this,"expanded");i(this,"_sdf");i(this,"step");i(this,"epsilon",1e-5);i(this,"backgroundColor",new THREE__namespace.Color(1,1,1));i(this,"lineColor",new THREE__namespace.Color(0,0,0));i(this,"lineWidth",1);const r=new THREE__namespace.Vector2;renderer.getSize(r),this.position=new THREE__namespace.WebGLRenderTarget(r.x,r.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(r.x,r.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(r.x,r.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(r.x,r.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this._sdf=e,this.step=e.stepCount;const t={epsilon:{value:this.epsilon},step:{value:this.step}};this.positionShader=createShader(core+position+e.glsl,t),this.normalShader=createShader(core+normal+e.glsl,t),this.edgesShader=createShader(core+edges+e.glsl,W(R({},Utils.createUniformsFromVariables(this,"backgroundColor","lineColor")),{positionTexture:{value:this.position.texture},normalTexture:{value:this.normal.texture}})),this.expandShader=createShader(core+expandLines+e.glsl,W(R({},Utils.createUniformsFromVariables(this,"backgroundColor","lineColor","lineWidth")),{linesTexture:{value:this.edges.texture}}))}set sdf(e){this._sdf=e,this.step=e.stepCount,this.positionShader.fragmentShader=core+position+this._sdf.glsl,this.normalShader.fragmentShader=core+normal+this._sdf.glsl,this.positionShader.needsUpdate=!0,this.normalShader.needsUpdate=!0}setUniforms(e){e.uniforms.epsilon.value=this.epsilon,e.uniforms.step.value=this.step}renderImage(e,r){return new Promise(t=>{Queue.once(()=>{setAutoResize(!1),setResolution(e,r);const a=new THREE__namespace.Vector2(e,r),s=new THREE__namespace.Vector2(this.position.texture.image.width,this.position.texture.image.height);a.equals(s)||(this.position.dispose(),this.normal.dispose(),this.edges.dispose(),this.expanded.dispose(),this.position=new THREE__namespace.WebGLRenderTarget(a.x,a.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(a.x,a.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(a.x,a.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(a.x,a.y,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})),this.setUniforms(this.positionShader),render(this.positionShader,this.position),this.setUniforms(this.normalShader),render(this.normalShader,this.normal),this.edgesShader.uniforms.positionTexture.value=this.position.texture,this.edgesShader.uniforms.normalTexture.value=this.normal.texture,Utils.setUniformsFromVariables(this.edgesShader,this,"backgroundColor","lineColor"),render(this.edgesShader,this.edges),this.expandShader.uniforms.linesTexture.value=this.edges.texture,Utils.setUniformsFromVariables(this.expandShader,this,"backgroundColor","lineColor","lineWidth"),render(this.expandShader,this.expanded),copyAA(this.expanded,null),t()})})}start(){setAutoResize(!0),Queue.loop(()=>{const e=new THREE__namespace.Vector2;renderer.getSize(e);const r=new THREE__namespace.Vector2(this.position.texture.image.width,this.position.texture.image.height);if(!e.equals(r)){this.position.dispose(),this.normal.dispose(),this.edges.dispose(),this.expanded.dispose();const t=Math.floor(e.x),a=Math.floor(e.y);this.position=new THREE__namespace.WebGLRenderTarget(t,a,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.normal=new THREE__namespace.WebGLRenderTarget(t,a,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.edges=new THREE__namespace.WebGLRenderTarget(t,a,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType}),this.expanded=new THREE__namespace.WebGLRenderTarget(t,a,{format:THREE__namespace.RGBAFormat,type:THREE__namespace.FloatType})}this.setUniforms(this.positionShader),render(this.positionShader,this.position),this.setUniforms(this.normalShader),render(this.normalShader,this.normal),this.edgesShader.uniforms.positionTexture.value=this.position.texture,this.edgesShader.uniforms.normalTexture.value=this.normal.texture,Utils.setUniformsFromVariables(this.edgesShader,this,"backgroundColor","lineColor"),render(this.edgesShader,this.edges),this.expandShader.uniforms.linesTexture.value=this.edges.texture,Utils.setUniformsFromVariables(this.expandShader,this,"backgroundColor","lineColor","lineWidth"),render(this.expandShader,this.expanded),copyAA(this.expanded,null)})}}exports.ColorBackground=ColorBackground,exports.EdgeRenderer=EdgeRenderer,exports.HemisphereBackground=HemisphereBackground,exports.ImageBackground=ImageBackground,exports.Menger=Menger,exports.PathTracer=PathTracer,exports.Queue=Queue,exports.RealtimeRenderer=RealtimeRenderer,exports.SDF=__SDF,exports.Sierpinski=Sierpinski,exports.camera=camera,exports.controls=controls,exports.fullscreen=fullscreen,exports.init=init,Object.defineProperty(exports,"__esModule",{value:!0}),exports[Symbol.toStringTag]="Module"});
